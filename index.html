<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Punk Voyage Adventures</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@sats-connect/core@latest/dist/bundles/sats-connect.js"></script>
    <style>
    html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow-x: hidden; /* Prevent horizontal scrollbars if content slightly overflows */
}

body {
    font-family: 'VT323', monospace;
    background-color: #f4f4f4; /* Light mode background */
    color: var(--text-color);
    font-size: var(--base-font-size);
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh; /* Ensure it takes at least full viewport height */
    box-sizing: border-box;
    transition: color 0.3s, background-color 0.3s;
}
body.dark-mode {
    background-color: #141414; /* Dark mode background */
}

.game-container,
.leaderboard-container,
.inventory-items-container,
.upgrade-interface,
.crafting-items-container,
.shop-items-container,
.page-content {
    background: none !important;
    border: none !important;
    box-shadow: none !important;
}

        :root {
    --body-bg-image-url: none;
            --border-color: #000000;
            --text-color: #000000;
            --label-color: #333333; 
            --header-text-color: #333333;
            --game-container-bg: rgba(255, 255, 255, 0.9); 
            --section-bg: rgba(255, 255, 255, 0.8);
            --adventure-block-bg: rgba(255, 255, 255, 0.75);
            --button-bg: #E0E0E0;
            --button-text-color: #000000;
            --button-border: #000000;
            --dropdown-bg: #FFFFFF;
            --twitter-feed-bg: rgba(255, 255, 255, 0.7);
            --highlight-color-pv: #00FF00; 
            --highlight-color-gold: #FFFF00;
            --highlight-color-diamond: #00BFFF; 
            --highlight-color-danger: #FF0000; 
            --highlight-color-connected: #4CAF50;
            --quest-available-outline: #00E676; /* Bright Green */
            --quest-completed-outline: #F44336; /* Red (similar to danger) */
            --orange-label: #FFA500; 
            --base-font-size: 18px;
            --item-icon-size: 40px; /* Consistent item icon size */
            --menu-icon-size: 1.1em; /* Consistent menu icon size */
            --item-placeholder-boots: #8B4513; --item-placeholder-amulet: #FFD700; 
            --item-placeholder-armour: #C0C0C0; --item-placeholder-helmet: #A9A9A9;
            --item-placeholder-ring: #B8860B; --item-placeholder-weapon: #778899;
            --item-placeholder-misc: #DA70D6; 
            --item-placeholder-pet: #32CD32; /* LimeGreen for Pet slot */
            --item-upgrade-plus1-border: #00FF00; /* Bright Green */
            --item-upgrade-plus2-border: #0000FF; /* Blue */
            --item-upgrade-plus3-border: #BF00BF; /* Bright Purple (MediumOrchid/DarkMagenta like) */
            --item-upgrade-plus4-border: #FFA500; /* Orange */
            --item-upgrade-plus5-border: #DC143C; /* Dark Red */
        }

        body {
            font-family: 'VT323', monospace;
            background-image: var(--body-bg-image-url);
            background-size: cover; background-position: center; background-repeat: no-repeat; background-attachment: fixed;
            color: var(--text-color);
            margin: 0; font-size: var(--base-font-size);
            display: flex; flex-direction: column;
            align-items: center; min-height: 100vh; box-sizing: border-box;
            transition: color 0.3s, background-color 0.3s;
        }

        body.dark-mode {
            --border-color: #777777; 
            --text-color: #FFFFFF;
            --label-color: var(--orange-label); 
            --header-text-color: var(--orange-label); 
            --game-container-bg: rgba(20, 20, 20, 0.9); 
            --section-bg: rgba(30, 30, 30, 0.85);
            --adventure-block-bg: rgba(40, 40, 40, 0.8);
            --button-bg: #444444;
            --button-text-color: #FFFFFF;
            --button-border: #666666;
            --dropdown-bg: #333333;
            --twitter-feed-bg: rgba(25, 25, 25, 0.7);
--item-upgrade-plus1-border: #32CD32; /* LimeGreen for dark mode */
        --item-upgrade-plus2-border: #4169E1; /* RoyalBlue for dark mode */
        --item-upgrade-plus3-border: #DA70D6; /* Orchid for dark mode */
        --item-upgrade-plus4-border: #FF8C00; 
        --item-upgrade-plus5-border: #FF4500; 
        }

        .hidden { display: none !important; }
        .craft-button.craftable {
            background-color: var(--highlight-color-connected) !important; /* Green */
            color: white !important;
            border-color: var(--highlight-color-connected) !important;
        }

        .craft-button.owned {
            background-color: var(--orange-label) !important; /* Orange */
            color: black !important; /* Or white, depending on what looks better on orange */
            border-color: var(--orange-label) !important;
            cursor: not-allowed !important;
        }

        /* Optional: Hover for craftable button to make it slightly darker green */
        body:not(.dark-mode) .craft-button.craftable:hover {
            background-color: #388E3C !important; /* Darker green for light mode */
        }
        body.dark-mode .craft-button.craftable:hover {
            background-color: #367c39 !important; /* Darker green for dark mode */
        }

        /* Ensure disabled (which 'owned' will also be) has a distinct style if not already covered */
        .craft-button[disabled] { /* This might already exist, ensure it's not overridden or make it more specific */
            opacity: 0.7;
        }
        #daily-rewards-page .reward-day.daily-reward-claimable {
            border-color: var(--quest-available-outline) !important; /* Use your existing green */
            box-shadow: 0 0 8px var(--quest-available-outline);
        }

        #daily-rewards-page .reward-day.daily-reward-claimed {
            border-color: var(--quest-completed-outline) !important; /* Use your existing red */
            box-shadow: 0 0 8px var(--quest-completed-outline);
            opacity: 0.8; /* Optional: make claimed less prominent */
        }

        /* Optional: Make the button more prominent when claimable */
        #daily-rewards-page .reward-day.daily-reward-claimable .claim-daily-reward-btn:not([disabled]) {
            background-color: var(--highlight-color-connected);
            color: white;
            border-color: var(--highlight-color-connected);
        }
        
        #customPopupOverlay, #itemSelectionModalOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8); 
            display: flex; 
            justify-content: center; align-items: center;
        }
        #customPopupOverlay { z-index: 2000; }
        #itemSelectionModalOverlay { z-index: 2005; } 

        #customPopup, #itemSelectionModal { 
            background-color: var(--section-bg); border: 3px solid var(--border-color);
            padding: 25px; border-radius: 10px; 
            text-align: center;
            min-width: 350px; max-width: 80%; width: auto; 
            box-shadow: 0 5px 20px rgba(0,0,0,0.4); font-family: 'VT323', monospace;
            color: var(--text-color); box-sizing: border-box;
            position: fixed; 
            top: 50%; left: 50%;
            transform: translate(-50%, -50%); 
        }
        #customPopup { z-index: 2001; }
        #itemSelectionModal { 
            z-index: 2006; 
            max-width: 600px; 
            max-height: 70vh; 
            overflow-y: auto;
        }

        #customPopupTitle, #itemSelectionModalTitle { 
            font-size: 1.8em; margin-top: 0; margin-bottom: 15px;
            color: var(--label-color); 
        }
        #customPopupMessage { font-size: 1.1em; margin-bottom: 25px; line-height: 1.6; white-space: pre-wrap; text-align: left; }
        #customPopupButtons { display: flex; justify-content: center; gap: 15px;}
        #customPopupCloseBtn, #itemSelectionModalCloseBtn, #popupCraftAgainBtn, #customPopupConfirmBtn, #customPopupCancelBtn { font-size: 1.2em; padding: 10px 20px; min-width: 100px; margin-top: 15px; }
        #popupCraftAgainBtn, #customPopupConfirmBtn { background-color: var(--highlight-color-connected); color:white;}


                .game-container {
            width: 100%; /* Fill full width */
            min-height: 100vh; /* Ensure it takes at least full viewport height */
            margin: 0; /* Remove top/bottom and auto side margins */
            border: 3px solid var(--border-color);
            padding: 15px;
            background-color: var(--game-container-bg);
            box-shadow: 0px 0px 15px rgba(0,0,0,0.5);
            box-sizing: border-box; /* Important! */
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, border-color 0.3s;
        }
        header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 15px; border-bottom: 2px solid var(--border-color); margin-bottom: 15px; width: 100%; transition: border-color 0.3s; }
        .header-title-container { display: flex; align-items: center; margin-right: auto; }
        .header-title-container img.header-logo { height: 80px; width: auto; margin-right: 15px; }
        header h1 { font-size: 2.5em; margin: 0; letter-spacing: 2px; color: var(--header-text-color); transition: color 0.3s; flex-shrink: 0; }
        .header-byline { font-size: 0.9em; color: white; margin-left: 10px; font-weight: normal; align-self: flex-end; padding-bottom: 5px; }
        body:not(.dark-mode) .header-byline { color: #333333; }

        .header-controls { display: flex; align-items: center; gap: 15px;  }
        .player-info-wallet { display: flex; flex-direction: column; align-items: flex-end; gap: 5px; }
        .player-stats { text-align: right; font-size: 1em; } 
        .player-stats .pv { color: var(--highlight-color-pv); font-weight: bold; } 
        .player-stats .gold { color: var(--highlight-color-gold); font-weight: bold; } 
        .player-stats .diamond { color: var(--highlight-color-diamond); font-weight: bold; }
        .player-stats .wallet-address { font-size: 0.9em; color: var(--highlight-color-connected); word-break: break-all; }
        .wallet-connector { position: relative; }
        .connect-wallet-btn, .menu-button, .social-btn-link button, .adventure-send-btn, .action-button, .craft-button, .equip-btn, .unequip-btn, .swap-btn, .raffle-action-btn, #signOutButton, #upgradeItemButton, .leaderboard-filter-btn, .use-rider-scroll-btn { background-color: var(--button-bg); border: 2px solid var(--button-border); padding: 6px 12px; color: var(--button-text-color); cursor: pointer; font-family: 'VT323', monospace; font-size: 1em; text-align: center; transition: background-color 0.3s, border-color 0.3s, color 0.3s; }
        .connect-wallet-btn, .menu-button, #signOutButton { min-width: 160px; }
        #signOutButton { background-color: var(--highlight-color-danger); color: white; border-color: var(--highlight-color-danger); }
        body:not(.dark-mode) #signOutButton:hover { background-color: #cc0000; }
        body.dark-mode #signOutButton:hover { background-color: #dd0000; }
        .leaderboard-filter-btn.active-type-filter {
    background-color: var(--highlight-color-gold);
    color: black;
    border-color: var(--highlight-color-gold);
}
.upgrade-booster-text {
    color: #00FF00; /* Bright Neon Green */
    font-weight: bold;
}

.craftable-toggle-checkmark {
    margin-left: 8px;
    font-size: 0.9em;
    display: none; /* Hidden by default */
}

.leaderboard-filter-btn.active .craftable-toggle-checkmark {
    display: inline; /* Show the checkmark when the button is active */
}
        .leaderboard-filter-btn.active { background-color: var(--highlight-color-connected); color: white; }
        .use-rider-scroll-btn { font-size: 0.85em; padding: 3px 6px; margin-top: 5px; }


        .header-controls .socials-nav { padding: 0; border: none; background-color: transparent; display: flex; align-items: center; gap: 10px; }
        .header-controls .socials-nav .social-title { font-size: 1.1em; margin-bottom: 0; }
        .header-controls .socials-nav .social-buttons { gap: 10px; display: flex; align-items: center; }
        .social-icon-link img { height: 30px; width: auto; vertical-align: middle; border: 1px solid var(--button-border); padding: 3px; background-color: var(--button-bg); border-radius: 4px; transition: filter 0.2s; }
        .social-icon-link img:hover { filter: brightness(0.85); }

        body:not(.dark-mode) .connect-wallet-btn:hover, body:not(.dark-mode) .menu-button:hover, body:not(.dark-mode) .social-btn-link button:hover, body:not(.dark-mode) .adventure-send-btn:hover, body:not(.dark-mode) .action-button:hover, body:not(.dark-mode) .craft-button:hover, body:not(.dark-mode) .equip-btn:hover, body:not(.dark-mode) .unequip-btn:hover, body:not(.dark-mode) .swap-btn:hover, body:not(.dark-mode) .raffle-action-btn:hover, body:not(.dark-mode) #upgradeItemButton:hover, body:not(.dark-mode) .leaderboard-filter-btn:not(.active):hover, body:not(.dark-mode) .use-rider-scroll-btn:hover { background-color: #cccccc; }
        body.dark-mode .connect-wallet-btn:hover, body.dark-mode .menu-button:hover, body.dark-mode .social-btn-link button:hover, body.dark-mode .adventure-send-btn:hover, body.dark-mode .action-button:hover, body.dark-mode .craft-button:hover, body.dark-mode .equip-btn:hover, body.dark-mode .unequip-btn:hover, body.dark-mode .swap-btn:hover, body.dark-mode .raffle-action-btn:hover, body.dark-mode #upgradeItemButton:hover, body.dark-mode .leaderboard-filter-btn:not(.active):hover, body.dark-mode .use-rider-scroll-btn:hover { background-color: #555555;}
        .connect-wallet-btn.connected { background-color: var(--highlight-color-connected); color: white; border-color: var(--highlight-color-connected); }
        .wallet-dropdown { display: none; position: absolute; top: 100%; right: 0; background-color: var(--dropdown-bg); color: var(--text-color); border: 2px solid var(--border-color); list-style: none; padding: 0; margin: 5px 0 0 0; width: 100%; z-index: 10; box-shadow: 0px 3px 7px rgba(0,0,0,0.2); transition: background-color 0.3s, border-color 0.3s, color 0.3s; }
        .wallet-dropdown li { padding: 8px 12px; cursor: pointer; border-bottom: 1px solid var(--border-color); text-align: center; transition: background-color 0.3s, border-color 0.3s; } .wallet-dropdown li:last-child { border-bottom: none; }
        body:not(.dark-mode) .wallet-dropdown li:hover { background-color: #f0f0f0; } body.dark-mode .wallet-dropdown li:hover { background-color: #4a4a4a; }
        .main-content { 
    display: flex; 
    gap: 20px; 
    width: 100%; 
    flex-grow: 1; 
    align-items: flex-start; /* This new line fixes the layout */
}        .left-sidebar { width: 300px; display: flex; flex-direction: column; gap: 20px; flex-shrink: 0; }
        .twitter-feed-container { border: 2px solid var(--border-color); padding: 10px; background-color: var(--twitter-feed-bg); height: auto; min-height: 250px; overflow-y: auto; display: flex; flex-direction: column; transition: background-color 0.3s, border-color 0.3s; margin-top: 20px; }
        .twitter-feed-container .twitter-timeline { width: 100% !important; }
        #availableAdventurersDisplay, .materials-display, #playerCombatStatsDisplay { border: 2px solid var(--border-color); padding: 10px; background-color: var(--section-bg); transition: background-color 0.3s, border-color 0.3s; }
        #availableAdventurersDisplay, #playerCombatStatsDisplay { text-align:center; font-size: 1.2em; } 
        #playerCombatStatsDisplay h4 {font-size: 1.2em; margin-top:0; margin-bottom: 8px; color: var(--label-color);}
        #playerCombatStatsDisplay p {font-size: 1em; margin: 5px 0;}

        .socials-nav .social-title, .adventure-controls label, .page-title, .materials-display h4, .adventures-label, #activeAdventuresDisplay_page h3, 
        .equipment-slots-container h4, #inventory-page > h4, .shop-section-wrapper h3, #crafting-page h2, .swap-section h3, #whitelist-page h3, #upgrade-page h3, #leaderboard-page h3, #dungeons-page h3 {  color: var(--label-color); font-weight: bold; transition: color 0.3s; }
        .materials-display h4 {font-size: 1.2em; margin-top:0; margin-bottom: 8px;} 
        .materials-display .material-tier-title, .materials-display .upgrade-scrolls-title { font-size: 1.1em; font-weight: bold; margin-top:10px; margin-bottom:5px; color: var(--label-color); }
        .materials-display .upgrade-scrolls-title { color: var(--highlight-color-pv); } 
        body.dark-mode .materials-display .upgrade-scrolls-title { color: var(--highlight-color-pv); }

        .materials-display ul { list-style: none; padding: 0; margin: 5px 0 0 0; font-size: 1em; } .materials-display li { margin-bottom: 3px; }
          #specialtiesListContainer ul {
        list-style: disc; /* Use disc bullets for specialties */
        padding-left: 20px; /* Indent list items */
        margin: 10px 0 5px 0; /* Adjust margins */
        font-size: 0.9em;   /* Slightly smaller font */
    }
    #specialtiesListContainer li {
        margin-bottom: 5px; /* Space between specialty items */
        line-height: 1.4;   /* Adjust line height for readability */
    }
    .specialty-source { /* To style the "(from Item Name)" part */
        font-size: 0.85em;
        opacity: 0.7;
        margin-left: 5px;
        font-style: italic;
    }
        .main-content-area { flex-grow: 1; display: flex; }
        .page-content { display: none; width: 100%; flex-direction: column; padding: 0 15px; box-sizing: border-box; overflow-y: auto; flex-grow: 1;} 
        .page-content.active { display: flex; }

        #adventures-page { flex-direction: row; align-items: flex-start; gap: 25px; padding:0; }
        .player-character-area { display: none; }
        .adventure-section-wrapper { display: flex; flex-direction: column; flex-grow: 1; align-items: center; } 
        .adventures-label { font-size: 2em; margin-bottom: 10px; text-align: center; width: 100%; }
        #adventureMilestoneInfo { text-align: center; font-size: 0.95em; margin-bottom: 15px; color: var(--highlight-color-diamond); }
        .adventure-locations { width: 100%; display: flex; flex-direction: column; align-items: center; gap: 20px; }
        .adventure { display: flex; align-items: center; gap: 20px; width: 100%; max-width: 800px; background-color: var(--adventure-block-bg); padding: 20px; border-radius: 8px; border: 1px solid var(--border-color); box-sizing: border-box; transition: background-color 0.3s, border-color 0.3s; position: relative; }
        .adventure-lock-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(30, 30, 30, 0.85); color: var(--highlight-color-danger); display: flex; justify-content: center; align-items: center; text-align: center; font-size: 1.1em; font-weight: bold; padding: 15px; box-sizing: border-box; border-radius: 8px; z-index: 5; line-height: 1.4; }
        .adventure-lock-overlay.hidden { display: none; }
        .adventure.locked-by-progression .adventure-send-btn, .adventure.locked-by-progression .adventure-num-select { filter: grayscale(100%) opacity(0.7); cursor: not-allowed !important; }
        .adventure-icon { width: 150px; height: 150px; border: 2px solid var(--border-color); background-size: cover; background-position: center; background-repeat: no-repeat; flex-shrink: 0; border-radius: 5px; transition: border-color 0.3s; }
        .adventure-icon.tree { background-image: url('https://raw.githubusercontent.com/nvoiy/pvadventures/main/adventure1.jpg'); } 
        .adventure-icon.mountain { background-image: url('https://raw.githubusercontent.com/nvoiy/pvadventures/main/adventure2.jpg'); } 
        .adventure-icon.fire-fields { background-image: url('https://raw.githubusercontent.com/nvoiy/pvadventures/main/adventure3.jpg'); }
        .adventure-icon.tomb { background-image: url('https://raw.githubusercontent.com/nvoiy/pvadventures/main/adventure4.jpg'); }
        .adventure-icon.adventure-5-icon { background-image: url('https://raw.githubusercontent.com/nvoiy/pvadventures/main/imgnew%20(2).jpg'); }
        .adventure-main-info { flex-grow: 1; display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; } 
        .adventure-content { display: flex; flex-direction: column; gap: 10px; } 
        .adventure-details { font-size: 1.1em; line-height: 1.5; } 
        .adventure-details .prize { color: var(--highlight-color-pv); font-weight: bold; } 
        .adventure-details .chance-gold { color: var(--highlight-color-gold); font-weight: bold; } 
        .adventure-details .chance-diamond { color: var(--highlight-color-diamond); font-weight: bold; }
        .adventure-requirement { color: var(--highlight-color-danger); font-weight: bold; font-size: 0.9em; margin-top: 5px;}
        .adventure-controls { display: flex; align-items: center; gap: 12px; margin-top: 10px; } 
        .adventure-controls label { font-size: 1.1em; } 
        .adventure-num-select { font-family: 'VT323', monospace; font-size: 1em; padding: 4px; border: 2px solid var(--border-color); background-color: var(--dropdown-bg); color: var(--text-color); min-width: 40px; transition: background-color 0.3s, border-color 0.3s, color 0.3s; } 
        .adventure-send-btn { padding: 6px 10px; font-size: 1em; } 
        .adventure-send-btn.active-adv1 { background-color: var(--highlight-color-pv); color: black;} 
        .adventure-send-btn.active-adv2 { background-color: var(--highlight-color-gold); color: black;} 
        .adventure-send-btn.active-adv3, .adventure-send-btn.active-adv4 { background-color: var(--highlight-color-danger); color: white;}
        .adventure-drops-area { position: relative; align-self: flex-start; min-height: 100px; } 
        .adventure-drops-button { font-size: 1em; padding: 4px 10px; } 
        .drops-popover { display: none; position: absolute; top: calc(100% + 5px); left: 50%; transform: translateX(-50%); background-color: var(--section-bg); border: 1px solid var(--border-color); padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 20; width: 220px; min-width: 180px; font-size: 1em; text-align: left; transition: background-color 0.3s, border-color 0.3s; } 
        .drops-popover h5 { margin: 0 0 5px 0; color: var(--label-color); transition: color 0.3s;} 
        .drops-popover ul { list-style: none; padding: 0; margin: 0; } 
        .drops-popover li { margin-bottom: 3px; }
        
        #active-adventures-page .active-adventures-container { margin-top: 0; width:100%; max-width:none; padding: 10px; border: none; background-color: transparent; box-shadow:none; }
        #active-adventures-page .active-adventures-container h3 { font-size: 1.6em; text-align:left; margin-bottom:10px;}
        #active-adventures-page .active-adventure-item { font-size:1em; padding:10px; background-color: var(--adventure-block-bg); border: 1px solid var(--border-color); border-radius: 4px; margin-bottom: 8px;}
        #active-adventures-page .active-adventure-item p { margin: 4px 0; font-size: 1.1em; line-height: 1.6; }
        
        .right-sidebar-menu { width: 300px; flex-shrink: 0; display: flex; flex-direction: column; gap: 0; border: 2px solid var(--border-color); background-color: var(--section-bg); padding: 10px; box-sizing: border-box; transition: background-color 0.3s, border-color 0.3s; }
        
        .right-sidebar-menu .menu-button { min-width: auto; width: 85%; padding: 10px 15px; font-size: 1.4em; }
         /* Hide the menu button by default on desktop screens */
        #mainMenuToggleBtn {
            display: none;
        }

        /* Hide the container for the button on desktop */
        .header-controls .menu-button-container-fixed {
            display: none;
        }

        .sidebar-content-area { flex-grow: 1; overflow-y: auto; }
        .main-menu-nav-list { list-style: none; padding: 0; margin: 0; }
        .main-menu-nav-list li { padding: 12px 8px; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: border-color 0.3s, background-color 0.3s; font-size: 1.25em; text-align: left; display: flex; align-items: center; justify-content: flex-start; gap: 8px;}
        .main-menu-nav-list li img.menu-item-icon { height: var(--menu-icon-size); width: var(--menu-icon-size); object-fit: contain; vertical-align: middle; }
        .main-menu-nav-list li:last-child { border-bottom: none; } body:not(.dark-mode) .main-menu-nav-list li:hover { background-color: #f0f0f0; } body.dark-mode .main-menu-nav-list li:hover { background-color: #4a4a4a; }
        
        .sidebar-active-adventures-container { padding-top: 10px; } 
        .sidebar-active-adventures-container h3 { font-size: 1.3em; text-align: center; margin-bottom: 10px; color: var(--label-color); }
        .sidebar-active-adventures-container .active-adventure-item { display: flex; justify-content: space-between; align-items: center; font-size: 0.95em; padding: 8px; margin-bottom: 8px; background-color: var(--adventure-block-bg); border: 1px solid var(--border-color); border-radius: 4px; }
        .sidebar-active-adventures-container .active-adventure-item-info { flex-grow: 1; }
        .sidebar-active-adventures-container .active-adventure-item p { margin: 3px 0; }
        .cancel-adventure-btn { background-color: transparent; border: none; color: var(--highlight-color-danger); font-size: 1.5em; cursor: pointer; padding: 0 5px; line-height: 1; }
        .cancel-adventure-btn:hover { color: darkred; }


        .active-potions-display { padding-top: 15px; margin-top: 15px; border-top: 1px solid var(--border-color); }
        .active-potions-display h4 { font-size: 1.3em; text-align: center; margin-bottom: 10px; color: var(--label-color); }
        .active-potions-display .potion-item { font-size: 0.95em; padding: 8px; margin-bottom: 8px; background-color: var(--adventure-block-bg); border: 1px solid var(--border-color); border-radius: 4px; }
        .active-potions-display .potion-item p { margin: 3px 0; }

        .dark-mode-switch { display: flex; align-items: center; gap: 8px; } .dark-mode-switch label { font-size: 1em; color: var(--text-color); cursor: pointer; transition: color 0.3s; } .switch { position: relative; display: inline-block; width: 50px; height: 24px; } .switch input { opacity: 0; width: 0; height: 0; } .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; } .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; } input:checked + .slider { background-color: var(--highlight-color-connected); } input:focus + .slider { box-shadow: 0 0 1px var(--highlight-color-connected); } input:checked + .slider:before { transform: translateX(26px); }
        .page-title { font-size: 2.2em; margin-bottom: 25px; text-align:center; width:100%; }
        
        #shop-page { align-items: center; flex-direction: column; }
        .shop-top-section {
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: flex-start;
            width: 100%;
            max-width: 900px; /* Adjusted for better spacing */
            margin-bottom: 30px;
            margin-left: auto;
            margin-right: auto;
        }
        .shop-image-container {
            flex: 1; /* Takes up available space */
            max-width: 350px; /* Max width for the image */
        }
        .shop-image-container img {
            width: 100%;
            height: auto;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            display: block;
            margin: 0 auto; /* Center image if container is wider */
        }
        .swap-section-container {
            flex: 1; /* Takes up available space */
            display: flex;
            flex-direction: column;
            align-items: center; /* Center the swap-section div */
             max-width: 350px;
        }
        @media (max-width: 800px) {
            .shop-top-section {
                flex-direction: column;
                align-items: center;
            }
            .shop-image-container, .swap-section-container {
                max-width: 80%;
                margin-bottom: 20px;
            }
        }
        #reverseSwapDirectionBtn img {
            height: 24px; /* Adjust size as needed */
            width: auto;
            vertical-align: middle;
        }
        #reverseSwapDirectionBtn {
            padding: 6px 10px; /* Adjust padding if needed */
            line-height: 0; /* May help align icon if it has extra space */
        }


        #crafting-page { align-items: center; flex-direction: column; }
        .crafting-gif-container { flex: 1; max-width: 50%; margin: 0 auto 20px auto;}
        .crafting-gif-container img { width: 100%; max-width: 400px; height: auto; border: 2px solid var(--border-color); border-radius: 8px; display: block; margin: 0 auto; }
        
        .swap-section h3 { font-size: 1.8em; text-align: center; margin-bottom: 15px; }
        .shop-section-wrapper, .crafting-section-wrapper { width: 100%; max-width: 800px; margin-bottom:30px;} .shop-section-wrapper h3, #crafting-page h3 { font-size: 1.8em; text-align: center; margin-bottom: 20px; color: var(--label-color); }
        .quest-list, .shop-items, .crafting-items-container { display: flex; flex-direction: column; gap: 18px; width:100%; max-width:800px; margin:0 auto; }
        .quest-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px; /* Add some padding */
            border: 2px solid var(--border-color); /* Default border */
            border-radius: 8px;
            background-color: var(--adventure-block-bg); /* Consistent background */
            margin-bottom: 15px; /* Space between quest items */
            transition: border-color 0.3s, box-shadow 0.3s, opacity 0.3s; /* Smooth transitions */
        }

        .quest-item .quest-info {
            flex-grow: 1; /* Allows the info to take up available space */
            margin-right: 15px; /* Space before the actions */
        }
        .quest-item .quest-info p { /* Ensure quest text wraps nicely */
            margin: 0;
            white-space: normal; /* Allow text to wrap */
            word-break: break-word; /* Break long words if necessary */
        }


        .quest-item .quest-actions {
            display: flex; /* To align reward and button if needed */
            flex-direction: column; /* Stack reward and button vertically */
            align-items: flex-end; /* Align them to the right */
            text-align: right; /* Ensure text inside is right-aligned */
            flex-shrink: 0; /* Prevent actions from shrinking */
        }
        .quest-item .quest-actions .quest-reward {
            margin-bottom: 5px; /* Space between reward and button */
            font-size: 0.9em; /* Slightly smaller reward text */
        }
        .quest-item .quest-actions .claim-quest-btn {
            min-width: 80px; /* Give button a minimum width */
            padding: 6px 10px; /* Adjust padding */
        }

        /* Styling for completed but not claimed quests (AVAILABLE TO CLAIM) */
        .quest-item.available-to-claim {
            border-color: var(--quest-available-outline); /* Use your existing variable */
            box-shadow: 0 0 8px var(--quest-available-outline);
        }
        /* Make the claim button more prominent when available */
        .quest-item.available-to-claim .claim-quest-btn:not([disabled]) {
            background-color: var(--highlight-color-connected); /* Greenish button */
            color: white;
            border-color: var(--highlight-color-connected);
        }


        /* Styling for claimed quests (COMPLETED AND CLAIMED) */
        .quest-item.completed-and-claimed {
            border-color: var(--quest-completed-outline); /* Use your existing variable */
            box-shadow: 0 0 8px var(--quest-completed-outline);
            opacity: 0.7; /* Optional: make claimed quests less prominent */
        }
        /* Style for already claimed button */
        .quest-item.completed-and-claimed .claim-quest-btn[disabled] {
            background-color: var(--button-bg); /* Default button bg */
            color: var(--button-text-color);
            opacity: 0.6;
        }
        /* --- MODIFIED FOR INVENTORY GRID --- */
        .inventory-items-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); /* Adjust 280px for desired card width */
            gap: 15px;
            width: 100%;
            max-width: 900px; /* Can be wider for grid */
            margin: 0 auto;
            padding: 10px; /* Add some padding around the grid */
        }
        /* ... */
        .shop-item, .craftable-item-card { position:relative; background-color: var(--adventure-block-bg); border: 1px solid var(--border-color); padding: 18px; border-radius: 8px; display: flex; align-items: center; transition: background-color 0.3s, border-color 0.3s; gap: 15px; }
        /* --- MODIFIED FOR INVENTORY ITEM CARD IN GRID --- */
        .inventory-item-card {
            position: relative;
            background-color: var(--adventure-block-bg);
            border: 1px solid var(--border-color);
            padding: 12px; /* Slightly less padding for smaller cards */
            border-radius: 8px;
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            align-items: center; /* Center content */
            text-align: center; /* Center text */
            transition: background-color 0.3s, border-color 0.3s;
            gap: 8px; /* Smaller gap for vertical stacking */
            min-height: 180px; /* Ensure a consistent height */
            justify-content: space-between; /* Distribute space for button at bottom */
        }
        .inventory-item-card .item-icon-placeholder {
            margin-right: 0; /* Remove margin as it's centered now */
            margin-bottom: 8px;
        }
        .inventory-item-card .item-info {
            flex-grow: 0; /* Don't let info section grow excessively */
            width: 100%;
        }
        .inventory-item-card .item-actions {
            margin-top: auto; /* Push actions to the bottom */
            width: 100%; /* Make actions take full width for centering button */
            display: flex;
            justify-content: center;
        }
        .quest-item p, .shop-item p, .craftable-item-card p, .inventory-item-card p { font-size: 1.05em; margin:3px 0; }
        .quest-item .quest-reward, .shop-item .shop-price, .craftable-item-card .crafting-cost, .inventory-item-card .item-type { margin-left: auto; white-space: nowrap; text-align: right; }
        .shop-item .shop-price { color: var(--highlight-color-pv); } .action-button { padding: 6px 12px; font-size: 0.9em; } 
        .shop-item .quantity-selector { font-family: 'VT323', monospace; font-size: 0.9em; padding: 4px; border: 1px solid var(--border-color); background-color: var(--dropdown-bg); color: var(--text-color); width: 50px; margin-right: 8px; }
        
        .help-content { width: 100%; max-width: 900px; margin: 0 auto; }
        .help-content p, .help-content ul, .help-content h3, .help-content h4 { font-size: 1.05em; margin-bottom: 10px; line-height: 1.7; }
        .help-content h3 { font-size: 1.5em; margin-top: 20px; color: var(--label-color); }
        .help-content h4 { font-size: 1.2em; margin-top: 15px; color: var(--label-color); }
        .help-content ul { list-style: disc; padding-left: 25px; }
        .help-content strong { color: var(--highlight-color-pv); }
        body.dark-mode .help-content strong { color: var(--highlight-color-gold); }
        .help-gif-container { text-align: center; margin: 25px 0; }
        .help-gif-container img { max-width: 80%; height: auto; border: 2px solid var(--border-color); border-radius: 8px; }

        .item-icon-placeholder { width: var(--item-icon-size); height: var(--item-icon-size); border: 1px solid var(--border-color); border-radius: 4px; margin-right: 10px; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-size: 0.7em; overflow:hidden; }
        .item-icon-placeholder img { max-width: 100%; max-height: 100%; object-fit: contain; }
        .upgrade-slot .item-icon-placeholder { width: calc(var(--item-icon-size) + 10px) ; height: calc(var(--item-icon-size) + 10px); } 

        .craftable-item-card .item-info, .inventory-item-card .item-info { flex-grow: 1; }
        .crafting-cost small, .item-perk small { display: block; font-size: 0.9em; opacity: 0.8; }
        .equip-btn, .unequip-btn { font-size: 0.9em; padding: 4px 8px; margin-left: 5px; }
        .inventory-item-card .equipped-status { font-size: 0.9em; color: var(--highlight-color-connected); margin-left: 10px; }
        .inventory-item-card .use-btn { font-size: 0.9em; padding: 4px 8px; margin-left: 10px; background-color: var(--highlight-color-pv); color: black;}
        .inventory-item-card.item-level-plus4 { border: 2px solid var(--item-upgrade-plus4-border) !important; box-shadow: 0 0 8px var(--item-upgrade-plus4-border); }
        .inventory-item-card.item-level-plus5 { border: 2px solid var(--item-upgrade-plus5-border) !important; box-shadow: 0 0 10px var(--item-upgrade-plus5-border); }
        .inventory-item-card.item-level-plus1 { border: 2px solid var(--item-upgrade-plus1-border) !important; box-shadow: 0 0 6px var(--item-upgrade-plus1-border); }
        .inventory-item-card.item-level-plus2 { border: 2px solid var(--item-upgrade-plus2-border) !important; box-shadow: 0 0 7px var(--item-upgrade-plus2-border); }
        .inventory-item-card.item-level-plus3 { border: 2px solid var(--item-upgrade-plus3-border) !important; box-shadow: 0 0 7px var(--item-upgrade-plus3-border); }

        .equipment-slots-container { margin-bottom: 30px; padding: 15px; border: 1px dashed var(--border-color); border-radius: 5px; width: 100%; max-width: 800px; box-sizing: border-box; margin-left:auto; margin-right:auto; }
        .equipment-slots-container h4 { margin-top: 0; margin-bottom: 15px; text-align: center; color: var(--label-color); font-size: 1.8em; }
        .equipment-slots { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; } 
        .equipment-slot { border: 1px solid var(--border-color); background-color: var(--adventure-block-bg); padding: 10px; border-radius: 4px; text-align: center; min-height: 120px; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: background-color 0.3s, border-color 0.3s; position: relative; } /* Added position relative for tooltip handling */
        .equipment-slot.locked .slot-name::after { content: ""; font-size: 0.8em; }
        .equipment-slot .slot-name { font-size: 1em; margin-bottom: 8px; color: var(--label-color); font-weight:normal; }
        .equipment-slot .item-icon-placeholder { margin-bottom: 5px; width: var(--item-icon-size); height: var(--item-icon-size); font-size: 0.7em; }
        .equipment-slot .equipped-item-name { font-size: 0.95em; font-weight: bold; margin-bottom: 5px; }
        .equipment-slot .equipped-item-container { /* New container for tooltip */ display: flex; flex-direction: column; align-items: center; cursor: default; /* Or pointer if interactive */ }
        .equipment-slot .empty-slot-text { font-size: 0.9em; opacity: 0.7; }
        .equipment-slot.item-level-plus4 { border: 2px solid var(--item-upgrade-plus4-border) !important; box-shadow: 0 0 8px var(--item-upgrade-plus4-border); }
        .equipment-slot.item-level-plus5 { border: 2px solid var(--item-upgrade-plus5-border) !important; box-shadow: 0 0 10px var(--item-upgrade-plus5-border); }
        .equipment-slot.item-level-plus1 { border: 2px solid var(--item-upgrade-plus1-border) !important; box-shadow: 0 0 6px var(--item-upgrade-plus1-border); }
        .equipment-slot.item-level-plus2 { border: 2px solid var(--item-upgrade-plus2-border) !important; box-shadow: 0 0 7px var(--item-upgrade-plus2-border); }
        .equipment-slot.item-level-plus3 { border: 2px solid var(--item-upgrade-plus3-border) !important; box-shadow: 0 0 7px var(--item-upgrade-plus3-border); }
        .dungeon-drops-area { 
            position: relative; 
            align-self: center; /* Center the button if its wrapper is full width */
        } 
        .dungeon-drops-button { 
            font-size: 0.9em; 
            padding: 4px 8px; 
        }

        #inventory-page { align-items: center; }
        #inventory-page > h4 { font-size: 1.8em; color: var(--label-color); margin-top: 25px; margin-bottom: 15px; text-align: center; width: 100%; max-width: 800px; margin-left:auto; margin-right:auto; }
        
        #daily-rewards-page .rewards-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-top: 20px; }
        #daily-rewards-page .reward-day { border: 1px solid var(--border-color); background-color: var(--adventure-block-bg); padding: 10px; border-radius: 5px; text-align: center; }
        #daily-rewards-page .reward-day h5 { margin: 0 0 5px 0; color: var(--label-color); }
        #daily-rewards-page .reward-day p { margin: 0; font-size: 0.9em; }
        #daily-rewards-page .reward-day button { margin-top: 8px; }

        .swap-section { margin-top:10px; text-align: center;} 
        .swap-section .swap-info { margin-bottom: 10px; font-size: 1.1em; }
        .swap-btn { padding: 8px 15px; font-size: 1.1em; }

        #upgrade-page { align-items: center; flex-direction: column; }
        .upgrade-main-image-container { text-align: center; margin-bottom: 20px; }
        .upgrade-main-image-container img { max-width: 250px; width: 100%; height: auto; }
        .upgrade-interface { display: flex; flex-direction: column; align-items: center; gap: 15px; padding: 20px; background-color: var(--adventure-block-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 100%; max-width: 500px; }
        .upgrade-slot { width: 120px; height: 120px; border: 2px dashed var(--border-color); border-radius: 5px; display: flex; align-items: center; justify-content: center; text-align: center; font-size: 0.9em; background-color: var(--section-bg); color: var(--label-color); cursor: pointer; flex-direction: column; }
        .upgrade-slot img.icon-preview { max-width: var(--item-icon-size); max-height: var(--item-icon-size); margin-bottom: 5px; object-fit: contain; } 
        .upgrade-slot.filled { border-style: solid; }
        #selectedItemForUpgradeDisplay, #selectedScrollForUpgradeDisplay { font-size: 1em; text-align: center; display: flex; flex-direction:column; align-items: center; justify-content: center; gap: 5px; }
        #upgradeSuccessRateDisplay { margin-top: 10px; font-size: 1.1em; font-weight: bold; color: var(--label-color); }
        #upgradeResultDisplay { margin-top: 10px; font-size: 1.1em; font-weight: bold; }

        #whitelist-page { align-items: center; } 
        #adminRafflePanel { background-color: var(--section-bg); padding: 20px; border: 2px solid var(--border-color); border-radius: 8px; margin-bottom: 30px; width: 100%; max-width: 700px; box-shadow: 0 3px 10px rgba(0,0,0,0.15); }
        #adminRafflePanel h3 { text-align: center; margin-bottom: 15px; font-size: 1.6em; }
        .admin-form-group { margin-bottom: 12px; }
        .admin-form-group label { display: block; margin-bottom: 5px; font-size: 1.1em; color: var(--label-color); }
        .admin-form-group input[type="text"], .admin-form-group input[type="number"], .admin-form-group textarea { width: calc(100% - 20px); padding: 8px; font-family: 'VT323', monospace; font-size: 1em; border: 1px solid var(--border-color); background-color: var(--dropdown-bg); color: var(--text-color); border-radius: 4px; }
        .admin-form-group textarea { min-height: 60px; }
        #whitelistRafflesContainer { display: flex; flex-direction: column; gap: 20px; width: 100%; max-width: 800px; }
        .raffle-card { background-color: var(--adventure-block-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 20px; display: flex; gap: 20px; align-items: flex-start; }
        .raffle-card-image { width: 120px; height: 120px; background-size: cover; background-position: center; border: 1px solid var(--border-color); border-radius: 5px; flex-shrink: 0; }
        .raffle-card-image.placeholder { display: flex; align-items: center; justify-content: center; background-color: #555; color: white; font-size: 0.9em; }
        .raffle-card-content { flex-grow: 1; }
        .raffle-card-content h4 { margin: 0 0 10px 0; font-size: 1.5em; color: var(--label-color); }
        .raffle-card-content p { margin: 5px 0; font-size: 1em; line-height: 1.5; }
        .raffle-card-description { margin-bottom: 10px !important; }
        .raffle-card-socials a { margin-right: 10px; text-decoration: none; color: var(--highlight-color-connected); font-weight: bold; }
        .raffle-card-socials a:hover { text-decoration: underline; }
        .raffle-card-cost { margin-top: 10px; font-size: 0.95em; }
        .raffle-card-cost .pv { color: var(--highlight-color-pv); } .raffle-card-cost .gold { color: var(--highlight-color-gold); } .raffle-card-cost .diamond { color: var(--highlight-color-diamond); }
        .raffle-card-status { margin-top: 10px; font-weight: bold; }
        .raffle-card-winners ul { list-style: disc; padding-left: 20px; margin-top: 5px;}
        .raffle-admin-actions button { margin-right: 10px; margin-top:5px; }

        #leaderboard-page { align-items: center; flex-direction: column; }
        .leaderboard-filters { margin-bottom: 20px; display:flex; gap: 10px; }
        .leaderboard-container { width: 100%; max-width: 700px; margin-bottom: 30px; background-color: var(--section-bg); padding: 15px; border: 1px solid var(--border-color); border-radius: 8px; }
        .leaderboard-container h4 { font-size: 1.5em; color: var(--label-color); text-align: center; margin-bottom: 15px; }
        .leaderboard-list { list-style: none; padding: 0; margin: 0; }
        .leaderboard-list li { display: flex; justify-content: space-between; padding: 8px 5px; border-bottom: 1px solid var(--border-color); font-size: 1.1em; }
        .leaderboard-list li:last-child { border-bottom: none; }
        .leaderboard-list .rank { margin-right: 10px; color: var(--label-color); }
        .leaderboard-list .nickname { flex-grow: 1; }
        .leaderboard-list .score { font-weight: bold; }
        .leaderboard-list .score.pv { color: var(--highlight-color-pv); } .leaderboard-list .score.gold { color: var(--highlight-color-gold); } .leaderboard-list .score.diamond { color: var(--highlight-color-diamond); }
        .leaderboard-pagination { display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 15px; }
        .leaderboard-pagination button { padding: 6px 12px; font-size: 0.9em; }

        /* Dungeons Page Specific Styles */
        #dungeons-page .help-gif-container img { /* Ensure the main image isn't too large */
            max-width: 600px; /* Or your preferred size */
            width: 90%; /* Responsive width */
            height: auto;
            border: 2px solid var(--border-color);
            border-radius: 8px;
        }
        .dungeon-entry {
            display: flex;
            align-items: center;
            gap: 20px;
            width: 100%;
            background-color: var(--adventure-block-bg);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-sizing: border-box;
        }
        .dungeon-entry.locked {
            filter: grayscale(70%) opacity(0.8);
        }
        .dungeon-icon-placeholder {
            width: 80px;
            height: 80px;
            border: 2px solid var(--border-color);
            border-radius: 5px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: white;
            font-weight: bold;
        }
        .dungeon-info {
            flex-grow: 1;
        }
        .dungeon-info h3 {
            margin: 0 0 10px 0;
            font-size: 1.4em;
            color: var(--label-color);
        }
        .dungeon-info p {
            margin: 5px 0;
            font-size: 1em;
        }
        .dungeon-requirements {
            color: var(--highlight-color-danger);
            font-weight: bold;
        }
        .enter-dungeon-btn {
            padding: 8px 15px;
            font-size: 1.1em;
        }

        /* Tooltip Styles */
        #itemTooltip {
            position: fixed; 
            background-color: var(--section-bg);
            border: 2px solid var(--border-color);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            z-index: 10000; 
            font-size: 0.95em;
            line-height: 1.5;
            max-width: 320px; 
            display: none; 
            pointer-events: none; 
            font-family: 'VT323', monospace;
            color: var(--text-color);
        }
        #itemTooltip h5 { 
            margin: 0 0 8px 0; 
            color: var(--label-color); 
            font-size: 1.1em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        body.dark-mode #itemTooltip h5 { color: var(--orange-label); }
        #itemTooltip p { margin: 4px 0; }
        #itemTooltip ul { list-style: none; padding-left: 0; margin: 6px 0; }
        #itemTooltip ul li { margin-bottom: 3px; }
        #itemTooltip small { opacity: 0.9; display: block; margin-top: 3px;}
        #itemTooltip .perk-info { color: var(--highlight-color-pv); font-weight: bold;}
        body.dark-mode #itemTooltip .perk-info { color: var(--highlight-color-gold);}
        #itemTooltip .recipe-info { margin-top: 8px; font-size: 0.9em;}
        #itemTooltip .recipe-info strong { color: var(--label-color); }
        body.dark-mode #itemTooltip .recipe-info strong { color: var(--orange-label); }
         #dungeonCrawlerSelectionModalOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); /* Slightly darker than item selection */
            display: flex; 
            justify-content: center; align-items: center;
            z-index: 2010; /* Higher than item selection modal */
        }

        #dungeonCrawlerSelectionModal {
            background-color: var(--section-bg); border: 3px solid var(--border-color);
            padding: 20px; border-radius: 10px; 
            text-align: left; /* Align content to left for lists */
            min-width: 400px; max-width: 90%; width: auto; 
            box-shadow: 0 5px 25px rgba(0,0,0,0.5); font-family: 'VT323', monospace;
            color: var(--text-color); box-sizing: border-box;
            position: fixed; 
            top: 50%; left: 50%;
            transform: translate(-50%, -50%); 
            z-index: 2011;
            max-height: 80vh; /* Allow for more content */
            display: flex; /* Use flex for better internal layout */
            flex-direction: column;
        }

        #dungeonCrawlerSelectionModalTitle {
            font-size: 1.7em; margin-top: 0; margin-bottom: 10px;
            color: var(--label-color); 
            text-align: center;
        }

        #availableDungeonCrawlersList .crawler-item-btn,
        #selectedDungeonCrawlersDisplay .selected-crawler-tag {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 5px;
            border: 1px solid var(--border-color);
            background-color: var(--adventure-block-bg);
            border-radius: 4px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1em;
        }
        #availableDungeonCrawlersList .crawler-item-btn:hover {
            background-color: var(--button-bg-hover); /* You might need to define this variable or use a direct color */
        }
        body:not(.dark-mode) #availableDungeonCrawlersList .crawler-item-btn:hover { background-color: #f0f0f0; }
        body.dark-mode #availableDungeonCrawlersList .crawler-item-btn:hover { background-color: #4a4a4a; }


        #availableDungeonCrawlersList .crawler-item-btn.selected-for-dungeon {
            background-color: var(--highlight-color-connected) !important;
            color: white !important;
        }


        #selectedDungeonCrawlersDisplay .selected-crawler-tag {
            cursor: default;
            margin-right: 8px;
            margin-bottom: 8px; /* Add bottom margin for tags */
            display: inline-flex; /* Allow tags to sit next to each other */
        }
        #selectedDungeonCrawlersDisplay .selected-crawler-tag .remove-crawler-btn {
            margin-left: 10px;
            background: none;
            border: none;
            color: var(--highlight-color-danger);
            font-size: 1.1em;
            cursor: pointer;
            padding: 0 3px;
        }
        @media (max-width: 1280px) {            /* Show the menu button and its container on mobile */
            .header-controls .menu-button-container-fixed {
                display: block; /* Use block to show the container */
            }
            #mainMenuToggleBtn {
                display: inline-block; /* Use inline-block for the button itself */
            }

            .main-content {
                /* Change layout from side-by-side to stacked */
                flex-direction: column;
                gap: 15px; /* Add some space between stacked sections */
            }

            .left-sidebar,
            .main-content-area,
            .right-sidebar-menu {
                /* Make each section take up the full width */
                width: 100%;
                max-width: 100%; /* Override any max-widths */
            }

            .main-content-area {
                /* Ensure main content area is ordered correctly */
                order: 1;
            }

            .left-sidebar {
                order: 2; /* Left sidebar appears after main content */
            }
            
            .right-sidebar-menu {
                order: 3; /* Right menu appears last */
                /* --- Hide the right menu by default on mobile --- */
                display: none;
            }

            header {
                /* Stack header items for smaller screens */
                flex-direction: column;
                align-items: center; /* Center-align the items */
                gap: 15px;
            }

            .header-controls {
                /* Allow header controls to wrap if needed */
                flex-wrap: wrap;
                justify-content: center; /* Center the buttons and info */
                gap: 10px;
            }
            
            .player-info-wallet, .socials-nav {
                 align-items: center; /* Center wallet info and socials */
                 text-align: center;
            }
            .player-info-wallet {
                width: 100%; /* Allow wallet info to take full width */
            }

            header h1 {
                font-size: 1.8em; /* Make title smaller */
                text-align: center;
            }
            .header-byline {
                 align-self: center; /* Center the byline text */
                 margin-left: 0;
            }

            /* --- Styles for when the mobile menu is OPEN --- */
            body.mobile-menu-open .right-sidebar-menu {
                display: flex; /* Make the menu visible */
                position: fixed; /* Make it an overlay */
                top: 0;
                right: 0;
                height: 100%; /* Full screen height */
                z-index: 1500; /* Ensure it's on top of everything */
                overflow-y: auto; /* Allow menu to scroll if content is long */
                box-shadow: -5px 0 15px rgba(0,0,0,0.4);
            }
             body.mobile-menu-open .main-content {
                /* Prevent main content from scrolling when menu is open */
                overflow: hidden;
            }
        }
        
        @media (max-width: 768px) {
            /* Further adjustments for even smaller screens */
            .adventure {
                flex-direction: column; /* Stack adventure icon and details */
                align-items: center;
                text-align: center;
            }
            .adventure-main-info {
                flex-direction: column;
                align-items: center;
            }
            .raffle-card {
                flex-direction: column;
                align-items: center;
            }
            .shop-item {
                 flex-direction: column;
                 align-items: center;
                 text-align: center;
            }
            .shop-item .shop-details {
                margin-top: 10px;
            }
        }

        /* --- END OF MOBILE RESPONSIVE STYLES --- */
    </style>
</head>
<body>
    <div id="itemTooltip"></div> <!-- Tooltip Element -->
    <div id="leaderboardPlayerTooltip" style="position: fixed; display: none; /* ... other tooltip styles */"></div>

    <div class="game-container" id="gameContainer">
        <header> 
        <div class="header-title-container">
            <h1>PUNK VOYAGE ADVENTURES</h1>
            <span class="header-byline">by NV.Art</span>
        </div>
            <div class="header-controls"> 
                <div class="player-info-wallet"> 
                     <div class="player-stats" id="playerStats"> PLAYER <span id="playerNicknameDisplay">Voyager</span>, WELCOME<br> <span class="pv">PV = <span id="pvCount">0</span></span> , <span class="gold">GOLD = <span id="goldCount">0</span></span>, <span class="diamond">DIAMOND = <span id="diamondCount">0</span></span> <div class="wallet-address" id="walletAddressDisplay"></div> 
                    </div> 
                    <div class="wallet-connector"><button class="connect-wallet-btn" id="connectWalletBtn">CONNECT WALLET</button><ul class="wallet-dropdown" id="walletDropdown"><li data-wallet="xverse_provider">XVERSE</li><li data-wallet="unisat">UNISAT</li></ul>
                    </div> 
                </div>
     
                <nav class="socials-nav" id="headerSocialsNav"> 
                    <div class="social-title">SOCIALS</div> 
                    <div class="social-buttons"> 
                        <a href="https://x.com/nvart_" target="_blank" class="social-icon-link">
                            <img src="https://raw.githubusercontent.com/nvoiy/pvadventures/main/twitter-x-logo.jpg" alt="X/Twitter">
                        </a> 
                        <a href="https://discord.com/invite/4CEtXAFf3x" target="_blank" class="social-icon-link">
                            <img src="https://raw.githubusercontent.com/nvoiy/pvadventures/main/discordlogo.jpg" alt="Discord">
                        </a> 
                        <a href="https://magiceden.io/tr/ordinals/marketplace/punkvoyage" target="_blank" title="Punk Voyage on Magic Eden" class="social-icon-link">
                            <img src="https://raw.githubusercontent.com/nvoiy/pvadventures/main/images.png" alt="Magic Eden">
                        </a>
                    </div> 
                </nav>
                <div class="menu-button-container-fixed"><button class="menu-button" id="mainMenuToggleBtn">MENU</button></div>
                <div class="dark-mode-switch"> 
                    <label for="darkModeToggle">Dark Mode</label> 
                    <label class="switch"> <input type="checkbox" id="darkModeToggle"> <span class="slider"></span> </label> 
                </div> 
            </div> 
        </header>
        <main class="main-content">
            <aside class="left-sidebar"> 
                <div id="availableAdventurersDisplay"> Available Adventurers: <span id="availableAdventurersCount">5</span> </div> 
                <div id="playerCombatStatsDisplay" class="materials-display" style="text-align:center;">
                    <h4>COMBAT STATS</h4>
                    <p>Attack: <span id="playerAttackStat">0</span></p>
                    <p>Defense: <span id="playerDefenseStat">0</span></p>
                </div>
                <div class="materials-display" id="materialsDisplay"> 
                    <h4 style="display: flex; justify-content: space-between; align-items: center;">
                        <span>MY MATERIALS</span>
                        <button id="toggleMaterialsBtn" class="action-button" style="font-size: 0.7em; padding: 2px 5px;">Hide</button>
                    </h4> 
                    <div id="materialsListContainer"></div>
                </div> 
                
                <div id="activeSpecialtiesDisplay" class="materials-display" style="text-align:left; margin-top: 20px;">
        <h4 style="display: flex; justify-content: space-between; align-items: center;">
            <span>ACTIVE SPECIALTIES</span>
            <button id="toggleSpecialtiesBtn" class="action-button" style="font-size: 0.7em; padding: 2px 5px;">Hide</button>
        </h4>
        <div id="specialtiesListContainer" style="padding-left: 10px;">
            <!-- Specialties will be listed here by JavaScript -->
            <ul><li>No active specialties. Equip items with perks!</li></ul>
        </div>
        
    </div>
                    <div id="dungeonResetTimerDisplayContainer" class="materials-display" style="text-align:center; margin-top: 20px;">
                    <h4 style="font-size: 1.1em; margin-bottom: 5px;">DAILY DUNGEON RESET</h4>
                    <p style="font-size: 1em;">Resets In: <span id="dungeonResetCountdown" style="font-weight:bold;">--:--:--</span></p>
                </div>
                               <div id="userOrdinalsDisplay" class="materials-display" style="text-align:center; display: none; margin-top: 20px;">
                   <h4>MY PUNK VOYAGE ORDINALS</h4>
                   <div id="userOrdinalsList" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; max-height: 300px; overflow-y: auto; padding-top: 10px;">
                       <!-- Fetched Ordinals will be listed here -->
                   </div>
               </div>
                <div class="twitter-feed-container" id="twitter-widget-container"> <a class="twitter-timeline" data-dnt="true" href="https://twitter.com/nvart_?ref_src=twsrc%5Etfw">Tweets by nvart_</a> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> </div> 
            </aside>
            <div class="main-content-area">
                <section id="adventures-page" class="page-content active"> 
                    <div class="player-character-area"> 
                        <div class="player-character" aria-label="Player Character Image"></div> 
                    </div> 
                    <div class="adventure-section-wrapper"> 
                        <h2 class="adventures-label">ADVENTURES</h2> 
                        <p id="adventureMilestoneInfo">Complete 100 adventures for a bonus of 50 Gold and 1 Diamond!</p>
                        <div class="adventure-locations"> 
                            <div class="adventure" id="adventure-1-block"> 
                                <div class="adventure-lock-overlay hidden"></div>
                                <div class="adventure-icon tree"></div> 
                                <div class="adventure-main-info"> <div class="adventure-content"> <div class="adventure-details"> ADVENTURE 1, SPIRIT FOREST<br> ADVENTURE TIME = 4 HOURS<br> <span class="prize">PRIZE = 50 PV TOKENS</span> </div> <div class="adventure-controls"> <label for="num-adventurers-1">ADVENTURERS:</label> 
                            <input type="number" id="num-adventurers-1" class="adventure-num-select" value="1" min="1">
                                <button class="adventure-send-btn active-adv1" data-adventure-id="1" data-adventure-name="Spirit Forest" data-duration-hours="4" data-pv-reward="25" data-gold-chance="0">SEND</button> </div> 
                                </div> <div class="adventure-drops-area"> <button class="adventure-drops-button" data-adventure-id="1">DROPS</button> <div class="drops-popover" id="drops-popover-1"></div>  </div> </div> 
                            </div> 
                            <div class="adventure" id="adventure-2-block"> 
                                <div class="adventure-lock-overlay hidden"></div>
                                <div class="adventure-icon mountain"></div> <div class="adventure-main-info"> <div class="adventure-content"> <div class="adventure-details"> ADVENTURE 2, MOUNTAIN OF THE MAROWAN<br> ADVENTURE TIME = 8 HOURS<br> <span class="prize">PRIZE = 80 PV TOKENS</span> </div> <div class="adventure-controls"> <label for="num-adventurers-2">ADVENTURERS:</label> <input type="number" id="num-adventurers-2" class="adventure-num-select" value="1" min="1">
                                <button class="adventure-send-btn active-adv2" data-adventure-id="2" data-adventure-name="Mountain of the Marowan" data-duration-hours="8" data-pv-reward="40" data-gold-chance="0">SEND</button> </div> </div> <div class="adventure-drops-area"> <button class="adventure-drops-button" data-adventure-id="2">DROPS</button> <div class="drops-popover" id="drops-popover-2"></div>  </div> </div> 
                            </div> 
                            <div class="adventure" id="adventure-3-block"> 
                                <div class="adventure-lock-overlay hidden"></div>
                                <div class="adventure-icon fire-fields"></div> <div class="adventure-main-info"> <div class="adventure-content"> <div class="adventure-details"> ADVENTURE 3, FIRE FIELDS OF FLYINALS<br> ADVENTURE TIME = 24 HOURS<br> <span class="prize">PRIZE = 200 PV TOKENS</span><br> <span class="chance-gold">%1 CHANCE OF GOLD</span> <div class="adventure-requirement">Requires: 2 Adventurers</div> </div> <div class="adventure-controls"> <label for="num-adventurers-3">ADVENTURERS:</label>
<input type="number" id="num-adventurers-3" class="adventure-num-select" value="1" min="1">
                                <button class="adventure-send-btn active-adv3" data-adventure-id="3" data-adventure-name="Fire Fields of Flyinals" data-duration-hours="24" data-pv-reward="100" data-gold-chance="0.01" data-adventurer-requirement="2">SEND</button> </div> </div> <div class="adventure-drops-area"> <button class="adventure-drops-button" data-adventure-id="3">DROPS</button> <div class="drops-popover" id="drops-popover-3"></div>  </div> </div> 
                            </div>
                            <div class="adventure" id="adventure-4-block"> 
                                <div class="adventure-lock-overlay hidden"></div>
                                <div class="adventure-icon tomb"></div> <div class="adventure-main-info"> <div class="adventure-content"> <div class="adventure-details"> ADVENTURE 4, TOMB OF THE DEATH RIDERS<br> ADVENTURE TIME = 168 HOURS (1 WEEK)<br> <span class="prize">PRIZE = 1400 PV TOKENS</span><br> <span class="chance-gold">5% CHANCE OF GOLD</span><br> <span class="chance-diamond">1% CHANCE OF DIAMOND</span><div class="adventure-requirement">Requires: 5 Adventurers</div></div> <div class="adventure-controls"> <label for="num-adventurers-4">ADVENTURERS:</label>
<input type="number" id="num-adventurers-4" class="adventure-num-select" value="1" min="1">
                                <button class="adventure-send-btn active-adv4" data-adventure-id="4" data-adventure-name="Tomb of the Death Riders" data-duration-hours="168" data-pv-reward="700" data-gold-chance="0.05" data-diamond-chance="0.01" data-adventurer-requirement="5">SEND</button> </div> </div> <div class="adventure-drops-area"> <button class="adventure-drops-button" data-adventure-id="4">DROPS</button> <div class="drops-popover" id="drops-popover-4"></div>  </div> </div> 
                            </div>
                            <div class="adventure" id="adventure-5-block"> 
                                <div class="adventure-lock-overlay hidden"> {/* Initially hidden, will be controlled by JS */}</div>
                                <div class="adventure-icon adventure-5-icon"></div>
                                <div class="adventure-main-info"> 
                                    <div class="adventure-content"> 
                                        <div class="adventure-details">
                                            ADVENTURE 5, THE CYBER VOID ECHO<br>
                                            ADVENTURE TIME = 2 WEEKS (336 HOURS)<br> <!-- CORRECTED TIME -->
                                            <span class="prize">PRIZE = 6250 PV TOKENS</span><br>
                                            <span class="gold">GUARANTEED = 5 GOLD</span><br>
                                            <span class="chance-diamond">10% CHANCE OF 3 DIAMONDS</span>
                                            <div class="adventure-requirement">Requires: 7 Adventurers</div> <!-- CORRECTED REQUIREMENT -->
                                        </div>
                                        <div class="adventure-controls">
                                            <label for="num-adventurers-5">ADVENTURERS:</label> 
                                            <input type="number" id="num-adventurers-5" class="adventure-num-select" value="1" min="1">
                                            <button class="adventure-send-btn" data-adventure-id="5" data-adventure-name="The Cyber Void Echo" data-duration-hours="336" data-pv-reward="3125" data-gold-guaranteed="5" data-diamond-chance="0.10" data-diamond-reward-multiplier="3" data-adventurer-requirement="7" style="background-color: #8A2BE2; color:white;">SEND</button>
                                        </div> 
                                    </div> 
                                    <div class="adventure-drops-area"> 
                                        <button class="adventure-drops-button" data-adventure-id="5">DROPS</button> 
                                        <div class="drops-popover" id="drops-popover-5"></div>  
                                    </div> 
                                </div> 
                            </div>
                        </div> 
                    </div> 
                </section>
                <section id="dungeons-page" class="page-content" style="align-items: center;">
                    <h2 class="page-title">DUNGEONS</h2>
                    
                    <!-- This container is now wider -->
                    <div id="dungeon-carousel-container" style="width: 100%; max-width: 900px; display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <button id="dungeon-prev-btn" class="action-button" style="font-size: 1.8em; padding: 8px 20px;"><</button>
                        <div id="dungeon-entry-container" style="flex-grow: 1; margin: 0 20px;">
                            <!-- Single dungeon entry will be rendered here -->
                        </div>
                        <button id="dungeon-next-btn" class="action-button" style="font-size: 1.8em; padding: 8px 20px;">></button>
                    </div>
                    <div id="dungeon-dots-container" style="text-align: center; margin-bottom: 20px;">
                        <!-- Page indicator dots will be added here -->
                    </div>
                
                    <!-- NEW CONTAINER FOR NPC SELECTION -->
                    <div id="dungeon-npc-selection-container" style="width: 100%; max-width: 900px; margin-bottom: 20px;">
                        <!-- NPC selection UI will be rendered here -->
                    </div>
                    
                    <div id="dungeonResetTimerDisplay" style="text-align: center; margin-bottom: 15px; font-size: 1em;">
                        Daily Dungeon Resets In: <span id="dungeonPageResetCountdown">--:--:--</span>
                    </div>
                    
                    <p style="text-align:center; margin-top: 5px; margin-bottom:15px; font-size:1em;">
                        Dungeons require specific adventures to be active to enter.<br>
                        <strong style="color: var(--label-color);">Crypts (D1 & D2):</strong> Require Adventure 4 active.<br>
                        <strong style="color: var(--label-color);">ATH City (D3):</strong> Requires Adventure 5 active.
                    </p>
                    
                    <p style="text-align:center; margin-top: 5px; margin-bottom:15px; font-size:0.9em; line-height: 1.6;">
                        <strong style="color: var(--highlight-color-gold);">Dungeon Crawler Frames multiply their stats!</strong><br>
                        <span style="color: #CD7F32;">Bronze: x1</span> | 
                        <span style="color: #C0C0C0;">Silver: x2</span> | 
                        <span style="color: #FFD700;">Gold: x3</span> | 
                        <span style="color: #00E676;">Emerald: x4</span> | 
                        <span style="color: #00BFFF;">Diamond: x5</span> | 
                        <span style="color: #FF0000;">Ruby: x6</span><br>
                        <em style="font-size: 0.9em; opacity: 0.8;">(Note: Current NPCs are placeholders and will be removed when the official Dungeon Crawler mint begins.)</em>
                    </p>
                </section>

                <section id="quests-page" class="page-content" style="align-items: center;">
                    <h2 class="page-title">QUESTS</h2>
                    
                    <!-- ADDED THE GIF HERE -->
                    <div class="help-gif-container" style="margin-bottom: 20px;">
                        <img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/ENTRY.gif" alt="Quests GIF" style="max-width: 400px; border: 2px solid var(--border-color); border-radius: 8px;">
                    </div>
                
                    <div id="questFilterContainer" style="text-align: center; margin-bottom: 20px;">
                        <button id="questToggleCompletedBtn" class="action-button leaderboard-filter-btn">Show Completed</button>
                    </div>
                
                    <div class="quest-list" id="questList"></div>
                    
                    <div id="questPaginationContainer" style="display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 20px;">
                        <button id="questPrevBtn" class="action-button">< Prev</button>
                        <span id="questPageInfo">Page 1 / 1</span>
                        <button id="questNextBtn" class="action-button">Next ></button>
                    </div>
                </section>              
                <section id="daily-rewards-page" class="page-content"> <h2 class="page-title">DAILY LOGIN REWARDS</h2> <div class="rewards-grid" id="dailyRewardsGrid"> </div> </section>
                
                <section id="shop-page" class="page-content"> 
                    <h2 class="page-title">SHOP</h2> 
                     <div class="shop-top-section">
                        <div class="shop-image-container">
                         <img src="https://raw.githubusercontent.com/nvoiy/pvadventures/main/SHOP.gif" alt="Shop Decorative Image">
                        </div>
                        <div class="swap-section-container"> 
                            <div class="swap-section">
                                <h3>Currency Swap</h3> 
                                <div class="swap-info" id="swapInfoDisplay">100 <span class="gold">GOLD</span> = 1 <span class="diamond">DIAMOND</span></div> 
                                 <div style="display: flex; flex-direction: column; gap: 10px; align-items: center; margin-top: 10px; margin-bottom: 10px;">
                                    <button id="swapBtn" class="action-button swap-btn">Swap Gold for Diamond</button>
                                    <button id="reverseSwapDirectionBtn" class="action-button" title="Reverse Swap Direction">
                                        <img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/swap.jpg" alt="Reverse Swap">
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="shop-section-wrapper"> <h3>Buy Items</h3> <div class="shop-items" id="shopItems"></div> </div> 
                </section>

                <section id="crafting-page" class="page-content">
                    <h2 class="page-title">CRAFTING</h2>
                    <div class="crafting-gif-container">
                        <img src="https://raw.githubusercontent.com/nvoiy/pvadventures/main/CRAFT.gif" alt="Crafting Anvil GIF">
                    </div>
                
                    <!-- START OF NEW FILTER BUTTONS -->
                    <div id="craftingFilterContainer" style="text-align: center; margin-bottom: 20px; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px;">
                        <!-- Filter buttons will be added here by JavaScript -->
                    </div>
                    <!-- END OF NEW FILTER BUTTONS -->
                
                    <div class="crafting-section-wrapper"> 
                        <h3>Craft Items</h3> 
                        <div class="crafting-items-container" id="craftingItemsContainer"> 
                            <!-- Crafting items will be rendered here -->
                        </div> 
                        
                        <!-- START OF NEW PAGINATION CONTROLS -->
                        <div id="craftingPaginationContainer" style="display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 20px;">
                            <button id="craftingPrevBtn" class="action-button">< Prev</button>
                            <span id="craftingPageInfo">Page 1 / 1</span>
                            <button id="craftingNextBtn" class="action-button">Next ></button>
                        </div>
                        <!-- END OF NEW PAGINATION CONTROLS -->
                    </div> 
                </section>

                <section id="inventory-page" class="page-content"> 
                    <h2 class="page-title">INVENTORY</h2> 
                    <div class="equipment-slots-container"> 
                        <h4 >EQUIPPED ITEMS</h4> 
                        <div class="equipment-slots" id="equipmentSlotsDisplay"> </div> 
                    </div> 
                    <h4 >My Items</h4> 
                    <div class="inventory-items-container" id="inventoryItemsContainer"> </div> 
                </section>
                <section id="upgrade-page" class="page-content">
                    <h2 class="page-title">UPGRADE STATION</h2>
                    <div class="upgrade-main-image-container">
                        <img src="https://raw.githubusercontent.com/nvoiy/pvadventures/main/UPGRADE.gif" alt="Upgrade Anvil">
                    </div>
                     <p style="text-align:center; margin-top: 5px; margin-bottom:10px; font-size:0.9em;">Using a higher tier scroll than the item's base tier (for a compatible level upgrade) grants a +10% success chance bonus!</p>
                    <div class="upgrade-interface">
                        <div id="upgradeItemSlot" class="upgrade-slot">
                            <div id="selectedItemForUpgradeDisplay">Item: None</div>
                        </div>
                        <div id="upgradeScrollSlot" class="upgrade-slot">
                             <div id="selectedScrollForUpgradeDisplay">Scroll: None</div>
                        </div>
                        <button id="upgradeItemButton" class="action-button">Upgrade Item</button>
                        <div id="upgradeSuccessRateDisplay"></div>
                        <div id="upgradeResultDisplay"></div>
                    </div>
         <p style="text-align:center; margin-top: 15px; font-size:0.95em;">
            Item levels enhance their effectiveness. Each level applies an increasing percentage bonus directly to the item's base stats/perks: +25% at +1, +35% at +2, +45% at +3, +60% at +4, and a +80% at +5. Max level is +5. High risk, high reward! Failed upgrades will destroy the item
        </p>
        </section>
                <section id="leaderboard-page" class="page-content">
                    <h2 class="page-title">LEADERBOARDS</h2>
                    <div class="leaderboard-filters">
                        <button class="leaderboard-filter-btn active" data-resource="pvTokens">PV Tokens</button>
                        <button class="leaderboard-filter-btn" data-resource="gold">Gold</button>
                        <button class="leaderboard-filter-btn" data-resource="diamonds">Diamonds</button>
                    </div>
                    <div class="leaderboard-container">
                        <h4 id="leaderboardCurrentTypeTitle">PV Token Leaders</h4>
                        <ul id="leaderboardDisplayList" class="leaderboard-list">
                            <li>Click a filter above to load a leaderboard.</li>
                        </ul>
                        <div class="leaderboard-pagination" style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 15px;">
                            <button id="leaderboardPrevBtn" class="action-button" disabled>Previous</button>
                            <span id="leaderboardPageInfo">Page 1</span>
                            <button id="leaderboardNextBtn" class="action-button" disabled>Next</button>
                        </div>
                    </div>
                     <p style="text-align:center; font-size:0.9em;">Note: If leaderboards show errors, your Firebase may be missing required indexes for 'pvTokens', 'gold', and 'diamonds' (descending) on the 'playerProgress' collection. Check Firebase console.</p>
                </section>
            <section id="whitelist-page" class="page-content">
                <h2 class="page-title">GIVEAWAYS</h2>

                <!-- +++ ADDED IMAGE CONTAINER AND IMAGE +++ -->
                <div class="help-gif-container" style="margin-bottom: 25px; margin-top: 10px;">
                    <img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/give.gif" alt="Giveaways Banner" style="max-width: 400px; width: 80%; height: auto; border-radius: 8px; border: 2px solid var(--border-color);">
                </div>
                <!-- +++ END OF ADDED IMAGE +++ -->

                <div id="adminRafflePanel" class="hidden">
                    <h3>Create New Raffle</h3>
                        <form id="createRaffleForm">
                            <div class="admin-form-group">
                                <label for="raffleName">Raffle Name:</label>
                                <input type="text" id="raffleName" required>
                            </div>
                            <div class="admin-form-group">
                                <label for="raffleDescription">Description:</label>
                                <textarea id="raffleDescription" required></textarea>
                            </div>
                            <div class="admin-form-group">
                                <label for="raffleImageUrl">Image URL:</label>
                                <input type="text" id="raffleImageUrl" placeholder="https://example.com/image.png">
                            </div>
                            <div class="admin-form-group">
                                <label for="raffleSocialX">Project X/Twitter URL:</label>
                                <input type="text" id="raffleSocialX" placeholder="https://x.com/project">
                            </div>
                            <div class="admin-form-group">
                                <label for="raffleSocialDiscord">Project Discord URL:</label>
                                <input type="text" id="raffleSocialDiscord" placeholder="https://discord.gg/project">
                            </div>
                            <div class="admin-form-group">
                                <label for="raffleCostPV">Cost (PV Tokens):</label>
                                <input type="number" id="raffleCostPV" value="0" min="0">
                            </div>
                            <div class="admin-form-group">
                                <label for="raffleCostGold">Cost (Gold):</label>
                                <input type="number" id="raffleCostGold" value="0" min="0">
                            </div>
                            <div class="admin-form-group">
                                <label for="raffleCostDiamonds">Cost (Diamonds):</label>
                                <input type="number" id="raffleCostDiamonds" value="0" min="0">
                            </div>
                             <div class="admin-form-group">
                                <label for="raffleDurationHours">Duration (Hours - game time):</label>
                                <input type="number" id="raffleDurationHours" value="24" min="1" required>
                            </div>
                            <div class="admin-form-group">
                                <label for="raffleMaxWinners">Number of Winners:</label>
                                <input type="number" id="raffleMaxWinners" value="1" min="1" required>
                            </div>
                            <button type="submit" class="action-button">Create Raffle</button>
                        </form>
                    </div>
                    <div id="whitelistRafflesContainer">
                        <!-- Raffles will be dynamically inserted here -->
                    </div>
                </section>
                <section id="help-page" class="page-content"> 
                    <h2 class="page-title">PUNK VOYAGE HELP</h2> 
                    <div class="help-content"> 
                        <h3>Welcome, Voyager!</h3>
                        <p>Embark on an epic journey in Punk Voyage Adventures! This guide will help you navigate the cosmos of possibilities, from sending your brave adventurers on perilous quests to crafting legendary gear.</p>

                        <div class="help-gif-container">
                            <img src="https://raw.githubusercontent.com/nvoiy/pvadventures/main/HELP.gif" alt="Helpful Guide GIF">
                        </div>

<h3>Getting Started</h3>
                        <ul>
                            <li><strong>Connect Your Wallet:</strong> To play, connect your Bitcoin Ordinals-compatible wallet (e.g., Xverse, UniSat) using the "CONNECT WALLET" button. Your game progress is saved automatically to the Firebase cloud, linked to your wallet address.</li>
                            <li><strong>Nickname:</strong> Upon first connection, you'll be prompted to set a nickname. This will be your identity in the game world and for raffles.</li>
                            <li><strong>Interface:</strong> The game starts in Dark Mode. You can toggle to Light Mode using the switch in the top-right header. Use the main menu (usually on the right) to navigate between game sections.</li>
                        </ul>

                        <h3>The Core Voyage</h3>
                        <ul>
                            <li><strong>Adventurers:</strong> You have a set number of adventurers (initially 5). Below your adventurer count in the left sidebar, you'll see your current total Attack and Defense power derived from your equipped items.</li>
                            <li><strong>Adventures Page:</strong> This is where the action begins!
                                <ul>
                                    <li>Select an available adventure location.</li>
                                    <li>Choose how many of your available adventurers to send.</li>
                                    <li>Click "SEND". Some adventures have minimum adventurer requirements. If an adventure is already active, this button may change to "ADD MORE (+)" allowing you to send additional adventurers (this will reset the adventure timer).</li>
                                    <li><strong>Cancel Adventure:</strong> In the "ACTIVE ADVENTURES" list in the right sidebar, you can click the "" button next to an adventure to cancel it. Adventurers return immediately, but no rewards are given. A confirmation will be asked.</li>
                                    <li><strong>Progression:</strong> New, more challenging (and rewarding!) adventures unlock as you complete prerequisites, often by finishing earlier adventure series multiple times (e.g., "Complete Spirit Forest 5 times"). Locked adventures will show their unlock requirements.</li>
                                    <li><strong>Duration:</strong> Each adventure takes a set amount of time. Keep an eye on the "Active Adventures" list in the sidebar! (Remember: for testing, 1 game hour = 1 real second).</li>
                                    <li><strong>Rewards:</strong> Upon return, adventurers bring back <strong>PV Tokens</strong>, and have a chance to find <strong>Gold</strong>, rare <strong>Diamonds</strong>, and crafting <strong>Materials</strong>.</li>
                                    <li><strong>Milestone Reward:</strong> Every 100 adventures completed (any type, cumulative) will grant you a bonus of 50 Gold and 1 Diamond! This is noted on the Adventures page.</li>
                                    <li><strong>Drops:</strong> Hover over the "DROPS" button on an adventure card to see a list of potential material drops and their chances.</li>
                                </ul>
                            </li>
                            <li><strong>Materials:</strong> Gathered from adventures, these are essential for crafting items. View your current stash under "MY MATERIALS" in the left sidebar, now grouped by tier. You will also find your <strong>Upgrade Scroll</strong> counts here (Low, Middle, High), shown in green text.</li>
                        </ul>

                        <h3>Currencies & Economy</h3>
                        <ul>
                            <li><strong>PV Tokens:</strong> Earned primarily from adventures and quests. Used to buy items from the Shop.</li>
                            <li><strong>Gold:</strong> A rarer currency found on adventures, as special rewards, or from the 100-adventure milestone. Its main use currently is to swap for Diamonds.</li>
                            <li><strong>Diamonds:</strong> A premium currency. Obtainable by swapping Gold, as rare drops from high-level adventures, specific quest rewards, or from the 100-adventure milestone. Diamonds might be used for exclusive items or features in the future.</li>
                            <li><strong>Currency Swap:</strong> In the "Shop" page, you can swap 100 Gold for 1 Diamond, or 1 Diamond for 100 Gold.</li>
                        </ul>

                        <h3>Shop</h3>
                        <ul>
                             <li>Purchase consumable items like Potions and Upgrade Scrolls using PV Tokens.</li>
                             <li><strong>Potions:</strong> Provide temporary buffs. You cannot have multiple identical potions active simultaneously.</li>
                             <li><strong>Rider Scroll (Unlock):</strong> A one-time purchase from the shop for <strong>50,000 PV</strong>. This item goes to your inventory. You then "Use" it from the locked Ring 2 slot in your Equipment (Inventory page) to permanently unlock it.</li>
                             <li><strong>Upgrade Scrolls:</strong> Basic, Advanced, and Master scrolls are available for item upgrades. You can buy these in quantities of 1 to 10. Purchasing these adds to your scroll count (visible in "MY MATERIALS"). Scroll prices are 125 PV (Basic), 250 PV (Advanced), and 500 PV (Master).
                                <ul>
                                    <li><strong>Basic Upgrade Scroll:</strong> Can only be used to upgrade an item from +0 to +1.</li>
                                    <li><strong>Advanced Upgrade Scroll:</strong> Can be used on items that are level +0, +1, or +2. Grants a **+10% success bonus** if the item is level +0 or +1.</li>
                                    <li><strong>Master Upgrade Scroll:</strong> Can be used on items from level +0 up to +4. Grants a <strong>+10% success bonus</strong> if the item is level +0, +1, +2, or +3.</li>                                </ul>
                             </li>
                                </ul>
                             </li>
                        </ul>
                        <h3>Crafting</h3>
                        <ul>
                            <li>Visit the "Crafting" page. The crafting GIF is now located here.</li>
                            <li>Use materials collected from adventures to craft powerful equipment.</li>
                            <li>You'll see a list of craftable items and their required materials. Hover over an item to see its full stats and recipe.</li>
                            <li>You cannot craft an item if you already own an instance of that base item ID. If an item is destroyed during a failed upgrade, you can then craft a new +0 version. You will be prompted to craft the item again if an upgrade fails.</li>
                        </ul>
                        
                        <h3>Inventory & Equipment</h3>
                        <ul>
                            <li><strong>View Items:</strong> The Inventory page shows all items you've crafted or bought (excluding Upgrade Scrolls). Hover over items to see their details. Upgraded items will show their level (e.g., +1, +2).</li>
                            <li><strong>Equip Items:</strong> Equip your crafted gear to gain passive bonuses, which contribute to your Attack and Defense stats shown in the left sidebar.
                                <ul>
                                    <li><strong>Slots:</strong> Armour, Helmet, Boots, Amulet, Ring 1, Ring 2, Weapon, Misc 1, Misc 2.</li>
                                    <li><strong>Unlocking Ring 2:</strong> Purchase the "Rider Scroll (Unlock)" from the Shop. It appears in "My Items". Go to "Inventory", and in "EQUIPPED ITEMS", click "Use Rider Scroll" on the locked Ring 2 slot. This consumes the scroll and unlocks the slot.</li>
                                </ul>
                            </li>
                            <li><strong>Unequip:</strong> You can unequip items. They return to "My Items".</li>
                            <li><strong>Item Levels:</strong> Items start at +0. They can be upgraded up to +5. +4 items have an orange highlight, +5 items have a dark red highlight. Item levels enhance their base effectiveness (+0% at +0, +25% at +1, +35% at +2, +45% at +3, +60% at +4, +80% at +5).</li>
                        </ul>

                        <h3>Item Upgrading (Upgrade Station)</h3>
                        <ul>
                            <li>Visit the "Upgrade" page.</li>
                            <li>Select an equippable item (from +0 to +4) and an Upgrade Scroll type. The pop-up shows your scroll counts.</li>
                            <li><strong>Scroll Compatibility & Bonus:</strong>
                                <ul>
                                    <li><strong>Basic Upgrade Scrolls (Tier 1 Scroll):</strong> Can *only* be used to upgrade an item from +0 to +1. The item's base tier (0-4) does not prevent its use for this specific +0 to +1 upgrade.</li>
                                    <li><strong>Advanced Upgrade Scrolls (Tier 2 Scroll):</strong> Can be used if the item's current level is +0, +1, or +2. The item's base tier (0-4) does not prevent its use. A +10% success chance bonus is granted if the item's base tier is 0 or 1 (lower than the scroll's tier).</li>
                                    <li><strong>Master Upgrade Scrolls (Tier 3 Scroll):</strong> Can be used if the item's current level is +0, +1, +2, +3, or +4. The item's base tier (0-4) does not prevent its use. A +10% success chance bonus is granted if the item's base tier is 0, 1, or 2 (lower than the scroll's tier).</li>
                                </ul>
                            </li>
                            <li>The success chance for the upgrade will be displayed.</li>
                            <li>Attempting an upgrade:
                                <ul>
                                    <li><strong>Success:</strong> Item level increases (e.g., +0 becomes +1). The item remains in the upgrade slot.</li>
                                    <li><strong>Failure:</strong> Item is **DESTROYED**! You'll be asked if you want to craft a new +0 version (if you have materials). If the destroyed item was equipped, and you re-craft it, it will be automatically re-equipped to its previous slot.</li>
                                </ul>
                            </li>
                            <li>Base Upgrade Chances (before any +10% bonus from higher-tier scrolls): +0 to +1 (100%), +1 to +2 (85%), +2 to +3 (50%), +3 to +4 (35%), +4 to +5 (13%). Max level is +5.</li>
                        </ul>

                        <h3>Other Features</h3>
                        <ul>
                            <li><strong>Dungeons:</strong> High-risk, high-reward challenges.
                                <ul>
                                    <li><strong>Unlocking:</strong> Dungeons require a specific high-level adventure to be active. Crypts (D1 & D2) require Adventure 4 to be active. ATH City (D3) requires Adventure 5 to be active.</li>
                                    <li><strong>Party System:</strong> Party Dungeons (D2 & D3) allow you to recruit placeholder NPCs to boost your stats. These NPCs will be replaced by the official Dungeon Crawler ordinal mint in the future.</li>
                                    <li><strong>Rewards:</strong> Dungeons are the primary source for the rarest crafting materials and unique, powerful equipment that cannot be crafted.</li>
                                </ul>
                            </li>
                            <li><strong>Quests:</strong> Complete objectives for rewards. Claim from the Quests page.</li>
                            <li><strong>Daily Login Rewards:</strong> Claim a reward every 24 hours.</li>
                            <li><strong>Whitelist Raffles:</strong> Participate in raffles.</li>
                            <li><strong>Leaderboards:</strong> See top players.</li>
                        </ul>

                        <h3>Community & Support</h3>
                        <ul>
                            <li><strong>Socials:</strong> Join our community! Links in header.</li>
                            <li><strong>Game Status:</strong> Punk Voyage Adventures is evolving. Feedback is valued!</li>
                        </ul>
                        <p>Good luck on your voyages, Voyager! May your hauls be plentiful and your Punks legendary!</p>
                    </div> 
                </section>
                <section id="pvp-page" class="page-content" style="align-items: center;">
                    <h2 class="page-title">PLAYER VS PLAYER</h2>
                    <div style="text-align:center; max-width: 600px;">
                        <p>PvP is not yet implemented.</p>
                        <p>By unlocking this scroll, you have flagged your account as ready for combat. When the feature goes live, you will be able to participate in battles for glory and rewards!</p>
                    </div>
                </section>
            </div>
<aside class="right-sidebar-menu"> <nav class="main-menu-nav"> <div class="sidebar-content-area" id="sidebarContentArea"> <ul class="main-menu-nav-list" id="mainMenuList"> 
                <li data-page="adventures-page" class="menu-list-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/adventures.jpg" alt="" class="menu-item-icon">ADVENTURES</li>  
                <li data-page="dungeons-page" class="menu-list-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/dungeons.jpg" alt="" class="menu-item-icon">DUNGEONS</li> 
                <li data-page="quests-page" class="menu-list-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/quest.jpg" alt="" class="menu-item-icon">QUESTS</li> 
                <li data-page="daily-rewards-page" class="menu-list-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/reward.jpg" alt="" class="menu-item-icon">DAILY LOGIN REWARDS</li> 
                <li data-page="shop-page" class="menu-list-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/shop.jpg" alt="" class="menu-item-icon">SHOP</li> 
                <li data-page="crafting-page" class="menu-list-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/crafting.jpg" alt="" class="menu-item-icon">CRAFTING</li> 
                <li data-page="inventory-page" class="menu-list-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/stash.jpg" alt="" class="menu-item-icon">INVENTORY</li>  
                <li data-page="upgrade-page" class="menu-list-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/anvil.jpg" alt="" class="menu-item-icon">UPGRADE</li> 
                <li data-page="leaderboard-page" class="menu-list-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/leaderboard.jpg" alt="" class="menu-item-icon">LEADERBOARD</li> 
                <li data-page="whitelist-page" class="menu-list-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/star.jpg" alt="" class="menu-item-icon">GIVEAWAYS</li> 
                <li data-page="help-page" class="menu-list-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/help.jpg" alt="" class="menu-item-icon">HELP</li> 
                <li data-page="pvp-page" class="menu-list-item" style="display: none;" id="pvp-menu-item"><img src="https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/pvp.jpg" alt="" class="menu-item-icon">PVP</li>    
            </ul> <div class="sidebar-active-adventures-container" id="sidebarActiveAdventuresDisplay"> <h3>ACTIVE ADVENTURES</h3> <div id="sidebarActiveAdventuresList"></div> </div> 
                              <div class="sidebar-active-adventures-container" id="sidebarActiveDungeonsDisplay" style="margin-top: 15px;">
                    <h3>ACTIVE DUNGEONS</h3>
                    <div id="sidebarActiveDungeonsList"></div>
                </div>
                
                <div class="active-potions-display hidden" id="activePotionsDisplay"> <h4>ACTIVE POTIONS</h4> <div id="activePotionsList"></div> </div> </div> </nav> </aside>
        </main>
    </div>

    <div id="customPopupOverlay" class="hidden"></div>
    <div id="customPopup" class="hidden">
        <h3 id="customPopupTitle">Notification</h3>
        <div id="customPopupMessage"></div> 
        <div id="customPopupButtons">
            <button id="customPopupConfirmBtn" class="action-button hidden">Confirm</button>
            <button id="customPopupCancelBtn" class="action-button hidden">Cancel</button>
            <button id="customPopupCloseBtn" class="action-button">OK</button>
        </div>
    </div>

    <!-- Item Selection Modal for Upgrading -->
    <div id="itemSelectionModalOverlay" class="hidden"></div>
    <div id="itemSelectionModal" class="hidden">
        <h3 id="itemSelectionModalTitle">Select Item</h3>
        <div id="itemSelectionModalList"></div>
        <button id="itemSelectionModalCloseBtn" class="action-button">Cancel</button>
    </div>

    <!-- Item Selection Modal for Upgrading -->
    <div id="itemSelectionModalOverlay" class="hidden"></div>
    <div id="itemSelectionModal" class="hidden">
        <h3 id="itemSelectionModalTitle">Select Item</h3>
        <div id="itemSelectionModalList"></div>
        <button id="itemSelectionModalCloseBtn" class="action-button">Cancel</button>
    </div>

    <!-- +++ NEW: Dungeon Crawler Selection Modal +++ -->
    <div id="dungeonCrawlerSelectionModalOverlay" class="hidden"></div>
    <div id="dungeonCrawlerSelectionModal" class="hidden">
        <h3 id="dungeonCrawlerSelectionModalTitle">Select Dungeon Crawlers</h3>
        <p id="dungeonCrawlerSelectionModalInfo" style="font-size: 0.9em; margin-bottom: 10px;">Select up to <span id="dungeonCrawlerMaxSelectCount">0</span> crawlers for this dungeon. (Future: Their stats will aid you!)</p>
        <div id="availableDungeonCrawlersList" style="max-height: 300px; overflow-y: auto; margin-bottom: 15px; border: 1px solid var(--border-color); padding: 10px;">
            <!-- Available crawlers will be listed here -->
        </div>
        <h4>Selected Crawlers:</h4>
        <div id="selectedDungeonCrawlersDisplay" style="min-height: 50px; border: 1px dashed var(--border-color); padding: 10px; margin-bottom: 15px;">
            <!-- Selected crawlers will appear here -->
        </div>
        <div id="dungeonCrawlerSelectionModalButtons" style="display: flex; justify-content: center; gap: 15px;">
            <button id="dungeonCrawlerConfirmSelectionBtn" class="action-button">Confirm Selection</button>
            <button id="dungeonCrawlerCancelSelectionBtn" class="action-button">Cancel</button>
        </div>
    </div>
    <!-- +++ END OF NEW MODAL +++ -->

    <script type="module" id="firebaseModule">
        // ... your firebase script ...
    </script>

    <script type="module" id="firebaseModule">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, Timestamp, query, where, orderBy, getDocs, addDoc, runTransaction, updateDoc, deleteDoc, limit } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js"; 
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-analytics.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js";


        const firebaseConfig = {
            apiKey: "AIzaSyASoKVnbNVJBASSPEnWOvkocTwM16ijNxM", 
            authDomain: "punkvoyage.firebaseapp.com",
            projectId: "punkvoyage",
            storageBucket: "punkvoyage.appspot.com", 
            messagingSenderId: "929081617432",
            appId: "1:929081617432:web:1603e242f9cceb79ee676d",
            measurementId: "G-R5ESCD03L9"
        };
        

        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const analytics = getAnalytics(app); 
            const auth = getAuth(app); 

            window.firebaseApp = app;
            window.firebaseDb = db;
            window.fbAuth = auth; 
            window.firebaseFirestore = { doc, getDoc, setDoc, collection, Timestamp, query, where, orderBy, getDocs, addDoc, runTransaction, updateDoc, deleteDoc, limit };
            window.firebaseAuthFunctions = { createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail, GoogleAuthProvider, signInWithPopup }; 
            
            document.dispatchEvent(new CustomEvent('firebaseReady'));
            console.log("Firebase Initialized Successfully (including Auth with Google) and 'firebaseReady' event dispatched.");

        } catch (error) {
            console.error("Firebase initialization failed:", error);
            setTimeout(() => { 
                const popupTitle = document.getElementById('customPopupTitle');
                const popupMessage = document.getElementById('customPopupMessage');
                const popupOverlay = document.getElementById('customPopupOverlay');
                const popupItself = document.getElementById('customPopup');
                if (popupTitle && popupMessage && popupOverlay && popupItself) {
                     popupTitle.textContent = "Critical Error";
                     popupMessage.innerHTML = "Failed to connect to game services. Please ensure your Firebase configuration is correct and you are online. Error: " + error.message;
                     popupOverlay.classList.remove('hidden');
                     popupItself.classList.remove('hidden');
                } else {
                    alert("CRITICAL FIREBASE ERROR: " + error.message + "\nCheck Firebase config and internet connection."); 
                }
            }, 100);
        }
    </script>

    <script>
        
        document.addEventListener('firebaseReady', async () => {
                   let punkVoyageIdsLoaded = false;
                   
                    console.log("FirebaseReady event triggered. Starting main script logic.");
                const userOrdinalsDisplayElement = document.getElementById('userOrdinalsDisplay');
    const userOrdinalsListElement = document.getElementById('userOrdinalsList');
    let PUNK_VOYAGE_IDS_SET = new Set(); // To store your fixed inscription IDs for quick lookup
    const PUNK_VOYAGE_ID_IMAGE_CACHE = {}; // Simple cache for inscription images

function updateAdventureCardPvDisplay() {
            // The actual body of this function should start here.
            // For example, from your previous working code:
            console.log("Updating adventure card PV displays...");
            const adventureSendButtons = document.querySelectorAll('.adventure-send-btn');
            adventureSendButtons.forEach(button => {
                const adventureBlock = button.closest('.adventure');
                if (!adventureBlock) return;

                const detailsDiv = adventureBlock.querySelector('.adventure-details');
                if (!detailsDiv) return;

                const prizeSpan = detailsDiv.querySelector('.prize');
                if (prizeSpan && button.dataset.pvReward) {
                    const basePvFromButton = parseInt(button.dataset.pvReward);
                    const displayPv = basePvFromButton * 2; // Calculate the doubled PV for display
                    prizeSpan.innerHTML = prizeSpan.innerHTML.replace(/(PRIZE\s*=\s*)(\d+)(\s*PV TOKENS)/i, `$1${displayPv}$3`);
                    console.log(`Updated PV display for ${button.dataset.adventureName} to ${displayPv}`);
                }
            });
        } 
            console.log("'firebaseReady' event received by main script. Initializing game logic.");
            
            const db = window.firebaseDb;
            const auth = window.fbAuth; 
            const { doc, getDoc, setDoc, collection, Timestamp, query, where, orderBy, getDocs, addDoc, runTransaction, updateDoc, deleteDoc, limit } = window.firebaseFirestore;
            const { createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut: fbSignOut, onAuthStateChanged, sendPasswordResetEmail, GoogleAuthProvider, signInWithPopup } = window.firebaseAuthFunctions; 

            const GAME_HOUR_IN_REAL_SECONDS = 3600; 
            const TWENTY_FOUR_HOURS_MS = 24 * 60 * 60 * 1000;
            const DUNGEON_RESET_HOUR_UTC = 21; // 24-hour format (0-23)
            const DUNGEON_RESET_MINUTE_UTC = 0;

            const gameContainer = document.getElementById('gameContainer');
            const playerNicknameDisplay = document.getElementById('playerNicknameDisplay');
            const darkModeToggle = document.getElementById('darkModeToggle');
            const body = document.body;
            const twitterWidgetContainer = document.getElementById('twitter-widget-container');
            const pvCountElement = document.getElementById('pvCount');
            const goldCountElement = document.getElementById('goldCount');
            const diamondCountElement = document.getElementById('diamondCount');
            const adventureSendButtons = document.querySelectorAll('.adventure-send-btn');
            const adventureDropButtons = document.querySelectorAll('.adventure-drops-button');
            
            const swapInfoDisplay = document.getElementById('swapInfoDisplay');
            const swapBtn = document.getElementById('swapBtn');
            const reverseSwapDirectionBtn = document.getElementById('reverseSwapDirectionBtn');

            const sidebarActiveAdventuresContainer = document.getElementById('sidebarActiveAdventuresDisplay'); 
            const sidebarActiveAdventuresList = document.getElementById('sidebarActiveAdventuresList');
            const activePotionsDisplay = document.getElementById('activePotionsDisplay');
            const activePotionsList = document.getElementById('activePotionsList');
            const availableAdventurersCountElement = document.getElementById('availableAdventurersCount');
            const playerAttackStatElement = document.getElementById('playerAttackStat');
            const playerDefenseStatElement = document.getElementById('playerDefenseStat');

            const menuItems = document.querySelectorAll('.right-sidebar-menu .main-menu-nav-list li');
            const pageContents = document.querySelectorAll('.main-content-area .page-content'); 
            const questListDiv = document.getElementById('questList');
            const shopItemsDiv = document.getElementById('shopItems');
            const materialsListContainer = document.getElementById('materialsListContainer'); 
            const craftingItemsContainer = document.getElementById('craftingItemsContainer');
            const inventoryItemsContainer = document.getElementById('inventoryItemsContainer');
            const equipmentSlotsDisplay = document.getElementById('equipmentSlotsDisplay');
            const dailyRewardsGrid = document.getElementById('dailyRewardsGrid');
            const customPopupOverlay = document.getElementById('customPopupOverlay');
            const customPopup = document.getElementById('customPopup');
            const customPopupTitleEl = document.getElementById('customPopupTitle');
            const customPopupMessageEl = document.getElementById('customPopupMessage');
            const customPopupButtonsEl = document.getElementById('customPopupButtons');
            const customPopupCloseBtn = document.getElementById('customPopupCloseBtn');
            const customPopupConfirmBtn = document.getElementById('customPopupConfirmBtn');
            const customPopupCancelBtn = document.getElementById('customPopupCancelBtn');
            const adminRafflePanel = document.getElementById('adminRafflePanel');
            const createRaffleForm = document.getElementById('createRaffleForm');
            const whitelistRafflesContainer = document.getElementById('whitelistRafflesContainer');
            const itemTooltipElement = document.getElementById('itemTooltip');
            const ADMIN_WALLET_ADDRESSES = ["bc1pqfhcseq6vamzuewctlrq663j4w6nwr3favse5acm807fjdkgh6zq5y6ecg"];


            // Leaderboard elements
            const leaderboardFilterButtons = document.querySelectorAll('.leaderboard-filter-btn');
            const leaderboardDisplayList = document.getElementById('leaderboardDisplayList');
            const leaderboardCurrentTypeTitle = document.getElementById('leaderboardCurrentTypeTitle');
            const leaderboardPrevBtn = document.getElementById('leaderboardPrevBtn');
            const leaderboardNextBtn = document.getElementById('leaderboardNextBtn');
            const leaderboardPageInfo = document.getElementById('leaderboardPageInfo');
            let leaderboardCurrentPage = 1;
            const leaderboardItemsPerPage = 20;
            let leaderboardResourceType = 'pvTokens';
            let leaderboardAllUsers = [];

            async function fetchAndDisplayLeaderboards(resourceType = 'pvTokens') {
                console.log('fetchAndDisplayLeaderboards called with', resourceType);
                if (!db) { console.error("Firestore not initialized for fetching leaderboards."); return; }
                if (!leaderboardDisplayList || !leaderboardCurrentTypeTitle || !leaderboardPrevBtn || !leaderboardNextBtn || !leaderboardPageInfo) return;
                leaderboardDisplayList.innerHTML = '<li>Loading...</li>';
                let titleText = 'Leaderboard';
                let scoreClass = '';
                if (resourceType === 'pvTokens') { titleText = 'PV Token Leaders'; scoreClass = 'pv'; }
                else if (resourceType === 'gold') { titleText = 'Gold Leaders'; scoreClass = 'gold'; }
                else if (resourceType === 'diamonds') { titleText = 'Diamond Leaders'; scoreClass = 'diamond'; }
                leaderboardCurrentTypeTitle.textContent = titleText;
                leaderboardFilterButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.resource === resourceType);
                });
                leaderboardPrevBtn.disabled = true;
                leaderboardNextBtn.disabled = true;
                leaderboardCurrentPage = 1;
                try {
                    const q_leaderboard = query(collection(db, "playerProgress"), orderBy(resourceType, "desc"), limit(100));
                    const querySnapshot = await getDocs(q_leaderboard);
                    leaderboardAllUsers = querySnapshot.docs.map(docSnap => ({
                        id: docSnap.id,
                        ...docSnap.data()
                    }));
                    renderLeaderboardPage();
                } catch (error) {
                    console.error(`Error fetching ${resourceType} leaderboard: `, error);
                    leaderboardDisplayList.innerHTML = `<li>Error loading ${resourceType} leaderboard.</li>`;
                }
            }

            function renderLeaderboardPage() {
                leaderboardDisplayList.innerHTML = '';
                if (leaderboardAllUsers.length === 0) {
                    leaderboardDisplayList.innerHTML = '<li>No players on this leaderboard yet.</li>';
                    leaderboardPrevBtn.disabled = true;
                    leaderboardNextBtn.disabled = true;
                    leaderboardPageInfo.textContent = `Page 1`;
                    return;
                }
                const startIdx = (leaderboardCurrentPage - 1) * leaderboardItemsPerPage;
                const endIdx = startIdx + leaderboardItemsPerPage;
                const usersToShow = leaderboardAllUsers.slice(startIdx, endIdx);
                let rank = startIdx + 1;
                usersToShow.forEach(playerData => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="rank">${rank}.</span> <span class="nickname">${playerData.nickname || 'Anonymous'}</span> <span class="score ${getScoreClass(leaderboardResourceType)}">${playerData[leaderboardResourceType] || 0}</span>`;
                    li.dataset.playerId = playerData.id;
                    li.addEventListener('mouseenter', (event) => {
                        showPlayerInventoryTooltip(event, playerData.id);
                    });
                    li.addEventListener('mouseleave', () => {
                        hideItemTooltip();
                    });
                    leaderboardDisplayList.appendChild(li);
                    rank++;
                });
                leaderboardPrevBtn.disabled = leaderboardCurrentPage === 1;
                leaderboardNextBtn.disabled = endIdx >= leaderboardAllUsers.length;
                leaderboardPageInfo.textContent = `Page ${leaderboardCurrentPage}`;
            }

            function getScoreClass(resourceType) {
                if (resourceType === 'pvTokens') return 'pv';
                if (resourceType === 'gold') return 'gold';
                if (resourceType === 'diamonds') return 'diamond';
                return '';
            }

            if (leaderboardFilterButtons && leaderboardPrevBtn && leaderboardNextBtn) {
                leaderboardFilterButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        leaderboardResourceType = e.target.dataset.resource;
                        fetchAndDisplayLeaderboards(leaderboardResourceType);
                    });
                });
                leaderboardPrevBtn.addEventListener('click', () => {
                    if (leaderboardCurrentPage > 1) {
                        leaderboardCurrentPage--;
                        renderLeaderboardPage();
                    }
                });
                leaderboardNextBtn.addEventListener('click', () => {
                    const maxPage = Math.ceil(leaderboardAllUsers.length / leaderboardItemsPerPage);
                    if (leaderboardCurrentPage < maxPage) {
                        leaderboardCurrentPage++;
                        renderLeaderboardPage();
                    }
                });
                // Load leaderboard by default
                fetchAndDisplayLeaderboards('pvTokens');
            }

            // Upgrade Page Elements
            const upgradeItemSlot = document.getElementById('upgradeItemSlot');
            const upgradeScrollSlot = document.getElementById('upgradeScrollSlot');
            const selectedItemForUpgradeDisplay = document.getElementById('selectedItemForUpgradeDisplay');
            const selectedScrollForUpgradeDisplay = document.getElementById('selectedScrollForUpgradeDisplay');
            const upgradeItemButton = document.getElementById('upgradeItemButton');
            const upgradeSuccessRateDisplay = document.getElementById('upgradeSuccessRateDisplay');
            const upgradeResultDisplay = document.getElementById('upgradeResultDisplay');
            const itemSelectionModalOverlay = document.getElementById('itemSelectionModalOverlay');
            const itemSelectionModal = document.getElementById('itemSelectionModal');
            const itemSelectionModalTitle = document.getElementById('itemSelectionModalTitle');
            const itemSelectionModalList = document.getElementById('itemSelectionModalList');
            const itemSelectionModalCloseBtn = document.getElementById('itemSelectionModalCloseBtn');
             const activeSpecialtiesDisplay = document.getElementById('activeSpecialtiesDisplay');
            const toggleSpecialtiesBtn = document.getElementById('toggleSpecialtiesBtn');
            const specialtiesListContainer = document.getElementById('specialtiesListContainer');
                const dungeonCrawlerSelectionModalOverlay = document.getElementById('dungeonCrawlerSelectionModalOverlay');
            const dungeonCrawlerSelectionModal = document.getElementById('dungeonCrawlerSelectionModal');
            const dungeonCrawlerSelectionModalTitle = document.getElementById('dungeonCrawlerSelectionModalTitle');
            const dungeonCrawlerSelectionModalInfo = document.getElementById('dungeonCrawlerSelectionModalInfo');
            const dungeonCrawlerMaxSelectCountSpan = document.getElementById('dungeonCrawlerMaxSelectCount');
            const availableDungeonCrawlersListDiv = document.getElementById('availableDungeonCrawlersList');
            const selectedDungeonCrawlersDisplayDiv = document.getElementById('selectedDungeonCrawlersDisplay');
            const dungeonCrawlerConfirmSelectionBtn = document.getElementById('dungeonCrawlerConfirmSelectionBtn');
            const dungeonCrawlerCancelSelectionBtn = document.getElementById('dungeonCrawlerCancelSelectionBtn');

            // --- Game State Variables ---
            let currentUser = null; 
            let userNickname = ''; 
            let MAX_PLAYER_ADVENTURERS = 1;
            let currentPvTokens = 0; let currentGold = 0; let currentDiamonds = 0;
            let activeAdventures = []; let nextActiveAdventureId = 0;
            let totalAvailableAdventurers = MAX_PLAYER_ADVENTURERS;
            let playerInventory = []; 
            let nextUniqueInstanceId = 0; 
            let playerScrolls = { low: 0, middle: 0, high: 0 };
            let playerHasPurchasedRiderScroll = false;
            let playerHasPurchasedPetWhistle = false;
            let totalAdventuresCompleted = 0;
            let ordinalBonusAdventurers = 0;
            let activeDungeons = [];
            let craftingCurrentPage = 1;
            let craftingShowOnlyCraftable = false;
            let currentDungeonIndex = 0;
            let playerHasPurchasedPvpScroll = false;

const craftingItemsPerPage = 5;
let craftingFilterType = 'all';
let craftableItemsDataFiltered = [];
let questsCurrentPage = 1;
const questsItemsPerPage = 5;
let questsShowCompleted = false;
let questsFiltered = [];


const initialPlayerMaterials = { 
    "Leather": 0, "Wood": 0, "Clover": 0, "Fabric": 0, "Iron": 0, "Gizmo Tail": 0, 
    "Stone": 0, "Obsidian": 0, "Bitcoin": 0, "Bone": 0, "Flame Essence": 0, 
    "Essence of Death": 0, "Rider's Sigil": 0, "Ancient Tablet Fragment": 0, "Shadowgem": 0,
    "Glitch Fabric": 0, "Quantum Shard": 0,
    "Fire Ink": 0, "Zeus's Tear": 0, "Indian Street Food": 0,
    "Void Crystal": 0, "ATH Ash": 0 // ADDED NEW MATERIALS
};
            let playerMaterials = { ...initialPlayerMaterials };

            let equippedItems = {
                Armour: null, Helmet: null, Boots: null, Amulet: null,
                Ring1: null, Ring2: null, Weapon: null, Pet: null, // ADDED Pet: null
                Misc1: null, Misc2: null
            };
            let playerAdventurerLevel = 1; 
            let secondRingSlotUnlocked = false;
                    let petSlotUnlocked = false;
            let activePotions = [];
            let allRaffles = []; 
            let playerRaffleEntries = {}; 
            
let lastDailyRewardDayClaimed = 0;
            let lastDailyRewardClaimTimestamp = 0;

            // +++ NEW DUNGEON STATE VARIABLES +++
            let playerDungeonEntriesToday = { dungeon_1: 0, dungeon_2: 0 };
            let lastDungeonResetTimestamp = 0;
            let playerDungeonCrawlers = []; // To store owned Dungeon Crawler NFT instances
            const PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET = new Set(); // Will be populated later
            let dungeonCrawlerIdsLoaded = false;
            // +++ END OF NEW DUNGEON STATE VARIABLES +++

            let popupMessageQueue = [];
            let isPopupCurrentlyVisible = false;
            let currentPopupCraftCallback = null; 
            let currentPopupConfirmCallback = null;


            let selectedItemForUpgrade = null; 
            let selectedScrollForUpgrade = null; 
            let isGoldToDiamondSwap = true;
            let walletVerificationPendingForBonus = false;

            
            // --- Game Data ---
             const adventuresData = { 
                "1": { name: "Spirit Forest", drops: [ { name: "Leather", chance: 0.15, qty: 1}, { name: "Wood", chance: 0.20, qty: 1}, { name: "Clover", chance: 0.05, qty: 1}, { name: "Fabric", chance: 0.04, qty: 1} ] }, 
                "2": { name: "Mountain of the Marowan", drops: [ { name: "Iron", chance: 0.15, qty: 1}, { name: "Gizmo Tail", chance: 0.03, qty: 1}, { name: "Stone", chance: 0.20, qty: 1} ] }, 
                "3": { name: "Fire Fields of Flyinals", adventurerRequirement: 2, drops: [ { name: "Obsidian", chance: 0.15, qty: 1}, { name: "Bitcoin", chance: 0.001, qty: 1}, { name: "Flame Essence", chance: 0.085, qty: 1} ] }, 
                "4": { name: "Tomb of the Death Riders", adventurerRequirement: 5, drops: [ { name: "Bone", chance: 0.25, qty: 1}, { name: "Essence of Death", chance: 0.15, qty: 1}, { name: "Bitcoin", chance: 0.019, qty: 1},  { name: "Rider's Sigil", chance: 0.14, qty: 1}, { name: "Ancient Tablet Fragment", chance: 0.08, qty: 1}, { name: "Shadowgem", chance: 0.05, qty: 1} ] },
                            "5": { 
                name: "The Cyber Void Echo", 
                adventurerRequirement: 10, 
                drops: [ 
                    { name: "Glitch Fabric", chance: 0.05, qty: 1 }, // New Material 1
                    { name: "Quantum Shard", chance: 0.05, qty: 1 }  // New Material 2
                ] 
            },
            "5": { 
                    name: "The Cyber Void Echo", 
                    adventurerRequirement: 10,
                    guaranteedGold: 5, // Add this
                    diamondRewardMultiplier: 3, // Add this (applied if diamondChance hits)
                    drops: [ 
                        { name: "Glitch Fabric", chance: 0.05, qty: 1 }, 
                        { name: "Quantum Shard", chance: 0.05, qty: 1 }
                    ] 
                }
            };
            const materialTiers = {
    1: ["Leather", "Wood", "Clover", "Fabric"],
    2: ["Iron", "Gizmo Tail", "Stone"],
    3: ["Obsidian", "Bitcoin", "Flame Essence"], 
    4: ["Bone", "Essence of Death", "Rider's Sigil", "Ancient Tablet Fragment", "Shadowgem"],
    5: ["Glitch Fabric", "Quantum Shard"],
    6: ["Fire Ink", "Zeus's Tear", "Indian Street Food", "Void Crystal", "ATH Ash"] // ADDED NEW MATERIALS
};
                         const scrollData = { // scrollTier: 1=Basic (+0->+1), 2=Advanced (Up to +3), 3=Master (Up to +5)
                low: { name: "Basic Upgrade Scroll", descriptionName: "Basic Upgrade Scroll (+0 to +1)", icon: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/low%20upgrade%20scroll.jpg", tier: 1, shopId: "scroll_low" },
                middle: { name: "Advanced Upgrade Scroll", descriptionName: "Advanced Upgrade Scroll (Up to +3)", icon: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/middle%20upgrade%20scroll.jpg", tier: 2, shopId: "scroll_mid" },
                high: { name: "Master Upgrade Scroll", descriptionName: "Master Upgrade Scroll (Up to +5)", icon: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/high%20upgrade%20scroll.jpg", tier: 3, shopId: "scroll_high"}
            };

            const craftableItemsData = [
    { 
        id: "boots1", name: "Warped Boots", type: "Boots", 
        description: "Reduces adventure time by 30 minutes + 2% of total time.", // UPDATED
        perk: { type: "timeReductionHybrid", flat: 1800, percent: 0.02 }, // UPDATED
        recipe: { "Leather": 5, "Fabric": 3 }, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/main/boots.jpg", tier: 1 
    }, 
    { 
        id: "amulet1", name: "Amulet of Greed", type: "Amulet", 
        description: "Increases Gold find chance by +50% of current chance.", 
        perk: { type: "goldChanceIncrease", value: 0.5 }, 
        recipe: { "Iron": 3, "Gizmo Tail": 1 }, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/amuletofgreed.jpg", tier: 2 
    }, 
    { 
        id: "rucksack1", name: "Efficient Rucksack", type: "Rucksack", 
        description: "+10% PV tokens from adventures.", 
        perk: { type: "pvBonus", value: 0.10 }, 
        recipe: { "Fabric": 5, "Leather": 2 }, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/pouch.jpg", tier: 1 
    }, 
    { 
        id: "trinket1", name: "Lucky Rabbit's Foot", type: "Trinket", 
        description: "Increases material find chance by x1.3 (multiplicative).", 
        perk: { type: "materialChanceMultiplier", value: 1.3 }, 
        recipe: { "Clover": 3, "Bone": 2 }, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/rabbit%20foot.jpg", tier: 4 
    }, 
    { 
        id: "weapon1", name: "Rider's Blade", type: "Weapon", 
        description: "A blade echoing with the cries of the fallen. (+5 Attack)", 
        perk: {type: "attackBoost", value: 5}, 
        recipe: { "Rider's Sigil": 2, "Essence of Death": 3, "Iron": 5}, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/sword.jpg", tier: 4
    }, 
    { 
        id: "armour1", name: "Shadow-Woven Armour", type: "Armour", 
        description: "Provides moderate protection. (+10 Defense)", 
        perk: {type: "defenseBoost", value: 10}, 
        recipe: {"Obsidian": 5, "Essence of Death": 2, "Shadowgem": 1}, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/armour.jpg", tier: 4
    }, 
    { 
        id: "helmet1", name: "Helm of the Silent Watcher", type: "Helmet", 
        description: "Offers a gaze that pierces the veil. (+3 Defense)", 
        perk: {type: "defenseBoost", value: 3}, 
        recipe: {"Iron": 4, "Rider's Sigil": 1, "Shadowgem": 1}, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/helmet.jpg", tier: 4
    }, 
    { 
        id: "ring_warding", name: "Ring of Minor Warding", type: "Ring", 
        description: "Offers slight protection. (+2 Defense, +5% Gold/Diamond Find)", // UPDATED
        perk: {type: "statAndCurrencyBoost", defense: 2, goldBonus: 0.05, diamondBonus: 0.05}, // UPDATED
        recipe: {"Stone": 10, "Clover": 5}, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/ring1.jpeg", tier: 2
    }, 
    { 
        id: "ring_swiftness", name: "Band of Swiftness", type: "Ring", 
        description: "Slightly reduces adventure times. (-30 min)", // UPDATED
        perk: {type: "timeReduction", value: 1800}, // UPDATED
        recipe: {"Leather": 8, "Gizmo Tail": 3}, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/ring2.jpeg", tier: 2
    }, 
    { 
        id: "ring_cursedpower", name: "Cursed Ring of Power", type: "Ring", 
        description: "Grants power, but at a cost. (+5 Attack, -2 Defense)", 
        perk: {type: "statBoost", attack: 5, defense: -2}, 
        recipe: {"Rider's Sigil": 3, "Shadowgem": 2, "Essence of Death": 1}, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/ring3.jpg", tier: 4
    },
    {
        id: "pet_gizmo", name: "Gizmo", type: "Pet",
        description: "A loyal and surprisingly resilient Gizmo. (+2 Attack, +2 Defense)",
        perk: { type: "statBoost", attack: 2, defense: 2 },
        recipe: { "Ancient Tablet Fragment": 1, "Flame Essence": 1, "Bitcoin": 1, "Wood": 10 },
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/gizmo2.jpg", tier: 3 
    },
    {
        id: "dungeon_helmet", name: "Dungeon Helmet of Assault", type: "Helmet",
        description: "A sturdy helmet retrieved from the crypt. (+3 Attack)",
        perk: { type: "attackBoost", value: 3 },
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/main/dHELMET.jpg", tier: 2
    },
    {
        id: "dungeon_boots", name: "Dungeon Boots of Swiftness", type: "Boots",
        description: "Boots that tread forgotten paths. (+3 Attack, -10% Dungeon Time)", // UPDATED
        perk: { type: "statAndDungeonTime", attack: 3, timeReduction: 0.10 }, // UPDATED
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/main/dBOOTS.jpg", tier: 2
    },
    {
        id: "dungeon_sword", name: "Crypt Lord's Hammer", type: "Weapon",
        description: "A powerful hammer, pulsing with dungeon energy. (+7 Attack)",
        perk: { type: "attackBoost", value: 7 },
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/main/dWEAPON.jpg", tier: 4
    },
    {
        id: "dungeon_armour", name: "Crypt Lord's Plate", type: "Armour",
        description: "Resilient armour forged in the depths. (+14 Defense)",
        perk: { type: "defenseBoost", value: 14 },
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/main/dARMOR.jpg", tier: 4
    },
    {
        id: "pizza_pendant", name: "Pizza Pendant of Greed", type: "Amulet",
        description: "Smells faintly of pepperoni. Grants +1 daily entry to Dungeon 1 & 2.",
        perk: { type: "dungeonEntryBonus", dungeon1: 1, dungeon2: 1 },
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/main/pizzapendant.jpg", tier: 3
    },
    {
        id: "orb_of_haste", name: "Orb of Minor Haste", type: "Misc",
        description: "Swirls with temporal energies. Reduces adventure times by 10%.", // UPDATED
        perk: { type: "timeReductionPercent", value: 0.10 }, // UPDATED
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/main/orbofhaste.jpg", tier: 3
    },
    {
        id: "pet_dog", name: "$DOG Pet", type: "Pet",
        description: "A good boy. After completing a dungeon, fetches 1 random adventure material.",
        perk: { type: "dungeonMaterialFetch", count: 1 },
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/pet3.jpg", tier: 3
    },
    {
        id: "void_compass", name: "Void Compass", type: "Misc",
        description: "What is this pointing at? Definitely not the North Pole... Might be useful in the future.",
        perk: null,
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/voidcompass.jpg", tier: 5
    },
    {
        id: "ath_talisman", name: "ATH Talisman", type: "Misc",
        description: "A relic from the All-Time-High city. Grants +1 Crawler spot for Dungeon 2 & 3.",
        perk: { type: "crawlerSlotBonus", dungeon2: 1, dungeon3: 1 },
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/Talisman%20ath.jpg", tier: 5
    },
    {
        id: "fire_sword_satoshi", name: "Fire Sword of Satoshi", type: "Weapon",
        description: "A blade forged in the genesis block. (+10 Attack, +1 Dungeon 1 Entry)",
        perk: { type: "statAndEntryBoost", attack: 10, dungeon1: 1 },
        recipe: { "Glitch Fabric": 3, "Quantum Shard": 3, "Void Crystal": 5, "ATH Ash": 5, "Fire Ink": 1 }, // UPDATED RECIPE
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/fire%20sword%20of%20satoshi.jpg", tier: 5
    },
    {
        id: "krakkin_bow", name: "Krakkin Bow", type: "Weapon",
        description: "A powerful but unwieldy bow. (+15 Attack, -5 Defense, +1 Dungeon 2 Entry)",
        perk: { type: "statAndEntryBoost", attack: 15, defense: -5, dungeon2: 1 },
        recipe: { "Glitch Fabric": 3, "Quantum Shard": 3, "Void Crystal": 5, "ATH Ash": 5, "Zeus's Tear": 1 }, // UPDATED RECIPE
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/krakkin%20bow.jpg", tier: 5
    },
    {
        id: "poisy_daggs", name: "Poisy Daggs", type: "Weapon",
        description: "Daggers dripping with a potent alchemical brew. (+7 Attack, +2 Defense, Doubles Dungeon PV Rewards)",
        perk: { type: "statAndDungeonPVBoost", attack: 7, defense: 2, pvMultiplier: 2 },
        recipe: { "Glitch Fabric": 3, "Quantum Shard": 3, "Void Crystal": 5, "ATH Ash": 5, "Indian Street Food": 1 }, // UPDATED RECIPE
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/poison%20daggers.jpg", tier: 5
    },
    {
        id: "pet_bat", name: "Echo Bat", type: "Pet",
        description: "A creature of the void. Has a 10% chance to duplicate material drops from Dungeon 3.", // UPDATED
        perk: { type: "dungeonDropEcho", chance: 0.10, dungeonId: "dungeon_3" }, // UPDATED
        iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/pet%20bat.jpg", tier: 5
    }
];

            const shopItemsData = [ 
                { id: "potion2", name: "PV Doubler (1 Use)", description: "Doubles PV rewards from NEXT adventure.", price: 200, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/pv%20doubler.jpg", type: "buff", durationAdventures: 1, effect: { type: "pvMultiplier", value: 2 } }, 
                { id: "potion3", name: "Gold Magnet (3 Adventures)", description: "Adds +1% FLAT chance of finding gold on next 3 adventures.", price: 400, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/gold%20magnet.jpg", type: "buff", durationAdventures: 3, effect: { type: "goldChanceBonus", flatValue: 0.01 } }, 
                { id: "scroll_low", name: scrollData.low.descriptionName, description: "Used for upgrading items from level +0 to +1.", price: 125, iconUrlOrColor: scrollData.low.icon, type: "upgrade_scroll_purchase", scrollTypeKey: "low"},
                { 
    id: "scroll_mid", 
    name: scrollData.middle.descriptionName, 
    description: "Used for items at +0, +1, or +2. Grants +10% success bonus if item's level is +0 or +1.", // CORRECTED TEXT
    price: 250, 
    iconUrlOrColor: scrollData.middle.icon, 
    type: "upgrade_scroll_purchase", 
    scrollTypeKey: "middle"
},
{ 
    id: "scroll_high", 
    name: scrollData.high.descriptionName, 
    description: "Used for items at +0 up to +4. Grants +10% success bonus if item's level is +0, +1, +2, or +3.", // CORRECTED TEXT
    price: 500, 
    iconUrlOrColor: scrollData.high.icon, 
    type: "upgrade_scroll_purchase", 
    scrollTypeKey: "high"
},
                { id: "rider_scroll_unlock", name: "Rider Scroll (Unlock)", description: "Permanently unlocks your second Ring Slot. One-time purchase, consumed on use from Equipment Slot.", price: 5000, iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/riders%20scroll.jpg", type: "unlockable_consumable" },
                { // ADD THIS NEW ITEM
                id: "pet_whistle_unlock",
                name: "Ancient Pet Whistle (Unlock)",
                description: "Permanently unlocks your Pet Slot. One-time purchase, consumed on use from Equipment Slot.",
                price: 5000,
                iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/petwhistle.jpg", // <-- UPDATED ICON
                type: "unlockable_consumable"
            },
            {
    id: "upgrade_booster",
    name: "Upgrade Booster",
    description: "Consumed on purchase. Grants +10% FLAT success chance to your NEXT item upgrade attempt.",
    price: 5000, // PV cost
    goldPrice: 2, // Gold cost
    iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/booster.jpg",
    type: "buff",
    durationUpgrades: 1, // Lasts for 1 upgrade
    effect: { type: "upgradeChanceBonus", flatValue: 0.10 }
},
{
    id: "pvp_scroll_unlock",
    name: "Mastery Scroll (PvP)",
    description: "Permanently enables PvP. You can attack and be attacked by other players. One-time purchase, consumed on use.",
    price: 250000, // PV cost
    goldPrice: 50, // Gold cost
    diamondPrice: 5, // Diamond cost
    iconUrlOrColor: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/pvp.jpg",
    type: "unlockable_consumable"
}
        ];


            const quests = [ 
                { id: 1, text: "Complete Spirit Forest 5 times", reward: "50 PV", completed: false, progress: 0, target: 5, adventureName: "Spirit Forest" }, 
                { id: 2, text: "Complete Mountain of the Marowan 5 times", reward: "75 PV", completed: false, progress: 0, target: 5, adventureName: "Mountain of the Marowan"}, 
                { id: 3, text: "Complete Fire Fields of Flyinals 5 times", reward: "150 PV", completed: false, progress: 0, target: 5, adventureName: "Fire Fields of Flyinals"}, 
                { id: 4, text: "Venture into the Tomb of the Death Riders", reward: "250 PV, 1 Diamond", completed: false, progress: 0, target: 1, adventureName: "Tomb of the Death Riders"},
                { id: 5, text: "Craft any 3 items", reward: "100 PV", completed: false, progress: 0, target: 3, metric: "itemsCrafted" },
                { id: 6, text: "Accumulate 1000 PV Tokens", reward: "1 Gold", completed: false, progress: 0, target: 1000, metric: "pvBalance" }, 
                { id: 7, text: "Upgrade any item to +2", reward: "200 PV", completed: false, progress: 0, target: 1, metric: "itemUpgradedToPlus2" }, 
                { id: 8, text: "Collect 10 Iron materials", reward: "50 PV", completed: false, progress: 0, target: 10, metric: "materialCollected_Iron" },
                { id: 9, text: "Complete 25 total adventures (any type)", reward: "1 Diamond, 100 PV", completed: false, progress: 0, target: 25, metric: "totalAdventuresCompletedOverall" },
                { id: 10, text: "Equip a full set of Tier 1 gear (Boots, Rucksack)", reward: "150 PV", completed: false, progress: 0, target: 2, metric: "equippedTier1Set" },
                { id: 11, text: "Reach 10 Attack Power", reward: "1 Gold, 50 PV", completed: false, progress: 0, target: 10, metric: "attackPower" },
                { id: 12, text: "Successfully upgrade an item to +3", reward: "1 Diamond, 100 PV", completed: false, progress: 0, target: 1, metric: "itemUpgradedToPlus3" },
                { id: 13, text: "Use a PV Doubler Potion", reward: "25 PV", completed: false, progress: 0, target: 1, metric: "potionUsed_potion2" },
                { id: 14, text: "Find 5 Gold from adventures", reward: "100 PV, 1 Diamond", completed: false, progress: 0, target: 5, metric: "goldFoundAdventures" },
                { id: 15, text: "Complete Tomb of the Death Riders 5 times", reward: "500 PV, 2 Diamonds", completed: false, progress: 0, target: 5, adventureName: "Tomb of the Death Riders" }
            ];
        const dailyRewardsData = [];
        // Define material tiers for easier access in rewards
        const tier1Mats = ["Leather", "Wood", "Clover", "Fabric"];
        const tier2Mats = ["Iron", "Gizmo Tail", "Stone"];
        const tier3Mats = ["Obsidian", "Bitcoin", "Flame Essence"]; // Bitcoin is rare, use sparingly or replace
        const tier4Mats = ["Bone", "Essence of Death", "Rider's Sigil", "Ancient Tablet Fragment", "Shadowgem"];

        for (let day = 1; day <= 30; day++) {
            let pvReward = 75 + (day * 10); // Increased base PV and scaling
            let rewardsArray = [`${pvReward} PV`];
            let materialQuantity = Math.ceil(day / 5); // More materials as days go on

            // Add materials based on the day
            if (day <= 7) { // First week - Tier 1
                rewardsArray.push(`${materialQuantity} ${tier1Mats[day % tier1Mats.length]}`);
                if (day % 3 === 0) rewardsArray.push(`${materialQuantity} ${tier1Mats[(day + 1) % tier1Mats.length]}`);
            } else if (day <= 14) { // Second week - Tier 1 & 2
                rewardsArray.push(`${materialQuantity} ${tier1Mats[day % tier1Mats.length]}`);
                rewardsArray.push(`${Math.max(1, materialQuantity -1)} ${tier2Mats[day % tier2Mats.length]}`);
            } else if (day <= 21) { // Third week - Tier 2 & 3
                rewardsArray.push(`${materialQuantity} ${tier2Mats[day % tier2Mats.length]}`);
                if (day % 3 === 0 && tier3Mats.length > 0) rewardsArray.push(`${Math.max(1, materialQuantity - 2)} ${tier3Mats[day % tier3Mats.length]}`);
                if (day === 21) rewardsArray.push("1 Gold");
            } else if (day < 30) { // Fourth week - Tier 3 & 4
                rewardsArray.push(`${materialQuantity} ${tier3Mats[day % tier3Mats.length]}`);
                if (tier4Mats.length > 0) rewardsArray.push(`${Math.max(1, materialQuantity - 2)} ${tier4Mats[day % tier4Mats.length]}`);
            }

            // Special milestone rewards
            if (day === 7) rewardsArray.push("10 Gold");
            if (day === 14) rewardsArray.push("1 Diamond");
            if (day === 21) rewardsArray.push("25 Gold"); // Already added 1 Gold, this makes it 26
            if (day === 28) rewardsArray.push("2 Diamonds");
            if (day === 30) { // Grand prize for Day 30
                rewardsArray = [`${500 + day * 10} PV`, "50 Gold", "5 Diamonds"];
                if (tier4Mats.length > 0) rewardsArray.push(`5 ${tier4Mats[0]}`); // Example: 5 of the first T4 mat
                if (tier4Mats.length > 1) rewardsArray.push(`3 ${tier4Mats[1]}`); // Example: 3 of the second T4 mat
            }

            dailyRewardsData.push({ day: day, reward: rewardsArray.join(', ') });
        }
        const dungeonsData = [
    { 
        id: "dungeon_1", name: "Death Rider's Crypt Lvl 1", 
        description: "A solo challenge in a crypt.", 
        durationHours: 1, // CHANGED
        requiredAdventureId: "4",
        attackRequirement: 10,
        defenseRequirement: 10,
        type: "solo",
        maxEntriesPerDay: 2,
        drops: [
            { id: "dungeon_helmet", chance: 0.10, qty: 1, type: "equipment" },
            { id: "dungeon_boots", chance: 0.10, qty: 1, type: "equipment" }
        ],
        placeholderReward: "100 PV, 2 Gold"
    },
    { 
        id: "dungeon_2", name: "Death Rider's Crypt Lvl 2", 
        description: "A party challenge with NPCs.", 
        durationHours: 2, // CHANGED
        requiredAdventureId: "4",
        attackRequirement: 30, 
        defenseRequirement: 30,
        type: "party_npc", 
        maxPartySize: 3,
        maxEntriesPerDay: 1,
        drops: [
            { id: "dungeon_sword", chance: 0.06, qty: 1, type: "equipment" },
            { id: "dungeon_armour", chance: 0.08, qty: 1, type: "equipment" },
            { id: "pizza_pendant", chance: 0.05, qty: 1, type: "equipment" },
            { id: "orb_of_haste", chance: 0.095, qty: 1, type: "equipment" },
            { id: "pet_dog", chance: 0.10, qty: 1, type: "equipment" }
        ],
        placeholderReward: "250 PV, 5 Gold, 1 Diamond"
    },
    {
        id: "dungeon_3", name: "ATH City",
        description: "The fabled city of All-Time Highs. A true party challenge.",
        durationHours: 4, // CHANGED
        requiredAdventureId: "5",
        attackRequirement: 80,
        defenseRequirement: 80,
        type: "party_npc",
        maxPartySize: 6,
        maxEntriesPerDay: 1,
        drops: [
     { name: "Void Crystal", chance: 0.08, qty: 1 },
     { name: "ATH Ash", chance: 0.08, qty: 1 },
     { name: "Fire Ink", chance: 0.03, qty: 1 },
     { name: "Zeus's Tear", chance: 0.03, qty: 1 },
     { name: "Indian Street Food", chance: 0.03, qty: 1 },
     { id: "void_compass", chance: 0.01, qty: 1, type: "equipment" },   // ADDED
     { id: "ath_talisman", chance: 0.01, qty: 1, type: "equipment" },   // ADDED
     { id: "pet_bat", chance: 0.005, qty: 1, type: "equipment" }
],
        placeholderReward: "5000 PV, 10 Gold, 2 Diamonds",
        isLockedContent: false
    }
];
const npcData = [
    { id: "npc1", name: "NPC 1", attack: 4, defense: 5, imageUrl: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/PVA%20Dungeon%20Crawlers%20%230014.png" },
    { id: "npc2", name: "NPC 2", attack: 4, defense: 6, imageUrl: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/PVA%20Dungeon%20Crawlers%20%230328.png" },
    { id: "npc3", name: "NPC 3", attack: 12, defense: 6, imageUrl: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/PVA%20Dungeon%20Crawlers%20%230757.png" },
    { id: "npc4", name: "NPC 4", attack: 4, defense: 16, imageUrl: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/PVA%20Dungeon%20Crawlers%20%231656.png" },
    { id: "npc5", name: "NPC 5", attack: 20, defense: 20, imageUrl: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/bf3.png" },
    { id: "npc6", name: "NPC 6", attack: 15, defense: 15, imageUrl: "https://raw.githubusercontent.com/nvoiy/pvadventures/refs/heads/main/PVA%20Dungeon%20Crawlers%20%230037.png" }
];         
const adventureProgressionConfig = [ { id: "1", blockId: "adventure-1-block", unlockQuestId: null, unlockMessage: "" }, { id: "2", blockId: "adventure-2-block", unlockQuestId: 1, unlockMessage: "Complete 'Spirit Forest' 5 times to unlock." }, { id: "3", blockId: "adventure-3-block", unlockQuestId: 2, unlockMessage: "Complete 'Mountain of the Marowan' 5 times to unlock." }, { id: "4", blockId: "adventure-4-block", unlockQuestId: 3, unlockMessage: "Complete 'Fire Fields of Flyinals' 5 times to unlock." },{ id: "5", blockId: "adventure-5-block", unlockQuestId: 15, unlockMessage: "Complete 'Tomb of the Death Riders' 5 times to unlock." } ];
            const upgradeChances = [1, 0.85, 0.50, 0.35, 0.13]; // For +0->+1, +1->+2, ..., +4->+5
            const dungeonSetItemIds = ["dungeon_helmet", "dungeon_boots", "dungeon_sword", "dungeon_armour"];


            // --- Perk Scaling Function ---
            function getScaledItemPerk(itemMaster, itemLevel) {
    if (!itemMaster || !itemMaster.perk || itemLevel === undefined) {
        return itemMaster ? itemMaster.perk : null;
    }
    if (itemLevel === 0) { return itemMaster.perk; }

    const scaleFactors = [1.00, 1.25, 1.35, 1.45, 1.60, 1.80];
    const scaleFactor = scaleFactors[itemLevel] || 1.00;

    const scaledPerk = JSON.parse(JSON.stringify(itemMaster.perk));

    switch (scaledPerk.type) {
        case "timeReduction":
        case "attackBoost":
        case "defenseBoost":
            scaledPerk.value = Math.round(itemMaster.perk.value * scaleFactor);
            break;
        case "pvBonus":
        case "goldChanceIncrease":
        case "timeReductionPercent":
        case "materialChanceMultiplier":
             scaledPerk.value = parseFloat((itemMaster.perk.value * scaleFactor).toFixed(4));
            break;
        case "statBoost":
            if (scaledPerk.attack !== undefined) scaledPerk.attack = Math.round(itemMaster.perk.attack * scaleFactor);
            if (scaledPerk.defense !== undefined) scaledPerk.defense = Math.round(itemMaster.perk.defense * scaleFactor);
            break;
        case "statAndDungeonTime":
            if (scaledPerk.attack !== undefined) scaledPerk.attack = Math.round(itemMaster.perk.attack * scaleFactor);
            if (scaledPerk.timeReduction !== undefined) scaledPerk.timeReduction = parseFloat((itemMaster.perk.timeReduction * scaleFactor).toFixed(4));
            break;
        case "timeReductionHybrid":
            if (scaledPerk.flat !== undefined) scaledPerk.flat = Math.round(itemMaster.perk.flat * scaleFactor);
            if (scaledPerk.percent !== undefined) scaledPerk.percent = parseFloat((itemMaster.perk.percent * scaleFactor).toFixed(4));
            break;
        case "statAndCurrencyBoost":
            if (scaledPerk.defense !== undefined) scaledPerk.defense = Math.round(itemMaster.perk.defense * scaleFactor);
            if (scaledPerk.goldBonus !== undefined) scaledPerk.goldBonus = parseFloat((itemMaster.perk.goldBonus * scaleFactor).toFixed(4));
            if (scaledPerk.diamondBonus !== undefined) scaledPerk.diamondBonus = parseFloat((itemMaster.perk.diamondBonus * scaleFactor).toFixed(4));
            break;
        
        // --- THIS IS THE NEW FIX ---
        case "statAndEntryBoost": 
        case "statAndDungeonPVBoost":
            if (scaledPerk.attack !== undefined) scaledPerk.attack = Math.round(itemMaster.perk.attack * scaleFactor);
            if (scaledPerk.defense !== undefined) scaledPerk.defense = Math.round(itemMaster.perk.defense * scaleFactor);
            // Dungeon entry and PV multiplier perks do not scale with level
            break;
        // --- END OF THE FIX ---

        case "dungeonEntryBonus":
        case "dungeonMaterialFetch":
        case "dungeonDropEcho":
        case "crawlerSlotBonus":
            // These perks do not scale with level by default
            break;
        default:
            break;
    }
    return scaledPerk;
}


            // --- Tooltip Functions ---
            function showItemTooltip(event, itemData, isCraftable = false) {
    if (!itemTooltipElement || !itemData) return;

    const currentItemLevel = itemData.level || 0;
    const baseItemMaster = craftableItemsData.find(ci => ci.id === itemData.id) || shopItemsData.find(si => si.id === itemData.id) || itemData;

    let contentHtml = `<h5>${itemData.name} <small>(${itemData.type || 'Item'})</small></h5>`;
    contentHtml += `<p>${itemData.description || 'No description.'}</p>`;

    if (baseItemMaster.perk) {
        const scaledPerk = getScaledItemPerk(baseItemMaster, currentItemLevel);
        const basePerk = baseItemMaster.perk; // Get the original, unscaled perk
        
        let perkDetails = [];

        // This function now systematically checks for all possible effects and shows base values
        const addPerkDetail = (name, baseValue, scaledValue, unit = '', isTime = false) => {
            let baseText = "";
            // Only show base value if the item is upgraded and the value has changed
            if (currentItemLevel > 0 && scaledValue !== baseValue) {
                if (isTime) {
                    baseText = ` (Base: ${Math.round(baseValue / 60)} min)`;
                } else if (unit === '%') {
                    baseText = ` (Base: ${(baseValue * 100).toFixed(1)}${unit})`;
                } else {
                    baseText = ` (Base: ${baseValue}${unit})`;
                }
            }
            if (isTime) {
                perkDetails.push(`${name}: -${Math.round(scaledValue / 60)} min${baseText}`);
            } else if (unit === '%') {
                 perkDetails.push(`${name}: +${(scaledValue * 100).toFixed(1)}${unit}${baseText}`);
            } else if (unit === 'x') {
                 perkDetails.push(`${name}: x${scaledValue.toFixed(2)}${baseText}`);
            } else {
                perkDetails.push(`${name}: ${scaledValue > 0 ? '+' : ''}${scaledValue}${unit}${baseText}`);
            }
        };
        
        if (scaledPerk.attack) addPerkDetail('Attack', basePerk.attack, scaledPerk.attack);
        if (scaledPerk.defense) addPerkDetail('Defense', basePerk.defense, scaledPerk.defense);

        if (scaledPerk.value && scaledPerk.type === 'attackBoost') addPerkDetail('Attack', basePerk.value, scaledPerk.value);
        if (scaledPerk.value && scaledPerk.type === 'defenseBoost') addPerkDetail('Defense', basePerk.value, scaledPerk.value);

        if (scaledPerk.pvBonus) addPerkDetail('PV Bonus', basePerk.pvBonus, scaledPerk.pvBonus, '%');
        if (scaledPerk.goldChanceIncrease) addPerkDetail('Gold Find Chance', basePerk.value, scaledPerk.value, '%');
        
        if (scaledPerk.goldBonus) addPerkDetail('Gold Find', basePerk.goldBonus, scaledPerk.goldBonus, '%');
        if (scaledPerk.diamondBonus) addPerkDetail('Diamond Find', basePerk.diamondBonus, scaledPerk.diamondBonus, '%');
        if (scaledPerk.pvMultiplier) perkDetails.push(`Dungeon PV x${scaledPerk.pvMultiplier}`);

        if (scaledPerk.timeReduction) addPerkDetail('Adventure Time', basePerk.value, scaledPerk.value, '', true);
        if (scaledPerk.timeReductionPercent) addPerkDetail('Adventure Time', basePerk.value, scaledPerk.value, '%');
        if (scaledPerk.flat && scaledPerk.percent) {
            perkDetails.push(`Adventure Time: -${Math.round(scaledPerk.flat / 60)} min & -${(scaledPerk.percent * 100).toFixed(0)}%`);
        }
        if (scaledPerk.statAndDungeonTime) addPerkDetail('Dungeon Time', basePerk.timeReduction, scaledPerk.timeReduction, '%');

        if (scaledPerk.dungeon1) perkDetails.push(`Dungeon 1 Entry: +${scaledPerk.dungeon1}`);
        if (scaledPerk.dungeon2) perkDetails.push(`Dungeon 2 Entry: +${scaledPerk.dungeon2}`);
        if (scaledPerk.dungeon3) perkDetails.push(`Dungeon 3 Entry: +${scaledPerk.dungeon3}`);
        
        if (scaledPerk.materialChanceMultiplier) addPerkDetail('Material Find', basePerk.value, scaledPerk.value, 'x');
        if (scaledPerk.dungeonMaterialFetch) perkDetails.push(`Dungeon Material Fetch: +${scaledPerk.count}`);
        if (scaledPerk.dungeonDropEcho) perkDetails.push(`Dungeon Drop Echo: ${scaledPerk.chance * 100}%`);
        
        if (perkDetails.length > 0) {
            contentHtml += `<p class="perk-info">Perk: ${perkDetails.join(', ')}</p>`;
        }
    }
    
    if (itemData.level > 0) contentHtml += `<p>Level: +${itemData.level}</p>`;
    if (itemData.tier !== undefined) contentHtml += `<p><small>Base Tier: ${itemData.tier}</small></p>`;

    if (isCraftable && itemData.recipe) {
        contentHtml += `<div class="recipe-info"><strong>Requires:</strong><ul>`;
        for (const mat in itemData.recipe) {
            contentHtml += `<li>${itemData.recipe[mat]} ${mat}</li>`;
        }
        contentHtml += `</ul></div>`;
    }
    if (itemData.price) contentHtml += `<p>Price: <span class="pv">${itemData.price} PV</span></p>`;

    itemTooltipElement.innerHTML = contentHtml;
    itemTooltipElement.style.display = 'block';
    
    const rect = event.target.getBoundingClientRect();
    let x = rect.right + 10; 
    let y = rect.top;
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    const tooltipWidth = itemTooltipElement.offsetWidth;
    const tooltipHeight = itemTooltipElement.offsetHeight;
    if (x + tooltipWidth > screenWidth) x = rect.left - tooltipWidth - 10;
    if (x < 0) x = 5;
    if (y + tooltipHeight > screenHeight) y = screenHeight - tooltipHeight - 5;
    if (y < 0) y = 5;
    itemTooltipElement.style.left = x + 'px';
    itemTooltipElement.style.top = y + 'px';
}
                        let playerTooltipDataCache = {};

            async function showPlayerInventoryTooltip(event, playerId) {
                if (!itemTooltipElement || !playerId || !db) return;

                itemTooltipElement.innerHTML = '<h5>Loading inventory...</h5>';
                itemTooltipElement.style.display = 'block';
                // Position the tooltip (basic positioning, you might want to refine this like your itemTooltip)
                itemTooltipElement.style.left = (event.pageX + 15) + 'px';
                itemTooltipElement.style.top = (event.pageY + 15) + 'px';

                try {
                    let targetPlayerData;
                    if (playerTooltipDataCache[playerId]) {
                        targetPlayerData = playerTooltipDataCache[playerId];
                    } else {
                        const playerDocRef = doc(db, "playerProgress", playerId);
                        const docSnap = await getDoc(playerDocRef);
                        if (docSnap.exists()) {
                            targetPlayerData = docSnap.data();
                            playerTooltipDataCache[playerId] = targetPlayerData; // Cache it
                        } else {
                            itemTooltipElement.innerHTML = '<h5>Player data not found.</h5>';
                            return;
                        }
                    }

                    let tooltipContent = `<h5>${targetPlayerData.nickname || 'Player'}'s Equipped Items:</h5>`;
                    const playerEquipped = targetPlayerData.equippedItems || {};
                    const playerInv = targetPlayerData.playerInventory || [];
                    let hasEquippedItems = false;

                    tooltipContent += '<ul style="padding-left: 15px; margin-top: 5px;">';
                    const slotOrder = ["Armour", "Helmet", "Boots", "Amulet", "Ring1", "Ring2", "Weapon", "Pet", "Misc1", "Misc2"];
                    
                    slotOrder.forEach(slotKey => {
                        const equippedInstanceId = playerEquipped[slotKey];
                        if (equippedInstanceId) {
                            const invItem = playerInv.find(i => i.uniqueInstanceId === equippedInstanceId);
                            if (invItem) {
                                const itemMaster = craftableItemsData.find(master => master.id === invItem.id);
                                if (itemMaster) {
                                    const levelText = (invItem.level || 0) > 0 ? ` (+${invItem.level})` : '';
                                    tooltipContent += `<li>${slotKey}: ${itemMaster.name}${levelText}</li>`;
                                    hasEquippedItems = true;
                                }
                            }
                        }
                    });

                    if (!hasEquippedItems) {
                        tooltipContent += '<li>No items equipped.</li>';
                    }
                    tooltipContent += '</ul>';

                    itemTooltipElement.innerHTML = tooltipContent;

                    // Re-adjust position after content is set, as size might change
                    const rect = event.target.getBoundingClientRect(); // event.target is the <li>
                    let x = rect.right + 10; 
                    let y = rect.top;
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;
                    const tooltipWidth = itemTooltipElement.offsetWidth;
                    const tooltipHeight = itemTooltipElement.offsetHeight;

                    if (x + tooltipWidth > screenWidth - 10) x = rect.left - tooltipWidth - 10;
                    if (x < 5) x = 5;
                    if (y + tooltipHeight > screenHeight - 10) y = screenHeight - tooltipHeight - 10;
                    if (y < 5) y = 5;
                    
                    itemTooltipElement.style.left = x + 'px';
                    itemTooltipElement.style.top = y + 'px';

                } catch (error) {
                    console.error("Error fetching player inventory for tooltip:", error);
                    itemTooltipElement.innerHTML = '<h5>Error loading data.</h5>';
                }
            }
            function hideItemTooltip() {
                if (itemTooltipElement) itemTooltipElement.style.display = 'none';
            }


function processPopupQueue() {
    if (isPopupCurrentlyVisible || popupMessageQueue.length === 0) { return; }

    // welcomeScreen related logic has been removed as the welcome screen itself is gone.
    const { message, title, craftCallback, confirmCallback, secondaryActionCallback, secondaryActionText, confirmText, cancelText } = popupMessageQueue.shift();

    isPopupCurrentlyVisible = true;
    if (customPopupTitleEl) customPopupTitleEl.textContent = title;
    if (customPopupMessageEl) customPopupMessageEl.innerHTML = message;

    // Hide all buttons initially and remove previous dynamic ones
    customPopupCloseBtn.classList.add('hidden');
    customPopupConfirmBtn.classList.add('hidden');
    customPopupCancelBtn.classList.add('hidden');
    const existingCraftBtn = document.getElementById('popupCraftAgainBtn');
    if (existingCraftBtn) existingCraftBtn.remove();
    const existingSecondaryBtn = document.getElementById('popupSecondaryActionBtn');
    if (existingSecondaryBtn) existingSecondaryBtn.remove();


    currentPopupConfirmCallback = null;
    currentPopupCraftCallback = null;
    let currentPopupSecondaryActionCallback = null; 

    if (craftCallback) {
        currentPopupCraftCallback = craftCallback;
        const craftAgainBtn = document.createElement('button');
        craftAgainBtn.id = 'popupCraftAgainBtn';
        craftAgainBtn.className = 'action-button';
        craftAgainBtn.textContent = 'Craft Again'; 
        craftAgainBtn.style.backgroundColor = 'var(--highlight-color-connected)';
        craftAgainBtn.style.color = 'white';
        customPopupButtonsEl.insertBefore(craftAgainBtn, customPopupCloseBtn);
        customPopupCloseBtn.textContent = cancelText || "No Thanks";
        customPopupCloseBtn.classList.remove('hidden');
    } else if (confirmCallback) { 
        currentPopupConfirmCallback = confirmCallback;
        customPopupConfirmBtn.textContent = confirmText || "Confirm";
        customPopupConfirmBtn.classList.remove('hidden');

        if (secondaryActionCallback && secondaryActionText) {
            currentPopupSecondaryActionCallback = secondaryActionCallback;
            const secondaryBtn = document.createElement('button');
            secondaryBtn.id = 'popupSecondaryActionBtn';
            secondaryBtn.className = 'action-button'; 
            secondaryBtn.textContent = secondaryActionText;
            secondaryBtn.addEventListener('click', () => {
                if (currentPopupSecondaryActionCallback) {
                    currentPopupSecondaryActionCallback();
                }
                hideCustomPopup();
            }, { once: true }); 
            customPopupButtonsEl.insertBefore(secondaryBtn, customPopupCancelBtn.nextSibling); 

            if (cancelText) {
                customPopupCancelBtn.textContent = cancelText;
                customPopupCancelBtn.classList.remove('hidden');
            } else {
                customPopupCancelBtn.classList.add('hidden'); 
            }

        } else { 
            customPopupCancelBtn.textContent = cancelText || "Cancel";
            customPopupCancelBtn.classList.remove('hidden');
        }
    } else { 
        customPopupCloseBtn.textContent = confirmText || "OK"; 
        customPopupCloseBtn.classList.remove('hidden');
    }

    if (customPopupOverlay) customPopupOverlay.classList.remove('hidden');
    if (customPopup) customPopup.classList.remove('hidden');

    // Focus logic
    if (customPopupConfirmBtn && !customPopupConfirmBtn.classList.contains('hidden')) {
        customPopupConfirmBtn.focus();
    } else if (document.getElementById('popupCraftAgainBtn')) {
        document.getElementById('popupCraftAgainBtn').focus();
    } else if (document.getElementById('popupSecondaryActionBtn')) {
         document.getElementById('popupSecondaryActionBtn').focus();
    } else if (customPopupCloseBtn && !customPopupCloseBtn.classList.contains('hidden')) {
        customPopupCloseBtn.focus();
    }
}
function showCustomPopup(message, title = "Notification", options = {}) {
    const { craftCallback = null, confirmCallback = null, secondaryActionCallback = null, secondaryActionText = null, confirmText = null, cancelText = null } = options;
    popupMessageQueue.push({ message, title, craftCallback, confirmCallback, secondaryActionCallback, secondaryActionText, confirmText, cancelText });
    processPopupQueue();
}
            function hideCustomPopup() { 
                if (customPopupOverlay) customPopupOverlay.classList.add('hidden'); 
                if (customPopup) customPopup.classList.add('hidden'); 
                isPopupCurrentlyVisible = false; 
                currentPopupCraftCallback = null;
                currentPopupConfirmCallback = null;
                
                const existingCraftBtn = document.getElementById('popupCraftAgainBtn');
                if (existingCraftBtn) existingCraftBtn.remove();

            customPopupConfirmBtn.classList.add('hidden');
            customPopupCancelBtn.classList.add('hidden');
            customPopupCloseBtn.classList.remove('hidden'); // Ensure OK button is visible by default
            customPopupCloseBtn.textContent = "OK"; // Reset OK button text

            processPopupQueue(); 
            }

            if (customPopupCloseBtn) {
                customPopupCloseBtn.addEventListener('click', () => {
                    // If it's acting as "No Thanks" for a craft prompt, the craft callback shouldn't fire.
                    // If it's "OK" for a simple message, no callback is expected.
                    // If it was accidentally shown for a confirm prompt (which it shouldn't be with the new logic),
                    // treat it as a cancel if a confirm callback was somehow active.
                    if (currentPopupConfirmCallback && customPopupCloseBtn.textContent !== "OK") {
                         currentPopupConfirmCallback(false); // Treat "No Thanks" as cancel
                    }
                    hideCustomPopup();
                });
            }

            if (customPopupConfirmBtn) {
                customPopupConfirmBtn.addEventListener('click', () => {
                    if (currentPopupConfirmCallback) {
                        currentPopupConfirmCallback(true); // User confirmed
                    }
                    hideCustomPopup();
                });
            }

            if (customPopupCancelBtn) {
                customPopupCancelBtn.addEventListener('click', () => {
                    if (currentPopupConfirmCallback) {
                        currentPopupConfirmCallback(false); // User canceled
                    }
                    hideCustomPopup();
                });
            }
            
            // Listener for dynamically created "Craft Again" button
            // We need to use event delegation since the button is added/removed.
            if (customPopupButtonsEl) {
                customPopupButtonsEl.addEventListener('click', (event) => {
                    if (event.target.id === 'popupCraftAgainBtn') {
                        if (currentPopupCraftCallback) {
                            currentPopupCraftCallback();
                        }
                        hideCustomPopup();
                    }
                });
            }


            if (customPopupOverlay) {
                 customPopupOverlay.addEventListener('click', (event) => {
                    if (event.target === customPopupOverlay) {
                        // If a confirm prompt is open, clicking overlay should be like cancel
                        if (currentPopupConfirmCallback && !customPopupConfirmBtn.classList.contains('hidden')) {
                            currentPopupConfirmCallback(false);
                        }
                        hideCustomPopup();
                    }
                });
            }

            
function resetGameStateToDefaults() {
    currentPvTokens = 0; currentGold = 0; currentDiamonds = 0;
    activeAdventures = []; nextActiveAdventureId = 0;
    // totalAvailableAdventurers will be set by recalculateTotalAvailableAdventurers
    playerInventory = []; nextUniqueInstanceId = 0;
    playerMaterials = { ...initialPlayerMaterials };
    playerScrolls = { low: 0, middle: 0, high: 0 };
    playerHasPurchasedRiderScroll = false;
    playerHasPurchasedPetWhistle = false;
    totalAdventuresCompleted = 0;
    ordinalBonusAdventurers = 0; // <<< ADDED THIS LINE
    playerHasPurchasedPvpScroll = false;

    equippedItems = { Armour: null, Helmet: null, Boots: null, Amulet: null, Ring1: null, Ring2: null, Weapon: null, Pet: null, Misc1: null, Misc2: null };
    playerAdventurerLevel = 1;
    secondRingSlotUnlocked = false;
    petSlotUnlocked = false;
    activePotions = [];
    allRaffles = [];
    playerRaffleEntries = {};
    quests.forEach(q => { q.progress = 0; q.completed = false; q.claimed = false; });
    lastDailyRewardDayClaimed = 0;
    lastDailyRewardClaimTimestamp = 0;
    selectedItemForUpgrade = null;
    selectedScrollForUpgrade = null;
    isGoldToDiamondSwap = true; updateSwapDisplay();

    activeDungeons = []; // <-- ADD THIS LINE

    if(sidebarActiveAdventuresList) sidebarActiveAdventuresList.innerHTML = '';
    if(activePotionsList) activePotionsList.innerHTML = '';
    if(materialsListContainer) materialsListContainer.innerHTML = '';
    if(inventoryItemsContainer) inventoryItemsContainer.innerHTML = '';
    if(equipmentSlotsDisplay) equipmentSlotsDisplay.innerHTML = '';
    if (whitelistRafflesContainer) whitelistRafflesContainer.innerHTML = '';
    if (dailyRewardsGrid) dailyRewardsGrid.innerHTML = '';
    if (leaderboardDisplayList) leaderboardDisplayList.innerHTML = '<li>Click a filter above to load a leaderboard.</li>';
    if (leaderboardCurrentTypeTitle) leaderboardCurrentTypeTitle.textContent = 'Leaderboard';
    if (upgradeResultDisplay) upgradeResultDisplay.textContent = '';
    if (selectedItemForUpgradeDisplay) selectedItemForUpgradeDisplay.innerHTML = 'Item: None';
    if (selectedScrollForUpgradeDisplay) selectedScrollForUpgradeDisplay.innerHTML = 'Scroll: None';
    if (upgradeSuccessRateDisplay) upgradeSuccessRateDisplay.textContent = '';
    if (document.getElementById('dungeonListContainer')) document.getElementById('dungeonListContainer').innerHTML = '';

    // +++ RESET DUNGEON STATE +++
    playerDungeonEntriesToday = { dungeon_1: 0, dungeon_2: 0 };
    lastDungeonResetTimestamp = 0;
    playerDungeonCrawlers = [];
    confirmedCrawlersForDungeons = {}; // <<< ADD THIS LINE
    dungeonCrawlerIdsLoaded = false;
    if (document.getElementById('dungeonCrawlerSelectionArea')) { // If UI exists, clear it
        document.getElementById('dungeonCrawlerSelectionArea').innerHTML = '';
        document.getElementById('dungeonCrawlerSelectionArea').style.display = 'none';
    }
    // +++ END RESET DUNGEON STATE +++

    recalculateTotalAvailableAdventurers(); // Call this to set totalAvailableAdventurers correctly after reset // Call this to set totalAvailableAdventurers correctly after reset
    updatePlayerCombatStatsDisplay();
    ordinalBonusAdventurers = 0;

}





            // --- Firebase Save/Load ---
            async function saveGameStateToFirebase(userId, gameState) {
                if (!userId) {
                    console.error("Cannot save game: User ID (wallet address) is missing.");
                    showCustomPopup("Error: User ID is missing. Cannot save progress.", "Save Error");
                    return;
                }
                if (!db) {
                    console.error("Firestore not initialized for saving state!");
                    showCustomPopup("Error: Database connection failed. Cannot save progress.", "Save Error");
                    return;
                }

                console.log(`Attempting to save game state for ${userId} directly to Firestore.`);
                try {
                    const savableGameState = { ...gameState }; // Use the gameState passed from getCurrentGameState()

                    // Convert JavaScript Dates/Timestamps to Firestore Timestamps before saving
                    if (savableGameState.activeAdventures) {
                        savableGameState.activeAdventures = savableGameState.activeAdventures.map(adv => ({
                            ...adv,
                            returnTime: typeof adv.returnTime === 'number' ? Timestamp.fromMillis(adv.returnTime) : (adv.returnTime || Timestamp.now()),
                        }));
                    }
                    if (savableGameState.activeDungeons) {
                        savableGameState.activeDungeons = savableGameState.activeDungeons.map(dun => ({
                            ...dun,
                            returnTime: typeof dun.returnTime === 'number' ? Timestamp.fromMillis(dun.returnTime) : (dun.returnTime || Timestamp.now()),
                        }));
                    }
                    if (savableGameState.activePotions) {
                        savableGameState.activePotions = savableGameState.activePotions.map(p => ({
                            ...p,
                            endTime: p.endTime ? Timestamp.fromMillis(p.endTime) : null,
                        }));
                    }
                    if (typeof savableGameState.lastDailyRewardClaimTimestamp === 'number') {
                        savableGameState.lastDailyRewardClaimTimestamp = Timestamp.fromMillis(savableGameState.lastDailyRewardClaimTimestamp);
                    }
                    if (typeof savableGameState.lastDungeonResetTimestamp === 'number') {
                        savableGameState.lastDungeonResetTimestamp = Timestamp.fromMillis(savableGameState.lastDungeonResetTimestamp);
                    }
                    // Ensure nickname is part of the saved state
                    savableGameState.nickname = userNickname || `Voyager ${userId.substring(0,4)}`;


                    const playerDocRef = doc(collection(db, 'playerProgress'), userId);
                    await setDoc(playerDocRef, savableGameState); // Using setDoc to overwrite with current state
                    console.log("Game state saved directly to Firestore for user ID:", userId);
                } catch (error) {
                    console.error("Error saving game state directly to Firestore: ", error);
                    showCustomPopup(`Failed to save game progress: ${error.message}`, "Save Error");
                }
            }

                  async function loadGameStateFromFirebase(userId) {
                if (!userId) {
                    console.error("Cannot load game: User ID (wallet address) is missing.");
                    return { status: 'error', error: new Error("User ID missing") };
                }
                if (!db) {
                    console.error("Firestore not initialized for loading state!");
                    return { status: 'error', error: new Error("Firestore not initialized") };
                }
                console.log(`Attempting to load game state for ${userId} directly from Firestore.`);
                try {
                    const playerDocRef = doc(collection(db, 'playerProgress'), userId);
                    const docSnap = await getDoc(playerDocRef);

                    if (docSnap.exists()) {
                        const loadedData = docSnap.data();
                        console.log("Raw loaded data from Firebase for UID", userId, JSON.parse(JSON.stringify(loadedData)));

                        // Convert Firestore Timestamps back to JS milliseconds
                        if (loadedData.activeAdventures) {
                            loadedData.activeAdventures = loadedData.activeAdventures.map(adv => ({
                                ...adv,
                                returnTime: adv.returnTime && typeof adv.returnTime.toMillis === 'function' ? adv.returnTime.toMillis() : (typeof adv.returnTime === 'number' ? adv.returnTime : Date.now()),
                            }));
                        }
                        if (loadedData.activeDungeons) {
                            loadedData.activeDungeons = loadedData.activeDungeons.map(dun => ({
                                ...dun,
                                returnTime: dun.returnTime && typeof dun.returnTime.toMillis === 'function' ? dun.returnTime.toMillis() : (typeof dun.returnTime === 'number' ? dun.returnTime : Date.now()),
                            }));
                        }
                        if (loadedData.activePotions) {
                            loadedData.activePotions = loadedData.activePotions.map(p => ({
                                ...p,
                                endTime: p.endTime && typeof p.endTime.toMillis === 'function' ? p.endTime.toMillis() : (typeof p.endTime === 'number' ? p.endTime : null),
                            }));
                        }
                        if (loadedData.lastDailyRewardClaimTimestamp && typeof loadedData.lastDailyRewardClaimTimestamp.toMillis === 'function') {
                            loadedData.lastDailyRewardClaimTimestamp = loadedData.lastDailyRewardClaimTimestamp.toMillis();
                        }
                        if (loadedData.lastDungeonResetTimestamp && typeof loadedData.lastDungeonResetTimestamp.toMillis === 'function') {
                            loadedData.lastDungeonResetTimestamp = loadedData.lastDungeonResetTimestamp.toMillis();
                        }

                        console.log("Processed loaded data before apply:", JSON.parse(JSON.stringify(loadedData)));
                        return { status: 'success', data: loadedData };
                    } else {
                        console.log("No saved game state found directly in Firestore for UID", userId);
                        return { status: 'not_found' };
                    }
                } catch (error) {
                    console.error("Error directly within loadGameStateFromFirebase (direct Firestore):", error);
                    // Don't show a popup here, let the caller (handleWalletConnected) decide
                    return { status: 'error', error: error };
                }
            }
            
            
            
            async function createInitialGameState(userId) { // Removed nicknameToUse from parameters
                const generatedNickname = userId.slice(-5).toUpperCase(); // Get last 5 chars, make uppercase
                userNickname = `Voyager-${generatedNickname}`; // Set the global userNickname

                console.log("Creating initial game state for new user (client-side):", userId, "Generated Nickname:", userNickname);
                if (playerNicknameDisplay) playerNicknameDisplay.textContent = userNickname;

                const initialBonus = ordinalBonusAdventurers || 0;

                const initialGameState = {
                    nickname: userNickname, // Use the newly generated nickname
                    pvTokens: 0, gold: 0, diamonds: 0,
                    activeAdventures: [], activeDungeons: [], confirmedCrawlersForDungeons: {},
                    playerInventory: [], nextUniqueInstanceId: 0,
                    playerMaterials: { ...initialPlayerMaterials },
                    playerScrolls: { low: 0, middle: 0, high: 0 },
                    playerHasPurchasedRiderScroll: false, playerHasPurchasedPetWhistle: false,
                    totalAdventuresCompleted: 0,
                    equippedItems: { Armour: null, Helmet: null, Boots: null, Amulet: null, Ring1: null, Ring2: null, Weapon: null, Pet: null, Misc1: null, Misc2: null },
                    quests: quests.map(q => ({ ...q, progress: 0, completed: false, claimed: false })),
                    activePotions: [], playerAdventurerLevel: 1,
                    secondRingSlotUnlocked: false, petSlotUnlocked: false,
                    playerRaffleEntries: {},
                    lastDailyRewardDayClaimed: 0, lastDailyRewardClaimTimestamp: 0,
                    ordinalBonusAdventurers: initialBonus,
                    playerDungeonEntriesToday: { dungeon_1: 0, dungeon_2: 0 },
                    lastDungeonResetTimestamp: 0,
                    playerDungeonCrawlers: [],
                    dungeonCrawlerIdsLoaded: dungeonCrawlerIdsLoaded
                };

                applyLoadedGameState(initialGameState);
                await saveGameStateToFirebase(userId, initialGameState);

                checkAndResetDailyDungeonEntries();
                // No need for a generic "Welcome" popup here, as applyLoadedGameState will handle UI.
                // The promptAndSetNickname can be removed from handleWalletConnected if this auto-generation is sufficient.
                // Or, keep promptAndSetNickname to allow them to immediately change it.
                // For now, let's assume this auto-generated name is the starting point.
                showCustomPopup(`Welcome, ${userNickname}! Your voyage begins!`, "New Account Created");
            }
            
function getCurrentGameState() {
    return {
        nickname: userNickname || "Voyager",
        pvTokens: currentPvTokens || 0,
        gold: currentGold || 0,
        diamonds: currentDiamonds || 0,
        activeAdventures: Array.isArray(activeAdventures) ? activeAdventures.map(adv => ({ id: adv.id, originalAdventureId: adv.originalAdventureId, name: adv.name || "Unknown Adventure", adventurers: adv.adventurers || 0, returnTime: adv.returnTime || Date.now(), pvReward: adv.pvReward || 0, goldChance: adv.goldChance || 0, diamondChance: adv.diamondChance || 0 })) : [],
        activeDungeons: Array.isArray(activeDungeons) ? activeDungeons.map(dun => ({ 
            id: dun.id, 
            dungeonId: dun.dungeonId, 
            name: dun.name || "Unknown Dungeon", 
            adventurers: dun.adventurers || 0, 
            returnTime: dun.returnTime || Date.now(),
            npcCrawlers: Array.isArray(dun.npcCrawlers) ? dun.npcCrawlers : [] // Save selected NPC crawlers
        })) : [],
        confirmedCrawlersForDungeons: confirmedCrawlersForDungeons || {}, // <<< ADD THIS LINE
        playerInventory: Array.isArray(playerInventory) ? playerInventory : [],
        nextUniqueInstanceId: nextUniqueInstanceId,
        playerMaterials: playerMaterials || { ...initialPlayerMaterials },
        playerScrolls: playerScrolls || { low: 0, middle: 0, high: 0 },
        playerHasPurchasedRiderScroll: playerHasPurchasedRiderScroll || false,
        playerHasPurchasedPvpScroll: playerHasPurchasedPvpScroll || false,
        totalAdventuresCompleted: totalAdventuresCompleted || 0,
        equippedItems: equippedItems || { Armour: null, Helmet: null, Boots: null, Amulet: null, Ring1: null, Ring2: null, Weapon: null, Pet: null, Misc1: null, Misc2: null },
        quests: Array.isArray(quests) ? quests.map(q => ({ id: q.id, text: q.text || "UKN", reward: q.reward || "0", completed: q.completed || false, progress: q.progress || 0, target: q.target || 0, adventureName: q.adventureName || null, metric: q.metric || null, claimed: q.claimed || false })) : [],
        activePotions: Array.isArray(activePotions) ? activePotions.map(p => ({ id: p.id, endTime: p.endTime || null, adventuresLeft: p.adventuresLeft !== undefined ? p.adventuresLeft : null, upgradesLeft: p.upgradesLeft !== undefined ? p.upgradesLeft : null })).filter(p => p.id) : [],        playerAdventurerLevel: playerAdventurerLevel || 1,
        secondRingSlotUnlocked: secondRingSlotUnlocked || false,
        petSlotUnlocked: petSlotUnlocked || false,
        playerHasPurchasedPetWhistle: playerHasPurchasedPetWhistle || false,
        playerRaffleEntries: playerRaffleEntries || {},
        lastDailyRewardDayClaimed: lastDailyRewardDayClaimed,
        lastDailyRewardClaimTimestamp: lastDailyRewardClaimTimestamp,
        ordinalBonusAdventurers: ordinalBonusAdventurers, // <<< ADD THIS LINE
        playerDungeonEntriesToday: playerDungeonEntriesToday || { dungeon_1: 0, dungeon_2: 0 },
        lastDungeonResetTimestamp: lastDungeonResetTimestamp || 0,
        playerDungeonCrawlers: Array.isArray(playerDungeonCrawlers) ? playerDungeonCrawlers : [],
        dungeonCrawlerIdsLoaded: dungeonCrawlerIdsLoaded || false // Though this is usually determined on client start
        // +++ END OF ADDED FOR DUNGEONS +++
    };
}

function applyLoadedGameState(loadedState) {
    console.log("Applying loaded game state:", JSON.parse(JSON.stringify(loadedState)));
    walletVerificationPendingForBonus = false; // Reset flag at the start of applying state
    
    if (currentUser && ADMIN_WALLET_ADDRESSES.includes(currentUser.uid.toLowerCase())) {
        MAX_PLAYER_ADVENTURERS = 15;
        console.log(`Admin wallet detected. Base adventurers set to ${MAX_PLAYER_ADVENTURERS}.`);
    } else {
        MAX_PLAYER_ADVENTURERS = 1;
    }

    if (!loadedState) {
        console.error("applyLoadedGameState called with null or undefined state.");
        showCustomPopup("No game data found to load. Starting fresh or try logging in again.", "Load Error");
        ordinalBonusAdventurers = 0; // Ensure it's reset if no state
        recalculateTotalAvailableAdventurers();
        return;
    }
    try {
        userNickname = loadedState.nickname || "Voyager";
        if (playerNicknameDisplay && userNickname) playerNicknameDisplay.textContent = userNickname;
        currentPvTokens = loadedState.pvTokens || 0;
        currentGold = loadedState.gold || 0;
        currentDiamonds = loadedState.diamonds || 0;

        const isWalletCurrentlyConnected = connectWalletBtn && connectWalletBtn.classList.contains('connected');

        // Wallet Bonus Handling
        if (loadedState.ordinalBonusAdventurers !== undefined && loadedState.ordinalBonusAdventurers > 0 && !isWalletCurrentlyConnected) {
            ordinalBonusAdventurers = loadedState.ordinalBonusAdventurers; // Temporarily use saved bonus
            walletVerificationPendingForBonus = true; // Set the flag for adventure sending check

            // Initial informational popup when game loads with a remembered bonus but no active wallet
            showCustomPopup(
                `Your game remembers an Ordinal Bonus of +${ordinalBonusAdventurers} adventurers from a previous session.<br><br>To ensure this bonus is current and to use it, please connect your wallet. If you attempt an adventure before connecting, you'll be prompted again.`,
                "Wallet Bonus Information",
                { // This popup is just informational, so a simple "OK" is fine.
                  // processPopupQueue will default to showing customPopupCloseBtn with "OK"
                }
            );
            // No need to set button text here, processPopupQueue default is fine.

        } else if (isWalletCurrentlyConnected) {
            // Wallet is already connected. The bonus should be determined by fetchWalletInscriptions,
            // which is called from updateWalletDisplay. We should not overwrite
            // ordinalBonusAdventurers here if fetchWalletInscriptions might have already set it.
            walletVerificationPendingForBonus = false; // Ensure this is false if wallet is connected.
            console.log("applyLoadedGameState: Wallet is connected. ordinalBonusAdventurers will be determined by fetchWalletInscriptions. Current value before potential overwrite by loadedState (if any):", ordinalBonusAdventurers);
            // REMOVED THE LINE: ordinalBonusAdventurers = 0;
        } else {
            // No saved bonus, or saved bonus was 0, and wallet not connected.
            ordinalBonusAdventurers = 0;
            walletVerificationPendingForBonus = false;
        }


        activeAdventures = Array.isArray(loadedState.activeAdventures) ? loadedState.activeAdventures.map(advData => {
            return {
                id: advData.id || nextActiveAdventureId++,
                originalAdventureId: advData.originalAdventureId || "1",
                name: advData.name || "Unknown Adventure",
                adventurers: advData.adventurers || 0,
                returnTime: typeof advData.returnTime === 'number' ? advData.returnTime : Date.now(),
                pvReward: advData.pvReward || 0,
                goldChance: advData.goldChance || 0,
                diamondChance: advData.diamondChance || 0
            };
        }) : [];
        // Recalculate nextActiveAdventureId based on both adventures and dungeons now
        let maxActiveId = activeAdventures.length > 0 ? Math.max(0, ...activeAdventures.map(a => a.id)) : 0;
        // nextActiveAdventureId = maxActiveId + 1; // This will be set later after processing dungeons too

        activeDungeons = Array.isArray(loadedState.activeDungeons) ? loadedState.activeDungeons.map(dunData => { // <-- ADD THIS BLOCK
             return {
                 id: dunData.id || nextActiveAdventureId++, // Use the same counter for unique instance IDs
                 dungeonId: dunData.dungeonId || "unknown_dungeon",
                 name: dunData.name || "Unknown Dungeon",
                 adventurers: dunData.adventurers || 0,
                 returnTime: typeof dunData.returnTime === 'number' ? dunData.returnTime : Date.now()
             };
         }) : [];
         nextActiveAdventureId = Math.max(maxActiveId, activeDungeons.length > 0 ? Math.max(0, ...activeDungeons.map(d => d.id)) : 0) + 1; // <-- Update counter after both lists


        totalAdventuresCompleted = loadedState.totalAdventuresCompleted || 0;
        nextUniqueInstanceId = loadedState.nextUniqueInstanceId || 0;
        playerInventory = [];
        if (Array.isArray(loadedState.playerInventory)) {
            loadedState.playerInventory.forEach(itemSource => {
                if (!itemSource) return;
                if (itemSource.id === "scroll_low" || itemSource.id === "scroll_mid" || itemSource.id === "scroll_high" || (itemSource.type && itemSource.type === "upgrade_scroll")) {
                    return;
                }
                let newItem = {};
                if (typeof itemSource === 'string') {
                    newItem = {
                        id: itemSource,
                        level: 0,
                        uniqueInstanceId: `legacy_${nextUniqueInstanceId++}`
                    };
                } else {
                    newItem = {
                        id: itemSource.id,
                        level: itemSource.level || 0,
                        uniqueInstanceId: itemSource.uniqueInstanceId || `loaded_${nextUniqueInstanceId++}`
                    };
                }
                if (newItem.id) {
                    playerInventory.push(newItem);
                } else {
                    console.warn("Loaded inventory item source without an ID:", itemSource);
                }
            });
        }
        playerMaterials = loadedState.playerMaterials || { ...initialPlayerMaterials };
        playerScrolls = loadedState.playerScrolls || { low: 0, middle: 0, high: 0 };
        playerHasPurchasedRiderScroll = loadedState.playerHasPurchasedRiderScroll || false;
        playerHasPurchasedPetWhistle = loadedState.playerHasPurchasedPetWhistle || false;
        playerHasPurchasedPvpScroll = loadedState.playerHasPurchasedPvpScroll || false;
        // ordinalBonusAdventurers is handled above based on wallet connection state


        const defaultEquippedStructure = { Armour: null, Helmet: null, Boots: null, Amulet: null, Ring1: null, Ring2: null, Weapon: null, Pet: null, Misc1: null, Misc2: null };
        if (loadedState.equippedItems && typeof loadedState.equippedItems === 'object') {
            equippedItems = { ...defaultEquippedStructure, ...loadedState.equippedItems };
        } else {
            equippedItems = { ...defaultEquippedStructure };
        }
        playerAdventurerLevel = loadedState.playerAdventurerLevel || 1;
        secondRingSlotUnlocked = loadedState.secondRingSlotUnlocked || false;
        petSlotUnlocked = loadedState.petSlotUnlocked || false;
        playerRaffleEntries = loadedState.playerRaffleEntries || {};
        lastDailyRewardDayClaimed = loadedState.lastDailyRewardDayClaimed || 0;
        lastDailyRewardClaimTimestamp = loadedState.lastDailyRewardClaimTimestamp || 0;

        if (Array.isArray(loadedState.quests)) {
            quests.forEach(q_default => {
                const loaded_q = loadedState.quests.find(lq => lq && lq.id === q_default.id);
                if (loaded_q) {
                    q_default.completed = loaded_q.completed || false;
                    q_default.progress = loaded_q.progress || 0;
                    q_default.claimed = loaded_q.claimed || false;
                }
            });
        }
        if (Array.isArray(loadedState.activePotions)) {
    activePotions = loadedState.activePotions.map(pData => {
        if (!pData || !pData.id) return null;
        const potionBase = shopItemsData.find(shopItem => shopItem.id === pData.id);
        if (!potionBase) return null;
        return {
            id: pData.id,
            name: potionBase.name,
            description: potionBase.description,
            effect: potionBase.effect,
            endTime: typeof pData.endTime === 'number' ? pData.endTime : null,
            adventuresLeft: pData.adventuresLeft,
            upgradesLeft: pData.upgradesLeft // Correctly loads the upgrade counter
        };
    }).filter(p => p !== null);
    // Filter out expired potions
    activePotions = activePotions.filter(p => (p.endTime && Date.now() < p.endTime) || (p.adventuresLeft > 0) || (p.upgradesLeft > 0));
}

        // +++ LOAD DUNGEON STATE +++
        playerDungeonEntriesToday = loadedState.playerDungeonEntriesToday || { dungeon_1: 0, dungeon_2: 0 };
        lastDungeonResetTimestamp = loadedState.lastDungeonResetTimestamp || 0;
        playerDungeonCrawlers = Array.isArray(loadedState.playerDungeonCrawlers) ? loadedState.playerDungeonCrawlers : [];
        playerDungeonCrawlers = Array.isArray(loadedState.playerDungeonCrawlers) ? loadedState.playerDungeonCrawlers : [];
        confirmedCrawlersForDungeons = loadedState.confirmedCrawlersForDungeons || {}; // <<< ADD THIS LINE
        // dungeonCrawlerIdsLoaded is generally set at client start, not loaded from save.
        // +++ END LOAD DUNGEON STATE +++
        
        // Ensure activeDungeons loads npcCrawlers correctly
        activeDungeons = Array.isArray(loadedState.activeDungeons) ? loadedState.activeDungeons.map(dunData => { 
             return {
                 id: dunData.id || nextActiveAdventureId++, 
                 dungeonId: dunData.dungeonId || "unknown_dungeon",
                 name: dunData.name || "Unknown Dungeon",
                 adventurers: dunData.adventurers || 0,
                 returnTime: typeof dunData.returnTime === 'number' ? dunData.returnTime : Date.now(),
                 npcCrawlers: Array.isArray(dunData.npcCrawlers) ? dunData.npcCrawlers : [] // <<< ADD THIS LINE
             };
         }) : [];
         // The nextActiveAdventureId recalculation after this block should still be fine.

        recalculateTotalAvailableAdventurers();

        updateStatsDisplay();
        updatePlayerCombatStatsDisplay();
        renderMaterials();
        renderActiveTasksInSidebar(); // Renamed renderActiveAdventuresInSidebar
        renderActivePotions();
        renderInventory();
        updateAdventureDisplayStates();
        updateSwapDisplay();

        // Re-render the currently active page
        const activePageElement = document.querySelector('.page-content.active');
        if (activePageElement) {
            const pageId = activePageElement.id;
            // Specific rendering logic moved into showPage
            showPage(pageId); // Call showPage to trigger specific render functions
        } else {
             // Default to showing the adventures page if no active page found
             showPage('adventures-page');
        }

        // +++ CHECK AND RESET DAILY DUNGEON ENTRIES +++
        checkAndResetDailyDungeonEntries();
        // +++ END CHECK +++

        console.log("Game state applied successfully.");
    } catch (error) {
        console.error("Error during applyLoadedGameState:", error, error.stack);
        showCustomPopup("Error applying loaded game data. Please try logging in again or contact support if this persists.", "Apply State Error");
    }
    const pvpMenuItem = document.getElementById('pvp-menu-item');
    if (pvpMenuItem) {
        pvpMenuItem.style.display = playerHasPurchasedPvpScroll ? 'flex' : 'none';
    }
}
            

            // --- Theme and Page Navigation ---
            function initializeTheme() { const savedTheme = localStorage.getItem('theme'); if (savedTheme === 'light') { body.classList.remove('dark-mode'); body.classList.add('light-mode'); if(darkModeToggle) darkModeToggle.checked = false; if (gameContainer && !gameContainer.classList.contains('hidden')) loadTwitterWidget('light'); } else { body.classList.add('dark-mode'); body.classList.remove('light-mode'); if(darkModeToggle) darkModeToggle.checked = true; if (gameContainer && !gameContainer.classList.contains('hidden')) loadTwitterWidget('dark'); } }
            function loadTwitterWidget(theme) { if (twitterWidgetContainer) { twitterWidgetContainer.innerHTML = ''; const twitterLink = document.createElement('a'); twitterLink.className = 'twitter-timeline'; twitterLink.setAttribute('data-dnt', 'true'); twitterLink.href = 'https://twitter.com/nvart_?ref_src=twsrc%5Etfw'; twitterLink.setAttribute('data-theme', theme); twitterLink.setAttribute('data-height', '400'); twitterLink.textContent = 'Tweets by nvart_'; twitterWidgetContainer.appendChild(twitterLink); let twitterScript = document.querySelector('script[src="https://platform.twitter.com/widgets.js"]'); if (twitterScript) { twitterScript.remove(); } twitterScript = document.createElement('script'); twitterScript.async = true; twitterScript.src = 'https://platform.twitter.com/widgets.js'; twitterScript.charset = 'utf-8'; document.body.appendChild(twitterScript); } }
            
            if(darkModeToggle){ darkModeToggle.addEventListener('change', () => { if (darkModeToggle.checked) { body.classList.add('dark-mode'); body.classList.remove('light-mode'); localStorage.setItem('theme', 'dark'); loadTwitterWidget('dark'); } else { body.classList.remove('dark-mode'); body.classList.add('light-mode'); localStorage.setItem('theme', 'light'); loadTwitterWidget('light'); } });}
            
                        const mainMenuToggleBtn = document.getElementById('mainMenuToggleBtn');
            if (mainMenuToggleBtn) {
                mainMenuToggleBtn.addEventListener('click', () => {
                    document.body.classList.toggle('mobile-menu-open');
                });
            }

            // Also close the menu when a menu item is clicked on mobile
            const mainMenuList = document.getElementById('mainMenuList');
            if (mainMenuList) {
                mainMenuList.addEventListener('click', (event) => {
                    // Check if a list item was clicked and if the mobile menu is open
                    if (event.target.closest('li') && document.body.classList.contains('mobile-menu-open')) {
                        document.body.classList.remove('mobile-menu-open');
                    }
                });
            }
            
            async function showPage(pageIdToShow) { console.log("Switching to page:", pageIdToShow); if(!pageContents || pageContents.length === 0) { console.error("pageContents NodeList is empty or not found in showPage. Ensure HTML elements with class 'page-content' exist and are selected correctly."); return; } pageContents.forEach(page => { page.classList.remove('active'); }); const targetPage = document.getElementById(pageIdToShow); if (targetPage) { targetPage.classList.add('active'); if (pageIdToShow === 'quests-page') renderQuests(); else if (pageIdToShow === 'shop-page') renderShopItems(); else if (pageIdToShow === 'crafting-page') renderCraftingItems(); else if (pageIdToShow === 'inventory-page') renderInventory(); else if (pageIdToShow === 'daily-rewards-page') renderDailyRewards(); else if (pageIdToShow === 'whitelist-page') await fetchAndDisplayRaffles(); else if (pageIdToShow === 'upgrade-page') { /* placeholder for upgrade page specific logic if any needed on show */ } else if (pageIdToShow === 'leaderboard-page') await fetchAndDisplayLeaderboards('pvTokens'); else if (pageIdToShow === 'dungeons-page') { renderDungeonsPage(); } /* <-- ADD THIS LINE */ } else { console.error("Target page with ID '" + pageIdToShow + "' not found."); showPage('adventures-page'); }}
            if(menuItems){ menuItems.forEach(item => { item.addEventListener('click', () => { const targetPageId = item.dataset.page; if (targetPageId) { showPage(targetPageId); } }); });}
            

            // --- Core Game Logic Display & Updates ---
            updateStatsDisplay(); 
            
            function updateStatsDisplay() { if(pvCountElement) pvCountElement.textContent = currentPvTokens; if(goldCountElement) goldCountElement.textContent = currentGold; if(diamondCountElement) diamondCountElement.textContent = currentDiamonds; if(availableAdventurersCountElement) availableAdventurersCountElement.textContent = totalAvailableAdventurers; }
            function formatTimeLeft(milliseconds) { if (milliseconds <= 0) return "Ended"; let ts = Math.ceil(milliseconds / 1000); let h = Math.floor(ts / 3600); ts %= 3600; let m = Math.floor(ts / 60); let s = ts % 60; return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`; }
            
function recalculateTotalAvailableAdventurers() {
    // Calculate adventurers currently on adventures AND dungeons
    const adventurersOnAdventure = activeAdventures.reduce((sum, adv) => sum + adv.adventurers, 0);
    const adventurersOnDungeon = activeDungeons.reduce((sum, dun) => sum + dun.adventurers, 0); // <-- ADD THIS LINE
    const totalAdventurersBusy = adventurersOnAdventure + adventurersOnDungeon; // <-- MODIFY THIS LINE

    // Base adventurers + bonus from ordinals - those currently busy
    totalAvailableAdventurers = MAX_PLAYER_ADVENTURERS + ordinalBonusAdventurers - totalAdventurersBusy; // <-- MODIFY THIS LINE

    updateStatsDisplay(); // This will update the UI for available adventurers
    updateAdventureDisplayStates(); // Update adventure buttons based on new availability
    // We also need to update dungeon button states
    if (document.getElementById('dungeons-page').classList.contains('active')) { // <-- ADD THIS IF BLOCK
        renderDungeonsPage();
    }
    console.log(`Recalculated totalAvailableAdventurers: ${totalAvailableAdventurers} (Base: ${MAX_PLAYER_ADVENTURERS}, Bonus: ${ordinalBonusAdventurers}, Busy: ${totalAdventurersBusy})`); // <-- MODIFY LOG
}
            
 // DELETE THE OLD renderDungeonsPage FUNCTION AND PASTE THIS NEW ONE

 function renderDungeonsPage() {
    const entryContainer = document.getElementById('dungeon-entry-container');
    const dotsContainer = document.getElementById('dungeon-dots-container');
    const prevBtn = document.getElementById('dungeon-prev-btn');
    const nextBtn = document.getElementById('dungeon-next-btn');
    const npcContainer = document.getElementById('dungeon-npc-selection-container');

    if (!entryContainer || !dotsContainer || !prevBtn || !nextBtn || !npcContainer) return;

    entryContainer.innerHTML = '';
    dotsContainer.innerHTML = '';
    npcContainer.innerHTML = '';

    dungeonsData.forEach((dungeon, index) => {
        const dot = document.createElement('span');
        dot.innerHTML = '';
        dot.style.cursor = 'pointer';
        dot.style.fontSize = '2.5em';
        dot.style.margin = '0 5px';
        dot.style.color = (index === currentDungeonIndex) ? 'var(--highlight-color-gold)' : 'var(--label-color)';
        dot.onclick = () => { currentDungeonIndex = index; renderDungeonsPage(); };
        dotsContainer.appendChild(dot);
    });
    
    const dungeon = dungeonsData[currentDungeonIndex];
    if (!dungeon) return;

    // --- Calculate Party Stats & Max Party Size ---
    const playerAttack = parseInt(playerAttackStatElement.textContent) || 0;
    const playerDefense = parseInt(playerDefenseStatElement.textContent) || 0;
    let partyAttack = playerAttack;
    let partyDefense = playerDefense;
    let effectiveMaxPartySize = dungeon.maxPartySize || 0;

    const athTalismanEquipped = Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "ath_talisman"));
    if (athTalismanEquipped && (dungeon.id === 'dungeon_2' || dungeon.id === 'dungeon_3')) {
        effectiveMaxPartySize++;
    }

    const selectedNpcsForDungeon = confirmedCrawlersForDungeons[dungeon.id] || [];
    if (dungeon.type === 'party_npc') {
        selectedNpcsForDungeon.forEach(npcId => {
            const npc = npcData.find(n => n.id === npcId);
            if (npc) {
                partyAttack += npc.attack;
                partyDefense += npc.defense;
            }
        });
    }

    // --- Requirements and Lock Logic ---
    const requiredAdventure = adventuresData[dungeon.requiredAdventureId];
    const isAdventureActive = activeAdventures.find(adv => adv.originalAdventureId === dungeon.requiredAdventureId);
    let isLockedForEntry = false;
    let requirementText = `Requires: ${dungeon.attackRequirement} ATK & ${dungeon.defenseRequirement} DEF. Adventure "${requiredAdventure.name}" must be active.`;
    
    // --- Bonus Entry calculation ---
    let bonusEntries = 0;
    if (dungeon.id === "dungeon_1") {
        if (Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "pizza_pendant"))) bonusEntries++;
        if (Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "fire_sword_satoshi"))) bonusEntries++;
    } else if (dungeon.id === "dungeon_2") {
        if (Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "pizza_pendant"))) bonusEntries++;
        if (Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "krakkin_bow"))) bonusEntries++;
    } else if (dungeon.id === "dungeon_3") {
        if (Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "ath_talisman"))) bonusEntries++;
    }
    
    const entriesToday = playerDungeonEntriesToday[dungeon.id] || 0;
    let effectiveMaxEntries = dungeon.maxEntriesPerDay + bonusEntries;

    if (dungeon.isLockedContent || !isAdventureActive || partyAttack < dungeon.attackRequirement || partyDefense < dungeon.defenseRequirement || entriesToday >= effectiveMaxEntries || totalAvailableAdventurers < 1) {
        isLockedForEntry = true;
    }

    // --- Create and append the dungeon HTML ---
    const imageUrls = {
        "dungeon_1": "https://raw.githubusercontent.com/nvoiy/pvadventures/main/dungeon1.jpg",
        "dungeon_2": "https://raw.githubusercontent.com/nvoiy/pvadventures/main/dungeon2.jpg",
        "dungeon_3": "https://raw.githubusercontent.com/nvoiy/pvadventures/main/imgnew%20(5).jpg"
    };
    
    const dungeonDiv = document.createElement('div');
    dungeonDiv.className = `dungeon-entry ${isLockedForEntry ? 'locked' : ''}`;
    const rewardHtml = `<span style="color: var(--highlight-color-gold);">${dungeon.placeholderReward}</span>`;
    const statusHtml = !isLockedForEntry ? `<span style="color: var(--highlight-color-connected);">Ready to Enter!</span>` : `<span style="color: var(--highlight-color-danger);">${requirementText}</span>`;
    
    dungeonDiv.innerHTML = `
        <div class="dungeon-icon-placeholder" style="background-image: url('${imageUrls[dungeon.id]}'); background-size: cover; background-position: center;"></div>
        <div class="dungeon-info">
            <h3>${dungeon.name}</h3>
            <p>${dungeon.description}</p>
            <p><strong>Time:</strong> ${dungeon.durationHours} Hours</p>
            <p><strong>Party Stats:</strong> ${partyAttack} ATK / ${partyDefense} DEF</p>
            <p><strong>Daily Entries:</strong> ${entriesToday} / ${effectiveMaxEntries} used</p>
            <p><strong>Reward:</strong> ${rewardHtml}</p>
            <p class="dungeon-requirements">${statusHtml}</p>
        </div>
        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px; min-width: 100px;">
            <button class="action-button enter-dungeon-btn" data-dungeon-id="${dungeon.id}" ${isLockedForEntry ? 'disabled' : ''}>Enter</button>
            <div class="dungeon-drops-area">
                <button class="action-button dungeon-drops-button" data-dungeon-id="${dungeon.id}">DROPS</button>
                <div class="drops-popover" id="dungeon-drops-popover-${dungeon.id}"></div> 
            </div>
        </div>
    `;
    entryContainer.appendChild(dungeonDiv);

    if (dungeon.type === 'party_npc' && !dungeon.isLockedContent) {
        let npcHtml = `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 10px;">
                           <h4 style="margin:0; color: var(--label-color);">Select Party Members (Max ${effectiveMaxPartySize})</h4>
                           <button id="reset-party-btn" class="action-button" style="background-color: var(--highlight-color-danger); color: white;">Reset Party</button>
                       </div>
                       <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;">`;
        
        npcData.forEach(npc => {
            const isSelected = selectedNpcsForDungeon.includes(npc.id);
            // LOCKS NPCs 4, 5, 6 for Dungeon 2
            const isSelectableForThisDungeon = dungeon.id === 'dungeon_3' || !['npc4', 'npc5', 'npc6'].includes(npc.id);

            npcHtml += `
                <div class="npc-card" data-npc-id="${npc.id}" data-dungeon-id="${dungeon.id}" style="border: 2px solid ${isSelected ? 'var(--highlight-color-gold)' : 'var(--border-color)'}; cursor: ${isSelectableForThisDungeon ? 'pointer' : 'not-allowed'}; padding: 10px; border-radius: 5px; text-align: center; width: 120px; opacity: ${isSelectableForThisDungeon ? '1' : '0.5'};">
                    <img src="${npc.imageUrl}" style="width: 80px; height: 80px; object-fit: cover; border-radius: 4px; margin-bottom: 5px;">
                    <p style="margin:0; font-size: 0.9em;">${npc.name}</p>
                    <p style="margin:0; font-size: 0.85em;">ATK: ${npc.attack} / DEF: ${npc.defense}</p>
                </div>
            `;
        });
        npcHtml += `</div>`;
        npcContainer.innerHTML = npcHtml;

        npcContainer.querySelectorAll('.npc-card').forEach(card => {
            card.onclick = () => {
                const npcId = card.dataset.npcId;
                const dungeonId = card.dataset.dungeonId;
                if (dungeonId !== dungeon.id) return; // Prevent clicks when not on current dungeon
                
                // Re-check if this NPC is selectable for the current dungeon
                const isSelectableNow = dungeon.id === 'dungeon_3' || !['npc4', 'npc5', 'npc6'].includes(npcId);
                if (!isSelectableNow) return;

                let currentSelection = confirmedCrawlersForDungeons[dungeonId] || [];
                const npcIndex = currentSelection.indexOf(npcId);

                if (npcIndex > -1) {
                    currentSelection.splice(npcIndex, 1);
                } else {
                    if (currentSelection.length < effectiveMaxPartySize) {
                        currentSelection.push(npcId);
                    } else {
                        showCustomPopup(`You can only select up to ${effectiveMaxPartySize} party members for this dungeon.`, "Party Full");
                    }
                }
                confirmedCrawlersForDungeons[dungeonId] = currentSelection;
                renderDungeonsPage();
            };
        });

        document.getElementById('reset-party-btn').onclick = () => {
            confirmedCrawlersForDungeons[dungeon.id] = [];
            renderDungeonsPage();
        };
    }

    dungeonDiv.querySelector('.enter-dungeon-btn').onclick = handleEnterDungeon;
    
    const dropsButton = dungeonDiv.querySelector('.dungeon-drops-button');
    if (dropsButton) {
        dropsButton.addEventListener('mouseenter', () => {
            const popover = document.getElementById(`dungeon-drops-popover-${dungeon.id}`);
            if (popover && dungeon.drops && dungeon.drops.length > 0) {
                let dropsHtml = '<h5>Possible Drops:</h5><ul>';
                dungeon.drops.forEach(drop => {
                    const dItem = craftableItemsData.find(ci => ci.id === drop.id || ci.name === drop.name);
                    dropsHtml += `<li>${drop.qty || 1}x ${dItem ? dItem.name : drop.name} (${(drop.chance * 100).toFixed(2)}%)</li>`;
                });
                dropsHtml += '</ul>';
                popover.innerHTML = dropsHtml;
                popover.style.display = 'block';
            } else if (popover) {
                 popover.innerHTML = '<h5>No rare drops in this dungeon.</h5>';
                 popover.style.display = 'block';
            }
        });
        dropsButton.addEventListener('mouseleave', () => {
            const popover = document.getElementById(`dungeon-drops-popover-${dungeon.id}`);
            if (popover) popover.style.display = 'none';
        });
    }

    prevBtn.style.visibility = (currentDungeonIndex > 0) ? 'visible' : 'hidden';
    nextBtn.style.visibility = (currentDungeonIndex < dungeonsData.length - 1) ? 'visible' : 'hidden';
    prevBtn.onclick = () => { if (currentDungeonIndex > 0) { currentDungeonIndex--; renderDungeonsPage(); } };
    nextBtn.onclick = () => { if (currentDungeonIndex < dungeonsData.length - 1) { currentDungeonIndex++; renderDungeonsPage(); } };
}

function renderActiveTasksInSidebar() {
    const sidebarAdventuresList = document.getElementById('sidebarActiveAdventuresList');
    const sidebarDungeonsList = document.getElementById('sidebarActiveDungeonsList');
    const sidebarDungeonsContainer = document.getElementById('sidebarActiveDungeonsDisplay');

    if (!sidebarAdventuresList || !sidebarDungeonsList || !sidebarDungeonsContainer) return;

    const isAdmin = currentUser && ADMIN_WALLET_ADDRESSES.includes(currentUser.uid.toLowerCase());

    // --- Render Active Adventures ---
    sidebarAdventuresList.innerHTML = '';
    if (activeAdventures.length === 0) {
        sidebarAdventuresList.innerHTML = '<p style="text-align:center; font-size:0.9em;">No active adventures.</p>';
    } else {
        activeAdventures.sort((a, b) => a.returnTime - b.returnTime).forEach(adv => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'active-adventure-item';
            itemDiv.dataset.instanceId = adv.id; // Add instanceId for timer update
            
            const adminFinishBtn = isAdmin ? `<button class="action-button finish-now-btn" data-task-id="${adv.id}" data-task-type="adventure" style="font-size:0.8em; padding: 2px 4px; margin-right: 5px; background-color: var(--highlight-color-gold); color: black;">Finish</button>` : '';

            itemDiv.innerHTML = `
                <div class="active-adventure-item-info">
                    <p><strong>${adv.name}</strong></p>
                    <p>Adventurers: ${adv.adventurers}</p>
                    <p>Time Left: <span class="timer">${formatTimeLeft(adv.returnTime - Date.now())}</span></p>
                </div>
                <div style="display:flex; align-items:center;">
                    ${adminFinishBtn}
                    <button class="cancel-adventure-btn" data-task-instance-id="${adv.id}" data-task-type="adventure" title="Cancel Adventure"></button>
                </div>
            `;
            sidebarAdventuresList.appendChild(itemDiv);
        });
    }

    // --- Render Active Dungeons ---
    sidebarDungeonsList.innerHTML = '';
    if (activeDungeons.length === 0) {
        sidebarDungeonsContainer.classList.add('hidden');
    } else {
        sidebarDungeonsContainer.classList.remove('hidden');
        activeDungeons.sort((a, b) => a.returnTime - b.returnTime).forEach(dun => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'active-adventure-item';
            itemDiv.dataset.instanceId = dun.id; // Add instanceId for timer update

            const adminFinishBtn = isAdmin ? `<button class="action-button finish-now-btn" data-task-id="${dun.id}" data-task-type="dungeon" style="font-size:0.8em; padding: 2px 4px; margin-right: 5px; background-color: var(--highlight-color-gold); color: black;">Finish</button>` : '';

            itemDiv.innerHTML = `
                <div class="active-adventure-item-info">
                    <p><strong>${dun.name}</strong></p>
                    <p>Dungeon Party: ${dun.adventurers}</p>
                    <p>Time Left: <span class="timer">${formatTimeLeft(dun.returnTime - Date.now())}</span></p>
                </div>
                <div style="display:flex; align-items:center;">
                    ${adminFinishBtn}
                    <button class="cancel-adventure-btn" data-task-instance-id="${dun.id}" data-task-type="dungeon" title="Cancel Dungeon"></button>
                </div>
            `;
            sidebarDungeonsList.appendChild(itemDiv);
        });
    }

    // Attach listeners after rendering
    document.querySelectorAll('.cancel-adventure-btn').forEach(b => {
        b.onclick = () => {
            const instanceId = parseInt(b.dataset.taskInstanceId);
            const taskType = b.dataset.taskType;
            if (taskType === 'adventure') handleCancelAdventure(instanceId);
            else if (taskType === 'dungeon') handleCancelDungeon(instanceId);
        };
    });

    document.querySelectorAll('.finish-now-btn').forEach(b => {
        b.onclick = () => {
            const taskId = parseInt(b.dataset.taskId);
            const taskType = b.dataset.taskType;
            if (taskType === 'adventure') completeAdventure(taskId);
            else if (taskType === 'dungeon') completeDungeon(taskId);
        };
    });
}
            
            
function handleCancelDungeon(dungeonInstanceId) {
                if (!currentUser) return;
                const dungeonToCancel = activeDungeons.find(dun => dun.id === dungeonInstanceId);
                if (!dungeonToCancel) {
                    console.warn(`handleCancelDungeon: Could not find active dungeon with instanceId ${dungeonInstanceId}.`);
                    return;
                }

                showCustomPopup(
                    `Are you sure you want to cancel the dungeon "${dungeonToCancel.name}"? Your adventurer(s) will return immediately, and no rewards will be given.`,
                    "Confirm Cancel Dungeon",
                    { 
                        confirmCallback: (confirmed) => {
                            if (confirmed) {
                                const dungeonToCancelAgain = activeDungeons.find(dun => dun.id === dungeonInstanceId); // Re-find for safety
                                if (!dungeonToCancelAgain) return;

                                activeDungeons = activeDungeons.filter(dun => dun.id !== dungeonInstanceId);
                                
                                recalculateTotalAvailableAdventurers(); // This will free up the adventurer

                                showCustomPopup(`Dungeon "${dungeonToCancelAgain.name}" has been cancelled. Adventurer(s) have returned.`, "Dungeon Cancelled");
                                
                                updateStatsDisplay();
                                renderActiveTasksInSidebar(); // To remove it from the list
                                if (document.getElementById('dungeons-page').classList.contains('active')) {
                                    renderDungeonsPage(); // To update button states on the main page
                                }
                                if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
                            }
                        }
                    }
                );
            }
            function renderActivePotions() { if (!activePotionsList || !activePotionsDisplay) return; activePotionsList.innerHTML = ''; if (activePotions.length === 0) { activePotionsDisplay.classList.add('hidden'); return; } activePotionsDisplay.classList.remove('hidden'); activePotions.forEach(potion => { const itemDiv = document.createElement('div'); itemDiv.classList.add('potion-item'); let details = ''; if (potion.endTime) { const timeLeftMs = potion.endTime - Date.now(); details = `Time Left: <span class="timer">${formatTimeLeft(timeLeftMs)}</span>`; } else if (potion.adventuresLeft !== undefined) { details = `Adventures Left: ${potion.adventuresLeft}`; } itemDiv.innerHTML = `<p><strong>${potion.name}</strong></p><p>${potion.description}</p><p>${details}</p>`; activePotionsList.appendChild(itemDiv); });}
            
            function updatePlayerCombatStatsDisplay() {
    if (!playerAttackStatElement || !playerDefenseStatElement) return;
    let totalAttack = 0;
    let totalDefense = 0;

    Object.values(equippedItems).forEach(equippedInstanceId => {
        if (!equippedInstanceId) return;
        const invItem = playerInventory.find(i => i.uniqueInstanceId === equippedInstanceId);
        if (invItem) {
            const itemMaster = craftableItemsData.find(im => im.id === invItem.id);
            if (itemMaster && itemMaster.perk) {
                const scaledPerk = getScaledItemPerk(itemMaster, invItem.level || 0);
                if (scaledPerk) {
                    // This now checks for 'attack' or 'defense' properties in ANY perk object
                    if (scaledPerk.attack) {
                        totalAttack += scaledPerk.attack;
                    }
                    if (scaledPerk.defense) {
                        totalDefense += scaledPerk.defense;
                    }
                    // This handles the old, simple perks
                    if (scaledPerk.type === "attackBoost") {
                        totalAttack += scaledPerk.value;
                    } else if (scaledPerk.type === "defenseBoost") {
                        totalDefense += scaledPerk.value;
                    }
                }
            }
        }
    });
    playerAttackStatElement.textContent = totalAttack;
    playerDefenseStatElement.textContent = totalDefense;
}

            function getDungeonSetBonusTimeReduction() {
                let equippedSetPieces = 0;
                dungeonSetItemIds.forEach(setItemId => {
                    if (Object.values(equippedItems).some(instanceId => {
                        if (!instanceId) return false;
                        const item = playerInventory.find(invItem => invItem.uniqueInstanceId === instanceId);
                        return item && item.id === setItemId;
                    })) {
                        equippedSetPieces++;
                    }
                });

                if (equippedSetPieces >= 4) { // All 4 pieces equipped
                    return 0.20; // 20% time reduction
                }
                return 0; // No bonus
            }

            function renderMaterials() { 
                if (!materialsListContainer) return;
                materialsListContainer.innerHTML = ''; 

                for (const tier in materialTiers) {
                    const tierTitle = document.createElement('h5');
                    tierTitle.classList.add('material-tier-title');
                    tierTitle.textContent = `Tier ${tier} Materials:`;
                    materialsListContainer.appendChild(tierTitle);

                    const ul = document.createElement('ul');
                    let foundInTier = false;
                    materialTiers[tier].forEach(matName => {
                        if (playerMaterials.hasOwnProperty(matName) && playerMaterials[matName] > 0) {
                            const li = document.createElement('li');
                            li.textContent = `${matName}: ${playerMaterials[matName]}`;
                            ul.appendChild(li);
                            foundInTier = true;
                        }
                    });
                    if (!foundInTier) {
                         const li = document.createElement('li');
                         li.textContent = `No Tier ${tier} materials found.`;
                         ul.appendChild(li);
                    }
                    materialsListContainer.appendChild(ul);
                }
                const scrollsTitle = document.createElement('h5');
                scrollsTitle.classList.add('upgrade-scrolls-title');
                scrollsTitle.textContent = 'Upgrade Scrolls:';
                materialsListContainer.appendChild(scrollsTitle);
                const scrollsUl = document.createElement('ul');
                                scrollsUl.appendChild(createScrollListItem(scrollData.low.name, playerScrolls.low));
                scrollsUl.appendChild(createScrollListItem(scrollData.middle.name, playerScrolls.middle));
                scrollsUl.appendChild(createScrollListItem(scrollData.high.name, playerScrolls.high));
                materialsListContainer.appendChild(scrollsUl);
            }
            function createScrollListItem(name, count) {
                const li = document.createElement('li');
                li.textContent = `${name}: ${count}`;
                return li;
            }


             function getItemIconHTML(iconUrlOrColor, typeInitial = 'I', size = 'var(--item-icon-size)') {
                const isUrl = iconUrlOrColor && (iconUrlOrColor.startsWith('http') || iconUrlOrColor.startsWith('data:image') || iconUrlOrColor.startsWith('https://'));
                const iconContainer = document.createElement('div');
                iconContainer.style.width = size;
                iconContainer.style.height = size;
                iconContainer.style.display = 'flex';
                iconContainer.style.alignItems = 'center';
                iconContainer.style.justifyContent = 'center';
                iconContainer.style.marginRight = (size === 'var(--item-icon-size)') ? '10px' : '0'; 
                iconContainer.style.flexShrink = '0';
                iconContainer.style.overflow = 'hidden'; 
                iconContainer.style.borderRadius = '4px'; 


                if (isUrl) {
                    const img = document.createElement('img');
                    img.src = iconUrlOrColor;
                    img.alt = typeInitial;
                    img.style.maxWidth = '100%';
                    img.style.maxHeight = '100%';
                    img.style.objectFit = 'contain'; 
                    iconContainer.appendChild(img);
                } else {
                    iconContainer.style.backgroundColor = iconUrlOrColor || '#555'; 
                    iconContainer.style.color = 'white';
                    let fontSizeNum = 0.4; 
                    try {
                        const sizeValue = getComputedStyle(document.documentElement).getPropertyValue('--item-icon-size').trim();
                        if (sizeValue.endsWith('px')) {
                           fontSizeNum = (parseInt(sizeValue) * 0.4) / parseInt(getComputedStyle(document.body).fontSize) ; 
                        }
                    } catch (e) { /* use default */ }
                    iconContainer.style.fontSize = `${fontSizeNum}em`; 
                    iconContainer.textContent = typeInitial ? typeInitial.substring(0,1).toUpperCase() : 'I';
                }
                return iconContainer.outerHTML;
            }


           /* DELETE THE OLD applyCraftingFiltersAndRender, renderCraftingItems, AND setupCraftingUI FUNCTIONS AND PASTE THIS ENTIRE NEW BLOCK */

           function applyCraftingFiltersAndRender() {
    // Filter by type (e.g., 'all', 'armour', 'boots')
    let tempFiltered = craftableItemsData.filter(item => {
        if (craftingFilterType === 'all') {
            return true;
        }
        // Handle 'Misc' as a special case for multiple types
        if (craftingFilterType === 'misc') {
            return ['Trinket', 'Rucksack', 'Misc'].includes(item.type);
        }
        // Fix: Compare in a case-insensitive way
        return item.type.toLowerCase() === craftingFilterType;
    });

    // Further filter by 'craftable only' if the toggle is active
    if (craftingShowOnlyCraftable) {
        tempFiltered = tempFiltered.filter(item => {
            if (!item.recipe) return false; // Must have a recipe to be craftable
            
            // Check if player already owns this base item
            const alreadyOwned = playerInventory.some(invItem => invItem.id === item.id);
            if (alreadyOwned) return false;

            // Check if player has enough materials
            for (const mat in item.recipe) {
                if ((playerMaterials[mat] || 0) < item.recipe[mat]) {
                    return false; // Not enough materials
                }
            }
            return true; // Has materials and does not own it
        });
    }
    
    craftableItemsDataFiltered = tempFiltered;
    craftingCurrentPage = 1; // Reset to page 1 whenever a filter is applied
    renderCraftingItems(); // Render the newly filtered and paginated list
}

function renderCraftingItems() {
    if (!craftingItemsContainer) return;
    craftingItemsContainer.innerHTML = '';
    
    const totalPages = Math.ceil(craftableItemsDataFiltered.length / craftingItemsPerPage);
    const paginationContainer = document.getElementById('craftingPaginationContainer');

    if (craftableItemsDataFiltered.length === 0) {
        craftingItemsContainer.innerHTML = '<p style="text-align:center;">No items match the current filter.</p>';
        if (paginationContainer) paginationContainer.style.display = 'none'; // Hide pagination
        return;
    }
    
    if (paginationContainer) paginationContainer.style.display = 'flex'; // Show pagination
    
    const startIndex = (craftingCurrentPage - 1) * craftingItemsPerPage;
    const endIndex = startIndex + craftingItemsPerPage;
    const itemsToRender = craftableItemsDataFiltered.slice(startIndex, endIndex);

    itemsToRender.forEach(item => {
        const card = document.createElement('div');
        card.className = 'craftable-item-card';
        let recipeHtml = '';
        let craftButtonHtml = '';

        if (item.recipe && Object.keys(item.recipe).length > 0) {
            recipeHtml = 'Requires: ';
            for (const mat in item.recipe) { recipeHtml += `${item.recipe[mat]} ${mat}, `; }
            recipeHtml = recipeHtml.slice(0, -2);
            recipeHtml = `<p class="crafting-cost"><small>${recipeHtml}</small></p>`;

            const alreadyOwned = playerInventory.some(invItem => invItem.id === item.id);
            let canCurrentlyCraft = true;
            for (const mat in item.recipe) {
                if ((playerMaterials[mat] || 0) < item.recipe[mat]) {
                    canCurrentlyCraft = false;
                    break;
                }
            }

            let buttonClasses = "action-button craft-button";
            let buttonText = "Craft";
            let buttonDisabledAttribute = "";
            if (alreadyOwned) {
                buttonClasses += " owned"; buttonText = "Owned"; buttonDisabledAttribute = "disabled";
            } else if (canCurrentlyCraft) {
                buttonClasses += " craftable";
            } else {
                buttonDisabledAttribute = "disabled";
            }
            craftButtonHtml = `<button class="${buttonClasses}" data-item-id="${item.id}" ${buttonDisabledAttribute}>${buttonText}</button>`;
        } else {
            recipeHtml = '<p class="crafting-cost"><small>Cannot be crafted.</small></p>';
        }

        card.innerHTML = `
            <div class="item-icon-placeholder">${getItemIconHTML(item.iconUrlOrColor, item.type)}</div>
            <div class="item-info">
                <p><strong>${item.name}</strong> (${item.type})</p>
                <small>${item.description}</small>
                ${recipeHtml}
            </div>
            ${craftButtonHtml}`;
        craftingItemsContainer.appendChild(card);
        card.addEventListener('mousemove', (e) => showItemTooltip(e, item, !!item.recipe));
        card.addEventListener('mouseleave', hideItemTooltip);
    });

    // Update pagination controls
    document.getElementById('craftingPageInfo').textContent = `Page ${craftingCurrentPage} / ${totalPages > 0 ? totalPages : 1}`;
    document.getElementById('craftingPrevBtn').disabled = (craftingCurrentPage === 1);
    document.getElementById('craftingNextBtn').disabled = (craftingCurrentPage >= totalPages);

    // Add event listeners
    craftingItemsContainer.querySelectorAll('.craft-button:not([disabled])').forEach(b => {
       b.addEventListener('click', e => craftItem(e.target.dataset.itemId));
    });
}

function setupCraftingUI() {
    const filterContainer = document.getElementById('craftingFilterContainer');
    const prevBtn = document.getElementById('craftingPrevBtn');
    const nextBtn = document.getElementById('craftingNextBtn');
    if (!filterContainer || !prevBtn || !nextBtn) return;

    // --- Create Filter Buttons ---
    const itemTypes = ['Armour', 'Helmet', 'Boots', 'Amulet', 'Ring', 'Weapon', 'Pet', 'Misc'];
    const filterTypes = ['All', ...itemTypes];
    
    filterContainer.innerHTML = ''; // Clear any existing buttons

    // Create the "Show Craftable Only" toggle first
    const craftableToggleBtn = document.createElement('button');
    craftableToggleBtn.className = 'action-button leaderboard-filter-btn';
    craftableToggleBtn.innerHTML = `Show Craftable Only <span class="craftable-toggle-checkmark"></span>`;
    
    // Check state on load and apply class if needed
    if (craftingShowOnlyCraftable) {
        craftableToggleBtn.classList.add('active');
    }

    craftableToggleBtn.onclick = () => {
        craftingShowOnlyCraftable = !craftingShowOnlyCraftable; // Toggle the state
        craftableToggleBtn.classList.toggle('active', craftingShowOnlyCraftable); // Toggle visual style
        applyCraftingFiltersAndRender();
    };
    filterContainer.appendChild(craftableToggleBtn);
    
    // Create the type filter buttons
    filterTypes.forEach(type => {
        const btn = document.createElement('button');
        btn.className = 'action-button leaderboard-filter-btn';
        btn.textContent = `${type} Items`;
        btn.dataset.filter = type.toLowerCase();

        // Set the active class based on the current state
        if (type.toLowerCase() === craftingFilterType) {
            btn.classList.add('active-type-filter');
        }
        
        btn.onclick = () => {
            // Remove active class from all *type* filters
            filterContainer.querySelectorAll('[data-filter]').forEach(b => b.classList.remove('active-type-filter'));
            // Add active class to the clicked button
            btn.classList.add('active-type-filter');
            // Set the state and re-render
            craftingFilterType = type.toLowerCase();
            applyCraftingFiltersAndRender();
        };
        filterContainer.appendChild(btn);
    });

    // --- Setup Pagination Listeners ---
    prevBtn.onclick = () => {
        if (craftingCurrentPage > 1) {
            craftingCurrentPage--;
            renderCraftingItems();
        }
    };
    nextBtn.onclick = () => {
        const totalPages = Math.ceil(craftableItemsDataFiltered.length / craftingItemsPerPage);
        if (craftingCurrentPage < totalPages) {
            craftingCurrentPage++;
            renderCraftingItems();
        }
    };
}

// Lastly, modify the showPage function to initialize the crafting UI
async function showPage(pageIdToShow) {
    console.log("Switching to page:", pageIdToShow);
    if (!pageContents || pageContents.length === 0) {
        console.error("pageContents NodeList is empty or not found in showPage.");
        return;
    }
    pageContents.forEach(page => {
        page.classList.remove('active');
    });
    const targetPage = document.getElementById(pageIdToShow);
    if (targetPage) {
        targetPage.classList.add('active');
        
        // Always update the upgrade success display when changing pages, just in case.
        updateUpgradeSuccessRateDisplay();

        if (pageIdToShow === 'quests-page') {
            setupQuestUI();
            applyQuestFiltersAndRender();
        } else if (pageIdToShow === 'shop-page') {
            renderShopItems();
        } else if (pageIdToShow === 'crafting-page') {
            setupCraftingUI();
            applyCraftingFiltersAndRender();
        } else if (pageIdToShow === 'inventory-page') {
            renderInventory();
        } else if (pageIdToShow === 'daily-rewards-page') {
            renderDailyRewards();
        } else if (pageIdToShow === 'whitelist-page') {
            await fetchAndDisplayRaffles();
        } else if (pageIdToShow === 'leaderboard-page') {
            await fetchAndDisplayLeaderboards('pvTokens');
        } else if (pageIdToShow === 'dungeons-page') {
            renderDungeonsPage();
        }
    } else {
        console.error("Target page with ID '" + pageIdToShow + "' not found.");
        showPage('adventures-page');
    }
}
            
// DELETE THE OLD renderInventory FUNCTION AND PASTE THIS NEW ONE

function renderInventory() {
    if (!inventoryItemsContainer || !equipmentSlotsDisplay) return;

    // --- Part 1: Render Equipped Item Slots ---
    equipmentSlotsDisplay.innerHTML = '';
    const slotTypes = [{ name: "Armour", id: "Armour" }, { name: "Helmet", id: "Helmet" }, { name: "Boots", id: "Boots" }, { name: "Amulet", id: "Amulet" }, { name: "Ring 1", id: "Ring1" }, { name: "Ring 2", id: "Ring2" }, { name: "Weapon", id: "Weapon" }, { name: "Pet", id: "Pet" }, { name: "Misc 1", id: "Misc1" }, { name: "Misc 2", id: "Misc2" }];
    
    // Create a Set of all equipped item instance IDs for quick lookup
    const equippedInstanceIds = new Set(Object.values(equippedItems));

    slotTypes.forEach(slot => {
        const slotDiv = document.createElement('div');
        slotDiv.classList.add('equipment-slot');
        const equippedItemInstanceId = equippedItems[slot.id];
        const equippedInvItem = equippedItemInstanceId ? playerInventory.find(invItem => invItem.uniqueInstanceId === equippedItemInstanceId) : null;
        const itemDataForSlot = equippedInvItem ? craftableItemsData.find(i => i.id === equippedInvItem.id) : null;
        let slotContent = `<div class="slot-name">${slot.name.toUpperCase()}</div>`;
        
        // Handle locked slots first
        if (slot.id === "Ring2" && !secondRingSlotUnlocked) {
            slotDiv.classList.add('locked');
            slotContent += `<div class="equipped-item-container"><div class="empty-slot-text">(Locked)</div>`;
            const riderScrollInInventory = playerInventory.find(item => item.id === 'rider_scroll_unlock');
            if (riderScrollInInventory && !equippedInstanceIds.has(riderScrollInInventory.uniqueInstanceId)) {
                slotContent += `<button class="action-button use-rider-scroll-btn" data-item-unique-id="${riderScrollInInventory.uniqueInstanceId}">Use Rider Scroll</button>`;
            } else if (!playerHasPurchasedRiderScroll) {
                slotContent += `<div class="empty-slot-text" style="font-size:0.8em;">Purchase from Shop</div>`;
            }
            slotContent += `</div>`;
        } else if (slot.id === "Pet" && !petSlotUnlocked) {
            slotDiv.classList.add('locked');
            slotContent += `<div class="equipped-item-container"><div class="empty-slot-text">(Locked)</div>`;
            const petWhistleInInventory = playerInventory.find(item => item.id === 'pet_whistle_unlock');
            if (petWhistleInInventory && !equippedInstanceIds.has(petWhistleInInventory.uniqueInstanceId)) {
                slotContent += `<button class="action-button use-pet-whistle-btn" data-item-unique-id="${petWhistleInInventory.uniqueInstanceId}">Use Pet Whistle</button>`;
            } else if (!playerHasPurchasedPetWhistle) {
                slotContent += `<div class="empty-slot-text" style="font-size:0.8em;">Purchase from Shop</div>`;
            }
            slotContent += `</div>`;
        } else {
            // Handle regular unlocked slots
            slotContent += `<div class="equipped-item-container">`;
            if (itemDataForSlot && equippedInvItem) {
                const level = equippedInvItem.level || 0;
                const levelText = level > 0 ? `(+${level}) ` : '';
                slotDiv.className = `equipment-slot item-level-plus${level}`; // Set border color class
                slotContent += `${getItemIconHTML(itemDataForSlot.iconUrlOrColor, itemDataForSlot.type)} <div class="equipped-item-name">${levelText}${itemDataForSlot.name}</div> <button class="unequip-btn action-button" data-item-slot-id="${slot.id}">Unequip</button>`;
            } else {
                slotContent += `<div class="empty-slot-text">(Empty)</div>`;
            }
            slotContent += `</div>`;
        }
        slotDiv.innerHTML = slotContent;
        equipmentSlotsDisplay.appendChild(slotDiv);
        
        const itemContainerForTooltip = slotDiv.querySelector('.equipped-item-container');
        if (itemDataForSlot && equippedInvItem && itemContainerForTooltip) {
            itemContainerForTooltip.addEventListener('mousemove', (e) => showItemTooltip(e, { ...itemDataForSlot, level: equippedInvItem.level || 0 }));
            itemContainerForTooltip.addEventListener('mouseleave', hideItemTooltip);
        }
    });
    
    // Add event listeners for buttons in the slots
    equipmentSlotsDisplay.querySelectorAll('.unequip-btn').forEach(b => b.addEventListener('click', e => unequipItem(e.target.dataset.itemSlotId)));
    equipmentSlotsDisplay.querySelectorAll('.use-rider-scroll-btn').forEach(b => b.addEventListener('click', e => useRiderScrollUnlock(e.target.dataset.itemUniqueId)));
    equipmentSlotsDisplay.querySelectorAll('.use-pet-whistle-btn').forEach(b => b.addEventListener('click', e => usePetWhistleUnlock(e.target.dataset.itemUniqueId)));

    // --- Part 2: Render "My Items" (the bag) ---
    inventoryItemsContainer.innerHTML = '';
    
    // Filter out items that are currently equipped
    const unequippedInventory = playerInventory.filter(invItem => !equippedInstanceIds.has(invItem.uniqueInstanceId));

    if (unequippedInventory.length === 0) {
        inventoryItemsContainer.innerHTML = '<p style="text-align:center;">Your item bag is empty.</p>';
    } else {
        unequippedInventory.forEach(invItem => {
            const itemData = craftableItemsData.find(i => i.id === invItem.id) || shopItemsData.find(i => i.id === invItem.id);
            if (itemData) {
                const card = document.createElement('div');
                const level = invItem.level || 0;
                card.className = `inventory-item-card item-level-plus${level}`;
                const levelText = level > 0 ? `(+${level}) ` : '';
                
                let actionsHtml = '';
                // Check if the item is equippable
                if (itemData.type !== "unlockable_consumable" && itemData.type !== "upgrade_scroll_purchase") {
                    actionsHtml = `<button class="equip-btn action-button" data-item-unique-id="${invItem.uniqueInstanceId}">Equip</button>`;
                }
                
                card.innerHTML = ` 
                    <div class="item-icon-placeholder">${getItemIconHTML(itemData.iconUrlOrColor, itemData.type)}</div> 
                    <div class="item-info"> 
                        <p><strong>${levelText}${itemData.name}</strong> (${itemData.type || 'Item'})</p> 
                        <small class="item-perk">${itemData.description || ''}</small> 
                    </div> 
                    <div class="item-actions">${actionsHtml}</div>`;
                inventoryItemsContainer.appendChild(card);
                card.addEventListener('mousemove', (e) => showItemTooltip(e, { ...itemData, level: invItem.level || 0 }));
                card.addEventListener('mouseleave', hideItemTooltip);
            }
        });
    }

    // Add event listener for equip buttons in the bag
    inventoryItemsContainer.querySelectorAll('.equip-btn').forEach(b => b.addEventListener('click', e => equipItem(e.target.dataset.itemUniqueId)));
    
    // Finally, update combat stats which depend on equipped items
    updatePlayerCombatStatsDisplay();
    renderActiveSpecialties(); // <<< THIS IS THE FIX
}

            function useRiderScrollUnlock(itemUniqueId) {
                if (!currentUser) return;
                const itemIndex = playerInventory.findIndex(item => item.uniqueInstanceId === itemUniqueId && item.id === 'rider_scroll_unlock');
                if (itemIndex === -1) {
                    showCustomPopup("Rider Scroll not found in inventory or invalid item.", "Error");
                    return;
                }
                if (secondRingSlotUnlocked) {
                    showCustomPopup("Second Ring Slot is already unlocked.", "Info");
                    playerInventory.splice(itemIndex, 1); 
                    renderInventory();
                    if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
                    return;
                }

                secondRingSlotUnlocked = true;
                playerInventory.splice(itemIndex, 1); 

                showCustomPopup("Second Ring Slot Unlocked!", "Unlock Successful");
                renderInventory(); 
                if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
            }

            function handleEnterDungeon(event) {
    if (!currentUser) {
        showCustomPopup("You must be logged in to enter a dungeon.", "Login Required");
        return;
    }
    const dungeonId = event.target.dataset.dungeonId;
    const dungeon = dungeonsData.find(d => d.id === dungeonId);

    if (!dungeon || activeDungeons.some(ad => ad.dungeonId === dungeon.id) || !activeAdventures.find(adv => adv.originalAdventureId === dungeon.requiredAdventureId)) {
        // This will prevent entry if requirements are not met, the render function already shows the specific reason
        renderDungeonsPage();
        return;
    }
    
    // --- FINAL CHECK BEFORE ENTRY ---
    const playerBaseAttack = parseInt(playerAttackStatElement.textContent) || 0;
    const playerBaseDefense = parseInt(playerDefenseStatElement.textContent) || 0;
    let currentPartyAttack = playerBaseAttack;
    let currentPartyDefense = playerBaseDefense;
    if (dungeon.type === "party_npc") {
        (confirmedCrawlersForDungeons[dungeon.id] || []).forEach(npcId => {
            const npc = npcData.find(n => n.id === npcId);
            if (npc) { currentPartyAttack += npc.attack; currentPartyDefense += npc.defense; }
        });
    }

    if (currentPartyAttack < dungeon.attackRequirement || currentPartyDefense < dungeon.defenseRequirement || totalAvailableAdventurers < 1) {
         showCustomPopup(`Requirements not met. Please check stats and available adventurers.`, "Entry Failed");
        return;
    }

    // --- Daily Entry Calculation (moved here for final check) ---
    let bonusEntries = 0;
    if (Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "pizza_pendant")) && (dungeon.id === "dungeon_1" || dungeon.id === "dungeon_2")) bonusEntries++;
    if (Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "fire_sword_satoshi")) && dungeon.id === "dungeon_1") bonusEntries++;
    if (Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "krakkin_bow")) && dungeon.id === "dungeon_2") bonusEntries++;
    if (Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "ath_talisman")) && dungeon.id === "dungeon_3") bonusEntries++;
    
    if ((playerDungeonEntriesToday[dungeon.id] || 0) >= (dungeon.maxEntriesPerDay + bonusEntries)) {
        showCustomPopup(`Daily limit for ${dungeon.name} reached.`, "Limit Reached");
        return;
    }

    // --- TIME CALCULATION (FIXED) ---
    let baseDurationMs = dungeon.durationHours * GAME_HOUR_IN_REAL_SECONDS * 1000;
    let timeReductionPercent = 0;
    if (Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "dungeon_boots"))) {
        timeReductionPercent += 0.10; // 10% reduction from Dungeon Boots
    }
    const calculatedDurationMs = baseDurationMs * (1 - timeReductionPercent);
    const returnTime = Date.now() + calculatedDurationMs;
    // --- END TIME CALCULATION ---

    playerDungeonEntriesToday[dungeon.id] = (playerDungeonEntriesToday[dungeon.id] || 0) + 1;

    const newActiveDungeon = {
        id: nextActiveAdventureId++,
        dungeonId: dungeon.id,
        name: dungeon.name,
        adventurers: 1,
        returnTime: returnTime,
        npcCrawlers: (dungeon.type === "party_npc" ? (confirmedCrawlersForDungeons[dungeon.id] || []) : [])
    };

    activeDungeons.push(newActiveDungeon);
    recalculateTotalAvailableAdventurers();
    renderActiveTasksInSidebar();
    renderDungeonsPage();
    if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
}

adventureDropButtons.forEach(button => {
    button.addEventListener('mouseenter', (event) => {
        const adventureId = event.target.dataset.adventureId;
        const popover = document.getElementById(`drops-popover-${adventureId}`);
        const adventureInfo = adventuresData[adventureId];
        if (popover && adventureInfo && adventureInfo.drops) {
            let dropsHtml = '<h5>Possible Drops:</h5><ul>';
            adventureInfo.drops.forEach(drop => {
                const dItem = craftableItemsData.find(cd => cd.id === drop.name);
                dropsHtml += `<li>${drop.qty || 1}x ${dItem ? dItem.name : drop.name} (${(drop.chance * 100).toFixed(3)}%)</li>`;
            });
            dropsHtml += '</ul>';
            popover.innerHTML = dropsHtml;
            popover.style.display = 'block';
        }
    });
    button.addEventListener('mouseleave', (event) => {
        const adventureId = event.target.dataset.adventureId;
        const popover = document.getElementById(`drops-popover-${adventureId}`);
        if (popover) {
            popover.style.display = 'none';
        }
    });
});

function usePetWhistleUnlock(itemUniqueId) {
    if (!currentUser) return;
    const itemIndex = playerInventory.findIndex(item => item.uniqueInstanceId === itemUniqueId && item.id === 'pet_whistle_unlock');
    if (itemIndex === -1) {
        showCustomPopup("Ancient Pet Whistle not found in inventory or invalid item.", "Error");
        return;
    }
    if (petSlotUnlocked) {
        showCustomPopup("Pet Slot is already unlocked.", "Info");
        // Optionally, still consume the item if they try to use it again
        playerInventory.splice(itemIndex, 1);
        renderInventory();
        if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
        return;
    }

    petSlotUnlocked = true;
    playerInventory.splice(itemIndex, 1); // Consume the whistle

    showCustomPopup("Pet Slot Unlocked! You can now equip a pet.", "Unlock Successful");
    renderInventory(); // Re-render to show the unlocked slot
    if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
}
function applyQuestFiltersAndRender() {
    questsFiltered = quests.filter(quest => {
        return questsShowCompleted ? true : !quest.claimed;
    });
    questsCurrentPage = 1;
    renderQuests();
}

function renderQuests() {
    if (!questListDiv) return;
    questListDiv.innerHTML = '';
    
    const paginationContainer = document.getElementById('questPaginationContainer');
    const totalPages = Math.ceil(questsFiltered.length / questsItemsPerPage);

    if (questsFiltered.length === 0) {
        questListDiv.innerHTML = `<p style="text-align:center;">No quests to show.</p>`;
        if (paginationContainer) paginationContainer.style.display = 'none';
        return;
    }

    if (paginationContainer) paginationContainer.style.display = 'flex';
    
    const startIndex = (questsCurrentPage - 1) * questsItemsPerPage;
    const endIndex = startIndex + questsItemsPerPage;
    const questsToRender = questsFiltered.slice(startIndex, endIndex);

    questsToRender.forEach(quest => {
        const qe = document.createElement('div');
        qe.classList.add('quest-item');
        if (quest.completed && quest.claimed) {
            qe.classList.add('completed-and-claimed');
        } else if (quest.completed && !quest.claimed) {
            qe.classList.add('available-to-claim');
        }
        qe.innerHTML = `
            <div class="quest-info">
                <p>${quest.text} (${quest.progress || 0}/${quest.target || 'N/A'})</p>
            </div>
            <div class="quest-actions">
                <span class="quest-reward">Reward: ${quest.reward}</span>
                <button class="action-button claim-quest-btn" data-quest-id="${quest.id}" ${quest.completed && !quest.claimed ? '' : 'disabled'}>
                    ${quest.claimed ? 'Claimed' : 'Claim'}
                </button>
            </div>`;
        questListDiv.appendChild(qe);
    });

    document.getElementById('questPageInfo').textContent = `Page ${questsCurrentPage} / ${totalPages > 0 ? totalPages : 1}`;
    document.getElementById('questPrevBtn').disabled = (questsCurrentPage === 1);
    document.getElementById('questNextBtn').disabled = (questsCurrentPage >= totalPages);

    document.querySelectorAll('.claim-quest-btn:not([disabled])').forEach(b => {
        b.addEventListener('click', (e) => {
            if (!currentUser) return;
            const qId = parseInt(e.target.dataset.questId);
            const q = quests.find(q => q.id === qId);
            if (q && q.completed && !q.claimed) {
                q.claimed = true;
                const rewardParts = q.reward.split(',');
                let pvReward = 0, diamondReward = 0, goldReward = 0;
                rewardParts.forEach(part => {
                    if (part.includes("PV")) pvReward = parseInt(part.match(/(\d+)/)[1]);
                    if (part.includes("Diamond")) diamondReward = parseInt(part.match(/(\d+)/)[1]);
                    if (part.includes("Gold")) goldReward = parseInt(part.match(/(\d+)/)[1]);
                });
                currentPvTokens += pvReward;
                currentDiamonds += diamondReward;
                currentGold += goldReward;
                updateStatsDisplay();
                showCustomPopup(`Claimed reward: ${q.reward} for completing quest: "${q.text}"`, "Quest Reward Claimed");
                if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
                if ([1, 2, 3, 15].includes(q.id)) { updateAdventureDisplayStates(); }
                applyQuestFiltersAndRender(); // Re-render the quest list
            }
        });
    });
}

function setupQuestUI() {
    const toggleBtn = document.getElementById('questToggleCompletedBtn');
    const prevBtn = document.getElementById('questPrevBtn');
    const nextBtn = document.getElementById('questNextBtn');
    if (!toggleBtn || !prevBtn || !nextBtn) return;

    // By using .onclick, we ensure there is only ever one command on the button.
    // It automatically replaces the old one each time the page is viewed.
    toggleBtn.onclick = () => {
        questsShowCompleted = !questsShowCompleted;
        toggleBtn.classList.toggle('active', questsShowCompleted);
        toggleBtn.textContent = questsShowCompleted ? 'Hide Completed' : 'Show Completed';
        applyQuestFiltersAndRender();
    };

    prevBtn.onclick = () => {
        if (questsCurrentPage > 1) {
            questsCurrentPage--;
            renderQuests();
        }
    };

    nextBtn.onclick = () => {
        const totalPages = Math.ceil(questsFiltered.length / questsItemsPerPage);
        if (questsCurrentPage < totalPages) {
            questsCurrentPage++;
            renderQuests();
        }
    };
}
            
             function renderDailyRewards() {
                if (!dailyRewardsGrid) return;
                dailyRewardsGrid.innerHTML = '';
                const now = Date.now();
                let nextClaimableDay;

                if (lastDailyRewardDayClaimed === 0 || lastDailyRewardClaimTimestamp === 0) {
                    nextClaimableDay = 1;
                } else if (now - lastDailyRewardClaimTimestamp >= TWENTY_FOUR_HOURS_MS) {
                    if (lastDailyRewardDayClaimed >= 30) {
                        nextClaimableDay = 1;
                    } else {
                        nextClaimableDay = lastDailyRewardDayClaimed + 1;
                    }
                } else {
                    nextClaimableDay = -1;
                }

                let daysEffectivelyClaimedInThisCycle = lastDailyRewardDayClaimed;
                if (nextClaimableDay === 1 && lastDailyRewardDayClaimed >= 30 && (now - lastDailyRewardClaimTimestamp >= TWENTY_FOUR_HOURS_MS)) {
                    daysEffectivelyClaimedInThisCycle = 0;
                }

                dailyRewardsData.forEach(item => {
                    const dayDiv = document.createElement('div');
                    dayDiv.classList.add('reward-day');
                    
                    // --- THESE TWO LINES MOVED UP ---
                    const canClaimThisItem = (item.day === nextClaimableDay);
                    const isClaimedForDisplay = item.day <= daysEffectivelyClaimedInThisCycle && !canClaimThisItem;

                    // +++ STYLING LINES NOW WORK CORRECTLY +++
                    if (canClaimThisItem) {
                        dayDiv.classList.add('daily-reward-claimable');
                    } else if (isClaimedForDisplay) {
                        dayDiv.classList.add('daily-reward-claimed');
                    }
                    
                    let rewardText = item.reward;
                    if (item.day === 30) rewardText = `<strong style="color:var(--highlight-color-gold);">${item.reward}</strong>`;

                    dayDiv.innerHTML = `<h5>Day ${item.day}</h5><p>${rewardText}</p>
                                        <button class="action-button claim-daily-reward-btn" data-day="${item.day}" 
                                                ${canClaimThisItem ? '' : 'disabled'}>
                                            ${isClaimedForDisplay ? 'Claimed' : (canClaimThisItem ? 'Claim' : 'Locked')}
                                        </button>`;
                    dailyRewardsGrid.appendChild(dayDiv);
                });

                document.querySelectorAll('.claim-daily-reward-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        if (!currentUser) return;
                        const dayToClaim = parseInt(e.target.dataset.day);

                        const currentNow = Date.now();
                        let recheckNextClaimableDay;
                        if (lastDailyRewardDayClaimed === 0 || lastDailyRewardClaimTimestamp === 0) {
                            recheckNextClaimableDay = 1;
                        } else if (currentNow - lastDailyRewardClaimTimestamp >= TWENTY_FOUR_HOURS_MS) {
                            if (lastDailyRewardDayClaimed >= 30) recheckNextClaimableDay = 1;
                            else recheckNextClaimableDay = lastDailyRewardDayClaimed + 1;
                        } else {
                            recheckNextClaimableDay = -1;
                        }

                        if (dayToClaim !== recheckNextClaimableDay) {
                            showCustomPopup("Not eligible to claim this reward now.", "Claim Error");
                            renderDailyRewards();
                            return;
                        }

                        const rewardItem = dailyRewardsData.find(d => d.day === dayToClaim);
                        if (!rewardItem) return;

                        if (lastDailyRewardDayClaimed >= 30 && dayToClaim === 1) {
                            lastDailyRewardDayClaimed = dayToClaim;
                        } else {
                            lastDailyRewardDayClaimed = dayToClaim;
                        }
                        lastDailyRewardClaimTimestamp = Date.now();

                        const rewardInfoString = rewardItem.reward;
                        const rewardParts = rewardInfoString.split(',').map(s => s.trim());
                        let gainedItemsSummary = [];

                        rewardParts.forEach(part => {
                            const pvMatch = part.match(/(\d+)\s*PV/i);
                            const goldMatch = part.match(/(\d+)\s*Gold/i);
                            const diamondMatch = part.match(/(\d+)\s*Diamond/i);
                            const materialMatch = part.match(/(\d+)\s*(.+)/);

                            if (pvMatch) {
                                currentPvTokens += parseInt(pvMatch[1]);
                                gainedItemsSummary.push(pvMatch[0]);
                            } else if (goldMatch) {
                                currentGold += parseInt(goldMatch[1]);
                                gainedItemsSummary.push(goldMatch[0]);
                            } else if (diamondMatch) {
                                currentDiamonds += parseInt(diamondMatch[1]);
                                gainedItemsSummary.push(diamondMatch[0]);
                            } else if (materialMatch) {
                                const quantity = parseInt(materialMatch[1]);
                                const materialName = materialMatch[2].trim();
                                if (playerMaterials.hasOwnProperty(materialName)) {
                                    playerMaterials[materialName] = (playerMaterials[materialName] || 0) + quantity;
                                    gainedItemsSummary.push(`${quantity} ${materialName}`);
                                } else {
                                    console.warn("Unknown material in daily reward:", materialName);
                                    gainedItemsSummary.push(part);
                                }
                            } else {
                                gainedItemsSummary.push(part);
                            }
                        });

                        updateStatsDisplay();
                        renderMaterials();
                        renderDailyRewards();
                        showCustomPopup(`Claimed reward for Day ${dayToClaim}: ${gainedItemsSummary.join(', ')}`, "Daily Reward Claimed");

                        if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
                    });
                });
            }
            // INSERT THIS NEW FUNCTION (e.g., after renderDailyRewards around line 2145)

// Inside checkAndResetDailyDungeonEntries()

function checkAndResetDailyDungeonEntries() {
    const now = new Date(); // Current moment
    const nowMs = now.getTime();

    // Determine the timestamp for "today's" scheduled reset (e.g., June 5th, 21:00 UTC)
    const todayResetTime = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate(),
        DUNGEON_RESET_HOUR_UTC, // 21
        DUNGEON_RESET_MINUTE_UTC, // 0
        0, 0
    ));
    const todayResetTimeMs = todayResetTime.getTime();

    // Determine the timestamp for "yesterday's" scheduled reset (e.g., June 4th, 21:00 UTC)
    const yesterdayResetTime = new Date(todayResetTimeMs);
    yesterdayResetTime.setUTCDate(yesterdayResetTime.getUTCDate() - 1);
    const yesterdayResetTimeMs = yesterdayResetTime.getTime();

    let needsReset = false;
    let newLastResetTimestampForSaving = lastDungeonResetTimestamp; // Initialize with current value

    console.log(`[Dungeon Reset Check] Current Time: ${now.toISOString()}`);
    console.log(`  Last Recorded Reset TS: ${lastDungeonResetTimestamp ? new Date(lastDungeonResetTimestamp).toISOString() : 'None'}`);
    console.log(`  Today's Scheduled Reset TS: ${todayResetTime.toISOString()}`);

    if (!lastDungeonResetTimestamp || lastDungeonResetTimestamp === 0) {
        // Case 1: No previous reset recorded (e.g., new user, or data was cleared)
        console.log("  Condition: No lastDungeonResetTimestamp. Initializing.");
        needsReset = true;
        // Set the 'last reset' to either today's reset time (if we're past it)
        // or yesterday's reset time (if today's reset hasn't happened yet).
        // This effectively means they get their first day's entries.
        if (nowMs >= todayResetTimeMs) {
            newLastResetTimestampForSaving = todayResetTimeMs;
        } else {
            newLastResetTimestampForSaving = yesterdayResetTimeMs;
        }
        console.log(`    -> Needs Reset. New lastDungeonResetTimestamp will be: ${new Date(newLastResetTimestampForSaving).toISOString()}`);
    } else {
        // Case 2: There IS a previous reset timestamp.
        // A reset is needed if the current time is AT or AFTER today's scheduled reset time,
        // AND the last recorded reset was *before* today's scheduled reset time.
        if (nowMs >= todayResetTimeMs && lastDungeonResetTimestamp < todayResetTimeMs) {
            console.log("  Condition: Current time is past today's reset, and last reset was before today's reset time.");
            needsReset = true;
            newLastResetTimestampForSaving = todayResetTimeMs; // The reset point is today's scheduled time
            console.log(`    -> Needs Reset. New lastDungeonResetTimestamp will be: ${new Date(newLastResetTimestampForSaving).toISOString()}`);
        }
        // Case 3: What if a user logs in *after* several days of inactivity?
        // The `lastDungeonResetTimestamp` could be days old (e.g., May 31st).
        // `todayResetTimeMs` would be June 5th @ 21:00.
        // `nowMs` is June 5th (e.g., 10:00 AM).
        // In this scenario, `nowMs < todayResetTimeMs`, so the above `if` block is false.
        // We need another condition: If the last reset was before YESTERDAY's reset time, it also needs a reset
        // because they missed one or more full reset cycles.
        else if (lastDungeonResetTimestamp < yesterdayResetTimeMs) {
            console.log("  Condition: Last reset was before yesterday's scheduled reset time (missed one or more full days).");
            needsReset = true;
            // If today's reset time hasn't passed yet, the effective last reset becomes yesterday's.
            // If today's reset time HAS passed, it should have been caught by the previous `if`.
            // This branch means they definitely missed at least one full day.
            // So the new 'last reset' is yesterday's reset time, allowing them to get today's entries.
            // Or, if it's already past today's reset hour, they effectively reset *to* today's reset hour.
            if (nowMs >= todayResetTimeMs) {
                newLastResetTimestampForSaving = todayResetTimeMs;
            } else {
                newLastResetTimestampForSaving = yesterdayResetTimeMs;
            }
            console.log(`    -> Needs Reset. New lastDungeonResetTimestamp will be: ${new Date(newLastResetTimestampForSaving).toISOString()}`);
        } else {
            console.log("  Condition: No reset needed. Last reset is recent enough relative to today's/yesterday's scheduled reset.");
        }
    }

    if (needsReset) {
        console.log("  -> ACTION: Performing daily dungeon entry reset.");
        playerDungeonEntriesToday = { dungeon_1: 0, dungeon_2: 0 }; // Reset attempt counts
        lastDungeonResetTimestamp = newLastResetTimestampForSaving; // Update the global variable

        console.log(`    -> Player Dungeon Entries After Reset: D1=${playerDungeonEntriesToday.dungeon_1}, D2=${playerDungeonEntriesToday.dungeon_2}`);
        console.log(`    -> Global lastDungeonResetTimestamp updated to: ${new Date(lastDungeonResetTimestamp).toISOString()}`);

        // Update UI if the dungeon page is active
        if (document.getElementById('dungeons-page') && document.getElementById('dungeons-page').classList.contains('active')) {
            console.log("    -> Rendering Dungeons Page due to reset.");
            renderDungeonsPage();
        }
        // Save the updated game state (which includes the new lastDungeonResetTimestamp and cleared entries)
        if (currentUser && currentUser.uid) {
            console.log("    -> Saving game state to Firebase after reset.");
            saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
        }
    }

    // Always update the countdown timer display
    const dungeonResetCountdownElement = document.getElementById('dungeonResetCountdown');
    const pageDungeonResetCountdownElement = document.getElementById('dungeonPageResetCountdown');
    let nextActualResetTargetMs;
    if (nowMs < todayResetTimeMs) { // If today's reset hasn't happened yet
        nextActualResetTargetMs = todayResetTimeMs;
    } else { // Today's reset has passed, so countdown to tomorrow's
        const tomorrowResetTime = new Date(todayResetTimeMs);
        tomorrowResetTime.setUTCDate(tomorrowResetTime.getUTCDate() + 1);
        nextActualResetTargetMs = tomorrowResetTime.getTime();
    }
    const timeLeftForActualNextResetMs = nextActualResetTargetMs - nowMs;
    const formattedTime = formatTimeLeft(timeLeftForActualNextResetMs);
    const displayText = timeLeftForActualNextResetMs <=0 ? "Calculating..." : formattedTime; // Handle case if somehow still negative

    if (dungeonResetCountdownElement) dungeonResetCountdownElement.textContent = displayText;
    if (pageDungeonResetCountdownElement) pageDungeonResetCountdownElement.textContent = displayText;
}
function renderShopItems() { 
    if (!shopItemsDiv) return; 
    shopItemsDiv.innerHTML = ''; 
    shopItemsData.forEach(item => { 
        const ie = document.createElement('div'); 
        ie.classList.add('shop-item'); 

        let buyButtonDisabled = '';
        let buyButtonText = 'Buy';

        if (item.id === 'rider_scroll_unlock' && (playerHasPurchasedRiderScroll || playerInventory.some(invItem => invItem.id === 'rider_scroll_unlock'))) {
            buyButtonDisabled = 'disabled title="You have already purchased this."';
            buyButtonText = 'Owned';
        } else if (item.id === 'pet_whistle_unlock' && (playerHasPurchasedPetWhistle || playerInventory.some(invItem => invItem.id === 'pet_whistle_unlock'))) {
            buyButtonDisabled = 'disabled title="You have already purchased this."';
            buyButtonText = 'Owned';
        } else if (item.id === 'pvp_scroll_unlock' && playerHasPurchasedPvpScroll) { // PvP Scroll Check
            buyButtonDisabled = 'disabled title="You have already purchased this."';
            buyButtonText = 'Owned';
        } else if (item.id === 'upgrade_booster' && activePotions.some(p => p.id === 'upgrade_booster')) { // Upgrade Booster Check
            buyButtonDisabled = 'disabled title="An Upgrade Booster is already active."';
            buyButtonText = 'Active';
        }

        let quantityInputHtml = '';
        if (item.type === "upgrade_scroll_purchase") {
            quantityInputHtml = `<input type="number" class="quantity-selector scroll-quantity-input" data-item-id="${item.id}" min="1" max="10" value="1">`;
        }

        // Build price string with multiple currencies
        let priceHtml = '';
        if(item.price) priceHtml += `${item.price} <span class="pv">PV</span> `;
        if(item.goldPrice) priceHtml += `${item.goldPrice} <span class="gold">GOLD</span> `;
        if(item.diamondPrice) priceHtml += `${item.diamondPrice} <span class="diamond">DIAMOND</span>`;

        ie.innerHTML = `
            <div class="item-icon-placeholder">${getItemIconHTML(item.iconUrlOrColor, item.name)}</div>
            <div>
                <p><strong>${item.name}</strong></p>
                <p><small>${item.description}</small></p>
            </div>
            <div class="shop-details" style="display:flex; align-items:center;">
                ${quantityInputHtml}
                <span class="shop-price" style="margin-right:10px;">${priceHtml}</span>
                <button class="action-button buy-item-btn" data-item-id="${item.id}" ${buyButtonDisabled}>${buyButtonText}</button>
            </div>`; 
        shopItemsDiv.appendChild(ie); 
         ie.addEventListener('mousemove', (e) => showItemTooltip(e, item));
         ie.addEventListener('mouseleave', hideItemTooltip);
    }); 
    
    document.querySelectorAll('.buy-item-btn:not([disabled])').forEach(b => { 
        b.onclick = (e) => { // Switched to onclick to prevent multiple listeners
            if(!currentUser) return; 
            const itemId = e.target.dataset.itemId; 
            const itemData = shopItemsData.find(it => it.id === itemId); 
            if (!itemData) return; 

            const pvCost = itemData.price || 0;
            const goldCost = itemData.goldPrice || 0;
            const diamondCost = itemData.diamondPrice || 0;
            
            let quantity = 1;
            if (itemData.type === "upgrade_scroll_purchase") {
                const quantityInput = e.target.closest('.shop-details').querySelector(`.scroll-quantity-input`);
                if (quantityInput) quantity = parseInt(quantityInput.value) || 1;
            }
            const totalPvCost = pvCost * quantity;
            const totalGoldCost = goldCost * quantity;
            const totalDiamondCost = diamondCost * quantity;

            if (currentPvTokens >= totalPvCost && currentGold >= totalGoldCost && currentDiamonds >= totalDiamondCost) { 
                currentPvTokens -= totalPvCost; 
                currentGold -= totalGoldCost;
                currentDiamonds -= totalDiamondCost;
                updateStatsDisplay(); 
                
                showCustomPopup(`Successfully bought ${quantity > 1 ? quantity + 'x' : ''} ${itemData.name}!`, "Purchase Complete"); 
                
                if (itemData.type === "buff" && itemData.effect) { 
                    let newPotion = { 
                        id: itemData.id, 
                        name: itemData.name, 
                        description: itemData.description, 
                        effect: itemData.effect,
                        adventuresLeft: itemData.durationAdventures,
                        upgradesLeft: itemData.durationUpgrades // Added for upgrade booster
                    }; 
                    activePotions.push(newPotion); 
                    renderActivePotions(); 
                } else if (itemData.type === "upgrade_scroll_purchase" && itemData.scrollTypeKey) { 
                    playerScrolls[itemData.scrollTypeKey] = (playerScrolls[itemData.scrollTypeKey] || 0) + quantity;
                    renderMaterials(); 
                } else if (itemData.id === "rider_scroll_unlock") {
                    playerInventory.push({ id: "rider_scroll_unlock", uniqueInstanceId: `unlock_${nextUniqueInstanceId++}` });
                    playerHasPurchasedRiderScroll = true; 
                } else if (itemData.id === "pet_whistle_unlock") {
                    playerInventory.push({ id: "pet_whistle_unlock", uniqueInstanceId: `unlock_pet_${nextUniqueInstanceId++}` });
                    playerHasPurchasedPetWhistle = true;
                } else if (itemData.id === "pvp_scroll_unlock") {
                    playerHasPurchasedPvpScroll = true; // Set the flag
                }
                
                renderShopItems(); // Re-render the shop to update button states
                if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState()); 
            } else { 
                showCustomPopup(`Not enough currency to buy ${itemData.name}!`, "Transaction Failed"); 
            } 
        }; 
    }); 
}
            
             function craftItem(itemId, fromPopup = false, originalSlotIdIfEquipped = null) { 
                if(!currentUser) return false; 
                const itemToCraft = craftableItemsData.find(i => i.id === itemId); 
                if (!itemToCraft) return false; 
                
                const alreadyOwned = playerInventory.some(invItem => invItem.id === itemToCraft.id) || 
                                   Object.values(equippedItems).some(equippedInstanceId => {
                                       const eqItem = playerInventory.find(pi => pi.uniqueInstanceId === equippedInstanceId);
                                       return eqItem && eqItem.id === itemToCraft.id;
                                   });

                if (alreadyOwned && !fromPopup) { 
                    showCustomPopup(`You already own an instance of ${itemToCraft.name}. You cannot craft another unless the existing one is destroyed.`, "Crafting Failed"); 
                    return false; 
                } 
                
                let canCraft = true; 
                let missingMatDetails = ""; 
                for (const mat in itemToCraft.recipe) { 
                    if ((playerMaterials[mat] || 0) < itemToCraft.recipe[mat]) { 
                        canCraft = false; 
                        missingMatDetails += `${itemToCraft.recipe[mat]} ${mat}, `;
                    } 
                } 
                if (canCraft) { 
                    for (const mat in itemToCraft.recipe) { playerMaterials[mat] -= itemToCraft.recipe[mat]; } 
                    const newItemInstanceId = `item_${nextUniqueInstanceId++}`;
                    playerInventory.push({ id: itemToCraft.id, level: 0, uniqueInstanceId: newItemInstanceId }); 
                    
                    if (fromPopup && originalSlotIdIfEquipped) {
                        equipItem(newItemInstanceId, originalSlotIdIfEquipped); 
                        showCustomPopup(`Successfully re-crafted and equipped ${itemToCraft.name}!`, "Item Crafted & Equipped"); 
                    } else {
                        showCustomPopup(`Successfully crafted ${itemToCraft.name}!`, "Item Crafted"); 
                    }
                    
                    quests.forEach(q => { if (q.metric === "itemsCrafted" && !q.completed && !q.claimed) {q.progress = (q.progress || 0) + 1; if (q.progress >= q.target) { q.completed = true; showCustomPopup(`Quest Completed: ${q.text}`, "Quest Complete!");}} });
                    if(document.getElementById('quests-page').classList.contains('active')) renderQuests();

                    renderMaterials(); renderInventory(); renderCraftingItems(); 
                    if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
                    return true;
                } else { 
                    missingMatDetails = missingMatDetails.slice(0, -2); 
                    showCustomPopup(`Not enough materials! You need: ${missingMatDetails} to craft ${itemToCraft.name}.`, "Crafting Failed"); 
                    return false;
                } 
            }

            function promptToCraftAgain(destroyedItemMaster, originalSlotId) {
                if (!destroyedItemMaster || !destroyedItemMaster.recipe) return;

                let recipeHtml = "<ul>";
                for (const mat in destroyedItemMaster.recipe) {
                    recipeHtml += `<li>${destroyedItemMaster.recipe[mat]} ${mat} (You have: ${playerMaterials[mat] || 0})</li>`;
                }
                recipeHtml += "</ul>";

                const message = `Your ${destroyedItemMaster.name} was destroyed!<br><br>Would you like to craft it again?<br><br><strong>Requires:</strong>${recipeHtml}`;
                
                showCustomPopup(message, "Craft Item Again?", { craftCallback: () => {
                    craftItem(destroyedItemMaster.id, true, originalSlotId); 
                }});
            }

      // DELETE THE OLD equipItem FUNCTION AND PASTE THIS NEW ONE

function equipItem(itemUniqueId, specificSlotId = null) {
    if (!currentUser) return;
    const invItemToEquip = playerInventory.find(invItem => invItem.uniqueInstanceId === itemUniqueId);
    if (!invItemToEquip) {
        console.error("Item to equip not found in inventory:", itemUniqueId);
        return;
    }

    const itemData = craftableItemsData.find(i => i.id === invItemToEquip.id);
    if (!itemData || !itemData.type) {
        console.error("Cannot equip item without a type:", itemData);
        return;
    }

    let targetSlotId = specificSlotId;

    if (!targetSlotId) {
        // Find the correct slot for the item type
        if (itemData.type === "Ring") {
            if (!equippedItems.Ring1) targetSlotId = "Ring1";
            else if (secondRingSlotUnlocked && !equippedItems.Ring2) targetSlotId = "Ring2";
            else targetSlotId = "Ring1"; // Default to swapping with Ring 1 if both are full
        } else if (itemData.type === "Trinket" || itemData.type === "Rucksack" || itemData.type === "Misc") {
            if (!equippedItems.Misc1) targetSlotId = "Misc1";
            else if (!equippedItems.Misc2) targetSlotId = "Misc2";
            else targetSlotId = "Misc1"; // Default to swapping with Misc 1
        } else if (itemData.type === "Pet") {
            if (petSlotUnlocked) {
                targetSlotId = "Pet";
            } else {
                showCustomPopup("Pet slot is locked. Unlock it first.", "Equip Failed");
                return; // Stop if pet slot is locked
            }
        } else if (equippedItems.hasOwnProperty(itemData.type)) {
            targetSlotId = itemData.type;
        }
    }

    // If we have a slot, perform the equip/swap
    if (targetSlotId) {
        // Check if the item is already equipped in this exact slot
        if (equippedItems[targetSlotId] === invItemToEquip.uniqueInstanceId) {
            return; // Don't do anything if trying to equip to the same slot
        }

        // Overwrite the slot. This handles both equipping to an empty slot and swapping.
        equippedItems[targetSlotId] = invItemToEquip.uniqueInstanceId;

        // Re-render everything that needs updating
        renderInventory();
        renderActiveSpecialties();
        if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
    } else {
        showCustomPopup(`No available slot for item type: ${itemData.type}`, "Equip Failed");
    }
}

            function unequipItem(itemSlotId) { 
                if(!currentUser) return; 
                if (equippedItems.hasOwnProperty(itemSlotId) && equippedItems[itemSlotId]) { 
                    equippedItems[itemSlotId] = null; 
                    renderInventory(); 
                      renderActiveSpecialties();
                    console.log("Equipped:", equippedItems); 
                    if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
                } 
            }
            
            function generateRandomQuests() { /* Using predefined quests */ }
            
                        function completeAdventure(instanceId) {
                // ... (keep your existing completeAdventure function body here)
            }

            function completeDungeon(instanceId) {
    if (!currentUser) return;
    const dunIdx = activeDungeons.findIndex(dun => dun.id === instanceId);
    if (dunIdx === -1) return;

    const completedDun = { ...activeDungeons[dunIdx] };
    const dungeonMasterData = dungeonsData.find(d => d.id === completedDun.dungeonId);

    activeDungeons.splice(dunIdx, 1);
    recalculateTotalAvailableAdventurers();

    const poisyDaggsEquipped = Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "poisy_daggs"));
    const pvMultiplier = poisyDaggsEquipped ? 2 : 1;
    
    const dogPetEquipped = Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "pet_dog"));
    
    const echoBatEquipped = Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "pet_bat"));
    const echoBatPerk = craftableItemsData.find(item => item.id === "pet_bat")?.perk;

    let gainedCurrencySummary = [];
    let gainedItemsSummary = [];
    let gainedMaterialsForEcho = {};

    if (dungeonMasterData && dungeonMasterData.placeholderReward) {
        const rewardParts = dungeonMasterData.placeholderReward.split(',').map(s => s.trim());
        rewardParts.forEach(part => {
            const pvMatch = part.match(/(\d+)\s*PV/i);
            const goldMatch = part.match(/(\d+)\s*Gold/i);
            const diamondMatch = part.match(/(\d+)\s*Diamond/i);
            if (pvMatch) {
                const earnedPV = parseInt(pvMatch[1]) * pvMultiplier;
                currentPvTokens += earnedPV;
                gainedCurrencySummary.push(`${earnedPV} PV${poisyDaggsEquipped ? ' (x2)' : ''}`);
            } else if (goldMatch) {
                currentGold += parseInt(goldMatch[1]);
                gainedCurrencySummary.push(goldMatch[0]);
            } else if (diamondMatch) {
                currentDiamonds += parseInt(diamondMatch[1]);
                gainedCurrencySummary.push(diamondMatch[0]);
            }
        });
    }

    if (dungeonMasterData && Array.isArray(dungeonMasterData.drops)) {
        dungeonMasterData.drops.forEach(dropAttempt => {
            if (Math.random() < dropAttempt.chance) {
                const itemMaster = craftableItemsData.find(ci => ci.id === dropAttempt.id);
                if (itemMaster) { // Dropped an equippable item
                    if (!playerInventory.some(invItem => invItem.id === itemMaster.id)) {
                        playerInventory.push({ id: itemMaster.id, level: 0, uniqueInstanceId: `item_${nextUniqueInstanceId++}` });
                        gainedItemsSummary.push(`1x ${itemMaster.name}`);
                    }
                } else { // Dropped a material
                    playerMaterials[dropAttempt.name] = (playerMaterials[dropAttempt.name] || 0) + (dropAttempt.qty || 1);
                    gainedItemsSummary.push(`${dropAttempt.qty || 1}x ${dropAttempt.name}`);
                    gainedMaterialsForEcho[dropAttempt.name] = (gainedMaterialsForEcho[dropAttempt.name] || 0) + (dropAttempt.qty || 1);
                }
            }
        });
    }
    
    if (dogPetEquipped) {
        const allPossibleAdventureMaterials = Object.values(adventuresData).flatMap(adv => adv.drops ? adv.drops.map(d => d.name) : []);
        if (allPossibleAdventureMaterials.length > 0) {
            const fetchedMaterial = allPossibleAdventureMaterials[Math.floor(Math.random() * allPossibleAdventureMaterials.length)];
            if (playerMaterials.hasOwnProperty(fetchedMaterial)) {
                playerMaterials[fetchedMaterial]++;
                gainedItemsSummary.push(`$DOG fetched: 1x ${fetchedMaterial}`);
                gainedMaterialsForEcho[fetchedMaterial] = (gainedMaterialsForEcho[fetchedMaterial] || 0) + 1;
            }
        }
    }
    
    if (echoBatEquipped && echoBatPerk && echoBatPerk.dungeonId === dungeonMasterData.id && Math.random() < echoBatPerk.chance) {
        let echoSummary = [];
        Object.keys(gainedMaterialsForEcho).forEach(matName => {
            const amount = gainedMaterialsForEcho[matName];
            playerMaterials[matName] += amount;
            echoSummary.push(`${amount}x ${matName}`);
        });

        if(echoSummary.length > 0) {
            gainedItemsSummary.push(`Echo Bat duplicated: ${echoSummary.join(', ')}!`);
        }
    }

    let popupMessage = `${completedDun.name} complete!\n\nRewards:\n- ${gainedCurrencySummary.join(', ')}`;
    if (gainedItemsSummary.length > 0) {
        popupMessage += `\n\nItems Found/Fetched:\n  - ${gainedItemsSummary.join('\n  - ')}`;
    }
    showCustomPopup(popupMessage, "Dungeon Complete!");

    renderActiveTasksInSidebar();
    if (document.getElementById('dungeons-page').classList.contains('active')) renderDungeonsPage();
    if (gainedItemsSummary.length > 0) renderInventory();
    renderMaterials();
    updateStatsDisplay(); 
    if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
}
            
                      function completeAdventure(instanceId) {
                if (!currentUser) return;

                const advIdx = activeAdventures.findIndex(adv => adv.id === instanceId);

                if (advIdx === -1) {
                    console.warn(`completeAdventure: Could not find active adventure with instanceId ${instanceId}. Already completed or invalid.`);
                    if (activeAdventures.length === 0 && sidebarActiveAdventuresList) {
                        renderActiveTasksInSidebar();
                    }
                    return;
                }

                const completedAdv = { ...activeAdventures[advIdx] }; 
                activeAdventures.splice(advIdx, 1);

                try {
                    let basePvReward = completedAdv.pvReward;
                    let pvMultiplierFromPotions = 1;
                    let pvBonusAdditiveEffect = 0;

                    activePotions.forEach(p => {
                        if (p.effect && p.effect.type === "pvMultiplier" && p.adventuresLeft > 0) {
                            pvMultiplierFromPotions *= p.effect.value;
                        }
                    });

                    Object.values(equippedItems).forEach(equippedInstanceId => {
                        if (!equippedInstanceId) return;
                        const invItem = playerInventory.find(i => i.uniqueInstanceId === equippedInstanceId);
                        if (invItem) {
                            const itemMaster = craftableItemsData.find(im => im.id === invItem.id);
                            if (itemMaster && itemMaster.perk) {
                                const scaledPerk = getScaledItemPerk(itemMaster, invItem.level || 0);
                                if (scaledPerk && scaledPerk.type === "pvBonus") {
                                    pvBonusAdditiveEffect += scaledPerk.value;
                                }
                            }
                        }
                    });

                    let earnedPvThisTrip = Math.floor(basePvReward * completedAdv.adventurers * (1 + pvBonusAdditiveEffect) * pvMultiplierFromPotions);
                    currentPvTokens += earnedPvThisTrip;

                    let totalGoldFoundThisTrip = 0;
                    let totalDiamondsFoundThisTrip = 0;
                    let allFoundDrops = {};

                    let totalGoldChanceIncreaseBonus = 0;
                    let flatGoldBonusFromPotions = 0;
                    let flatGoldBonusFromItems = 0;
                    let flatDiamondBonusFromItems = 0;
                    let materialChanceEffectiveMultiplier = 1;

                    activePotions.forEach(p => {
                        if (p.effect && p.effect.type === "goldChanceBonus" && p.adventuresLeft > 0) {
                            flatGoldBonusFromPotions += p.effect.flatValue || 0;
                        }
                    });

                    Object.values(equippedItems).forEach(equippedInstanceId => {
                        if (!equippedInstanceId) return;
                        const invItem = playerInventory.find(i => i.uniqueInstanceId === equippedInstanceId);
                        if (invItem) {
                            const itemMaster = craftableItemsData.find(im => im.id === invItem.id);
                            if (itemMaster && itemMaster.perk) {
                                const scaledPerk = getScaledItemPerk(itemMaster, invItem.level || 0);
                                if (scaledPerk) {
                                    if (scaledPerk.type === "goldChanceIncrease") totalGoldChanceIncreaseBonus += scaledPerk.value;
                                    if (scaledPerk.type === "flatCurrencyChanceBoost") {
                                        flatGoldBonusFromItems += (scaledPerk.goldBonus || 0);
                                        flatDiamondBonusFromItems += (scaledPerk.diamondBonus || 0);
                                    }
                                    if (scaledPerk.type === "materialChanceMultiplier") materialChanceEffectiveMultiplier *= scaledPerk.value;
                                }
                            }
                        }
                    });

                    const adventureMasterData = adventuresData[completedAdv.originalAdventureId];

                    if (adventureMasterData && adventureMasterData.guaranteedGold) {
                        const guaranteedGoldAmount = adventureMasterData.guaranteedGold * completedAdv.adventurers;
                        currentGold += guaranteedGoldAmount;
                        totalGoldFoundThisTrip += guaranteedGoldAmount;
                    }

                    for (let i = 0; i < completedAdv.adventurers; i++) {
                        if (!adventureMasterData || !adventureMasterData.guaranteedGold || (adventureMasterData.guaranteedGold && completedAdv.goldChance > 0)) {
                            const finalGoldChance = (completedAdv.goldChance * (1 + totalGoldChanceIncreaseBonus)) + flatGoldBonusFromPotions + flatGoldBonusFromItems;
                            if (completedAdv.goldChance > 0 && Math.random() < finalGoldChance) {
                                currentGold += 1;
                                totalGoldFoundThisTrip += 1;
                            }
                        }

                        const finalDiamondChance = completedAdv.diamondChance + flatDiamondBonusFromItems;
                        if (completedAdv.diamondChance > 0 && Math.random() < finalDiamondChance) {
                            let diamondsAwarded = 1;
                            if (adventureMasterData && adventureMasterData.diamondRewardMultiplier) {
                                diamondsAwarded = adventureMasterData.diamondRewardMultiplier;
                            }
                            currentDiamonds += diamondsAwarded;
                            totalDiamondsFoundThisTrip += diamondsAwarded;
                        }

                        if (adventureMasterData && adventureMasterData.drops) {
                            adventureMasterData.drops.forEach(drop => {
                                if (Math.random() < (drop.chance * materialChanceEffectiveMultiplier)) {
                                    if (playerMaterials.hasOwnProperty(drop.name)) {
                                        playerMaterials[drop.name] = (playerMaterials[drop.name] || 0) + (drop.qty || 1);
                                        allFoundDrops[drop.name] = (allFoundDrops[drop.name] || 0) + (drop.qty || 1);
                                        quests.forEach(q => {
                                            if (q.metric === `materialCollected_${drop.name}` && !q.completed && !q.claimed) {
                                                q.progress = (q.progress || 0) + (drop.qty || 1);
                                                if (q.progress >= q.target) {
                                                    q.completed = true;
                                                    if (!q.claimed) showCustomPopup(`Quest Completed: ${q.text}`, "Quest Complete!");
                                                }
                                            }
                                        });
                                    } else {
                                        const itemMasterInfo = craftableItemsData.find(ci => ci.id === drop.name);
                                        if (itemMasterInfo) {
                                            const itemExistsInInv = playerInventory.some(invItem => invItem.id === itemMasterInfo.id) ||
                                                Object.values(equippedItems).some(eqId => {
                                                    if (!eqId) return false;
                                                    const eqInvItem = playerInventory.find(pi => pi.uniqueInstanceId === eqId);
                                                    return eqInvItem && eqInvItem.id === itemMasterInfo.id;
                                                });
                                            if (!itemExistsInInv) {
                                                playerInventory.push({ id: itemMasterInfo.id, level: 0, uniqueInstanceId: `item_${nextUniqueInstanceId++}` });
                                                allFoundDrops[itemMasterInfo.name] = (allFoundDrops[itemMasterInfo.name] || 0) + (drop.qty || 1);
                                            }
                                        } else {
                                            console.warn("Unknown item drop defined in adventuresData that is not a material:", drop.name);
                                        }
                                    }
                                }
                            });
                        }
                    }

                    // --- MILESTONE REWARD LOGIC ---
                    const oldTotal = totalAdventuresCompleted;
                    totalAdventuresCompleted += completedAdv.adventurers; // Count each adventurer
                    const oldMilestoneCount = Math.floor(oldTotal / 100);
                    const newMilestoneCount = Math.floor(totalAdventuresCompleted / 100);
                    const milestonesCrossed = newMilestoneCount - oldMilestoneCount;
                    // --- END MILESTONE REWARD LOGIC ---

                    activePotions.forEach(p => {
                        if (p.adventuresLeft !== undefined && p.adventuresLeft > 0) {
                            if ((p.effect.type === "pvMultiplier" && pvMultiplierFromPotions > 1) ||
                                (p.effect.type === "goldChanceBonus" && flatGoldBonusFromPotions > 0)) {
                                p.adventuresLeft--;
                            }
                        }
                    });
                    activePotions = activePotions.filter(p => (p.endTime && Date.now() < p.endTime) || (p.adventuresLeft !== undefined && p.adventuresLeft > 0));

                    recalculateTotalAvailableAdventurers();

                    let popupMessage = `${completedAdv.adventurers} adventurer(s) returned from ${completedAdv.name}!\n\nRewards:\n- ${earnedPvThisTrip} PV Tokens`;
                    if (totalGoldFoundThisTrip > 0) { popupMessage += `\n- ${totalGoldFoundThisTrip} Gold`; }
                    if (totalDiamondsFoundThisTrip > 0) { popupMessage += `\n- ${totalDiamondsFoundThisTrip} Diamond(s)`; }
                    const foundDropNames = Object.keys(allFoundDrops);
                    if (foundDropNames.length > 0) {
                        popupMessage += `\n\nMaterials/Items Found:`;
                        foundDropNames.forEach(dropNameKey => {
                            popupMessage += `\n  - ${allFoundDrops[dropNameKey]}x ${dropNameKey}`;
                        });
                    }
                    
                    if (milestonesCrossed > 0) {
                        const milestoneGold = 50 * milestonesCrossed;
                        const milestoneDiamonds = 1 * milestonesCrossed;
                        currentGold += milestoneGold;
                        currentDiamonds += milestoneDiamonds;
                        popupMessage += `\n\n**Milestone!** You crossed the ${newMilestoneCount * 100} adventure mark! +${milestoneGold} Gold, +${milestoneDiamonds} Diamond(s)!`;
                    }
                    showCustomPopup(popupMessage, "Adventure Complete!");

                    // Quest Updates...
                    quests.forEach(quest => { 
                        if (!quest.completed && !quest.claimed) {
                            let progressChanged = false;
                            if (quest.adventureName === completedAdv.name) { quest.progress = (quest.progress || 0) + completedAdv.adventurers; progressChanged = true; }
                            if (quest.metric === "pvBalance") { quest.progress = currentPvTokens; progressChanged = true; }
                            if (quest.metric === "totalAdventuresCompletedOverall") { quest.progress = totalAdventuresCompleted; progressChanged = true; }
                            if (quest.metric === "goldFoundAdventures") { quest.progress = (quest.progress || 0) + totalGoldFoundThisTrip; progressChanged = true; }

                            if (quest.metric === "equippedTier1Set") {
                                const bootsEquipped = Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "boots1"));
                                const rucksackEquipped = Object.values(equippedItems).some(id => id && playerInventory.find(i => i.uniqueInstanceId === id && i.id === "rucksack1"));
                                quest.progress = (bootsEquipped ? 1 : 0) + (rucksackEquipped ? 1 : 0); progressChanged = true;
                            }
                            if (quest.metric === "attackPower") {
                                let currentAttack = 0;
                                Object.values(equippedItems).forEach(eqId => {
                                    if (!eqId) return;
                                    const invI = playerInventory.find(i => i.uniqueInstanceId === eqId);
                                    if (invI) {
                                        const mI = craftableItemsData.find(mi => mi.id === invI.id);
                                        if (mI && mI.perk) {
                                            const scaledPerk = getScaledItemPerk(mI, invI.level || 0);
                                            if (scaledPerk.type === "attackBoost") currentAttack += scaledPerk.value;
                                            if (scaledPerk.type === "statBoost" && scaledPerk.attack) currentAttack += scaledPerk.attack;
                                        }
                                    }
                                });
                                quest.progress = currentAttack; progressChanged = true;
                            }

                            if (progressChanged && quest.progress >= quest.target && !quest.completed) {
                                quest.completed = true;
                                if (!quest.claimed) showCustomPopup(`Quest Completed: ${quest.text}`, "Quest Complete!");
                                if ([1, 2, 3, 15].includes(quest.id)) { updateAdventureDisplayStates(); }
                            }
                        }
                    });

                    renderActivePotions();
                    updateAdventureDisplayStates();
                    renderMaterials();
                    if (foundDropNames.some(name => craftableItemsData.find(ci => ci.name === name))) {
                        renderInventory();
                    }
                } catch (error) {
                    console.error(`Error during reward processing for adventure ${completedAdv.name} (ID: ${instanceId}):`, error);
                    showCustomPopup(`An error occurred processing rewards for ${completedAdv.name}. Some rewards may have been missed. The adventure has been removed from the active list.`, "Reward Processing Error");
                    recalculateTotalAvailableAdventurers();
                } finally {
                    renderActiveTasksInSidebar();
                    updateStatsDisplay();

                    if (currentUser && currentUser.uid) {
                        saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
                    }
                }
            }
            
function updateAdventureDisplayStates() {
    adventureProgressionConfig.forEach(advConfig => {
        const adventureBlock = document.getElementById(advConfig.blockId);
        if (!adventureBlock) return;

        const sendBtnElement = adventureBlock.querySelector('.adventure-send-btn');
        const numInput = adventureBlock.querySelector('.adventure-num-select'); // Changed variable name
        const lockOverlay = adventureBlock.querySelector('.adventure-lock-overlay');

        let isLockedByProgression = false;
        if (advConfig.unlockQuestId) {
            const unlockingQuest = quests.find(q => q.id === advConfig.unlockQuestId);
            if (!unlockingQuest || !unlockingQuest.completed) {
                isLockedByProgression = true;
            }
        }
        const existingActiveAdventure = activeAdventures.find(adv => adv.originalAdventureId === advConfig.id);

        if (sendBtnElement) {
            if (existingActiveAdventure) {
                sendBtnElement.textContent = "ADD MORE (+)";
                // Can add if player has adventurers AND input is not disabled by lock
                sendBtnElement.disabled = totalAvailableAdventurers <= 0 || (isLockedByProgression && !existingActiveAdventure);
            } else {
                sendBtnElement.textContent = "SEND";
                sendBtnElement.disabled = isLockedByProgression;
            }
        }

        if (numInput) {
            numInput.disabled = isLockedByProgression && !existingActiveAdventure;
            numInput.max = totalAvailableAdventurers; // Set max based on currently available

            // If current value exceeds new max, reset it (optional, but good UX)
            if (parseInt(numInput.value) > totalAvailableAdventurers && totalAvailableAdventurers > 0) {
                numInput.value = totalAvailableAdventurers;
            } else if (totalAvailableAdventurers === 0 && parseInt(numInput.value) > 0) {
                numInput.value = 0; // Or 1 if you want to always default to 1 if possible
            } else if (parseInt(numInput.value) < 1 && totalAvailableAdventurers > 0) {
                 numInput.value = 1; // Ensure it's at least 1 if adventurers are available
            }
             // Ensure value is not less than min (1) if it was somehow set lower
            if (parseInt(numInput.value) < parseInt(numInput.min)) {
                numInput.value = numInput.min;
            }

        }

        adventureBlock.classList.toggle('locked-by-progression', isLockedByProgression && !existingActiveAdventure);

        if (lockOverlay) {
            if (isLockedByProgression && !existingActiveAdventure) {
                lockOverlay.textContent = advConfig.unlockMessage;
                lockOverlay.classList.remove('hidden');
            } else {
                lockOverlay.classList.add('hidden');
            }
        }
    });
}
            
            function handleCancelAdventure(adventureInstanceId) {
                if (!currentUser) return;
                const adventureToCancel = activeAdventures.find(adv => adv.id === adventureInstanceId);
                if (!adventureToCancel) return;

                showCustomPopup(
                    `Are you sure you want to cancel the adventure "${adventureToCancel.name}"? Your ${adventureToCancel.adventurers} adventurer(s) will return immediately, but you will receive no rewards.`,
                    "Confirm Cancel Adventure",
                    { 
                            confirmCallback: (confirmed) => {
                                if (confirmed) {
                                    const adventureToCancel = activeAdventures.find(adv => adv.id === adventureInstanceId); // Good to re-find it just in case
                                    if (!adventureToCancel) return; // Safety check if it was already removed

                                    // Step 1: Update the activeAdventures list by removing the cancelled one
                                    activeAdventures = activeAdventures.filter(adv => adv.id !== adventureInstanceId);
                                    
                                    // Step 2: Now that activeAdventures is updated, recalculate the available count
                                    recalculateTotalAvailableAdventurers();
                                    // The line 'totalAvailableAdventurers += adventureToCancel.adventurers;' has been REMOVED.

                                    showCustomPopup(`Adventure "${adventureToCancel.name}" has been cancelled. Adventurers have returned.`, "Adventure Cancelled");
                                    updateStatsDisplay();
                                    renderActiveTasksInSidebar();
                                    updateAdventureDisplayStates();
                                    if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
                                }
                            }
                    }
                );
            }


            function updateTimers() {
                // console.log("updateTimers is running - top"); // You can uncomment this for debugging
                let taskCompletedThisTick = false;
                const nowMs = Date.now(); // Get current time once per tick in milliseconds
                const nowDateObj = new Date(nowMs); // Get current Date object from the timestamp

                // --- Process Active Adventures (iterate backwards for safe removal) ---
                for (let i = activeAdventures.length - 1; i >= 0; i--) {
                    const adv = activeAdventures[i];
                    const timeLeftMs = adv.returnTime - nowMs;
                    
                    const adventureTimerElements = document.querySelectorAll(`.active-adventure-item[data-instance-id="${adv.id}"] .timer`);
                    adventureTimerElements.forEach(timerSpan => {
                        if (timerSpan) timerSpan.textContent = formatTimeLeft(timeLeftMs);
                    });

                    if (timeLeftMs <= 0) {
                        console.log(`Timer: Adventure ${adv.name} (ID: ${adv.id}) ended. Calling completeAdventure.`);
                        completeAdventure(adv.id); 
                        taskCompletedThisTick = true;
                    }
                }

                // --- Process Active Dungeons (iterate backwards for safe removal) ---
                for (let i = activeDungeons.length - 1; i >= 0; i--) {
                    const dun = activeDungeons[i];
                    const timeLeftMs = dun.returnTime - nowMs;

                    const dungeonTimerElements = document.querySelectorAll(`.active-adventure-item[data-instance-id="${dun.id}"] .timer`);
                     dungeonTimerElements.forEach(timerSpan => {
                        if (timerSpan) timerSpan.textContent = formatTimeLeft(timeLeftMs);
                    });

                    if (timeLeftMs <= 0) {
                        console.log(`Timer: Dungeon ${dun.name} (ID: ${dun.id}) ended. Calling completeDungeon.`);
                        completeDungeon(dun.id); 
                        taskCompletedThisTick = true;
                    }
                }

                if (taskCompletedThisTick) {
                    console.log("Task completed this tick, re-rendering active tasks sidebar.");
                    renderActiveTasksInSidebar(); 
                }

                // --- Process Active Potions ---
                let potionsChanged = false;
                activePotions.forEach(potion => { 
                    if (potion.endTime) {
                        if (nowMs >= potion.endTime) potionsChanged = true;
                        // Attempt to find the specific potion div to update its timer
                        const potionItemDiv = activePotionsList ? Array.from(activePotionsList.children).find(child => child.innerHTML.includes(`<strong>${potion.name}</strong>`)) : null;
                        if (potionItemDiv) {
                            const timerSpan = potionItemDiv.querySelector('.timer');
                            if (timerSpan) timerSpan.textContent = formatTimeLeft(potion.endTime - nowMs);
                        }
                    }
                });
                if (potionsChanged) {
                    activePotions = activePotions.filter(p => p.endTime ? p.endTime > nowMs : true);
                    activePotions = activePotions.filter(p => p.adventuresLeft === undefined || p.adventuresLeft > 0);
                    renderActivePotions();
                }

                // --- Process Raffles ---
                 let rafflesUpdatedByTimer = false;
                 allRaffles.forEach(raffle => { 
                     if (raffle.status === 'active') {
                         const timeLeftMs = raffle.endTime - nowMs;
                         const raffleCard = whitelistRafflesContainer ? whitelistRafflesContainer.querySelector(`.raffle-card[data-raffle-id="${raffle.id}"]`) : null;
                         if (raffleCard) {
                              const timerSpan = raffleCard.querySelector('.raffle-timer');
                              if (timerSpan) timerSpan.textContent = formatTimeLeft(timeLeftMs);
                         }
                         if (timeLeftMs <= 0) {
                             raffle.status = 'ended'; 
                             rafflesUpdatedByTimer = true;
                         }
                     }
                 });
                 if (rafflesUpdatedByTimer && document.getElementById('whitelist-page') && document.getElementById('whitelist-page').classList.contains('active')) {
                     renderWhitelistRaffles();
                 }

                // +++ DUNGEON RESET COUNTDOWN TIMER +++
                // Get the countdown element from the sidebar (this was the original one)
                const sidebarDungeonResetCountdownElement = document.getElementById('dungeonResetCountdown');
                // Get the new countdown element from the Dungeons page
                const pageDungeonResetCountdownElement = document.getElementById('dungeonPageResetCountdown');

                // We only need to calculate the time once
                const currentInstant = nowDateObj; // From top of updateTimers
                const currentMs = currentInstant.getTime(); // From top of updateTimers

                const currentUTCFullYear = currentInstant.getUTCFullYear();
                const currentUTCMonth = currentInstant.getUTCMonth();
                const currentUTCDate = currentInstant.getUTCDate();

                let nextScheduledResetObject = new Date(Date.UTC(
                    currentUTCFullYear,
                    currentUTCMonth,
                    currentUTCDate,
                    DUNGEON_RESET_HOUR_UTC,
                    DUNGEON_RESET_MINUTE_UTC,
                    0, 0
                ));
                let nextScheduledResetMs = nextScheduledResetObject.getTime();

                // If the current time is already AT or PAST today's scheduled reset time,
                // then the next reset we are counting down to is TOMORROW's scheduled reset time.
                if (currentMs >= nextScheduledResetMs) {
                    // Create a new Date object for modification to avoid issues
                    nextScheduledResetObject = new Date(nextScheduledResetMs); 
                    nextScheduledResetObject.setUTCDate(nextScheduledResetObject.getUTCDate() + 1);
                    nextScheduledResetMs = nextScheduledResetObject.getTime();
                }

                const timeLeftForResetMs = nextScheduledResetMs - currentMs;
                const formattedTime = formatTimeLeft(timeLeftForResetMs);
                const isResetting = timeLeftForResetMs <= 0;
                const displayText = isResetting ? "Resetting..." : formattedTime;

                // Update sidebar countdown if it exists
                if (sidebarDungeonResetCountdownElement) {
                    sidebarDungeonResetCountdownElement.textContent = displayText;
                }

                // Update Dungeons page countdown if it exists
                if (pageDungeonResetCountdownElement) {
                    pageDungeonResetCountdownElement.textContent = displayText;
                }
                
                // Trigger the actual reset logic if time is up
                if (isResetting) {
                    // Your console.log(logMessage) for debugging can be re-added here if needed,
                    // just define logMessage using the variables above.
                    if (typeof checkAndResetDailyDungeonEntries === 'function') {
                        checkAndResetDailyDungeonEntries();
                    }
                }
                // +++ END OF DUNGEON RESET COUNTDOWN TIMER LOGIC +++
            }
            
            adventureSendButtons.forEach(button => {
    button.addEventListener('click', () => {
        if (!currentUser) return;
        
        // Simplified requirements check
        const adventureIdBase = button.dataset.adventureId;
        const numAdventurersToSend = parseInt(document.getElementById(`num-adventurers-${adventureIdBase}`).value);
        if (numAdventurersToSend <= 0 || numAdventurersToSend > totalAvailableAdventurers) {
            showCustomPopup(`Invalid number of adventurers selected.`, "Action Needed");
            return;
        }

        const adventureName = button.dataset.adventureName;
        const originalDurationHours = parseInt(button.dataset.durationHours);
        const pvReward = parseInt(button.dataset.pvReward) * 2;
        const goldChance = parseFloat(button.dataset.goldChance);
        const diamondChance = parseFloat(button.dataset.diamondChance) || 0;
        const requiredAdventurers = parseInt(button.dataset.adventurerRequirement) || 0;

        if (numAdventurersToSend < requiredAdventurers) {
            showCustomPopup(`This adventure requires at least ${requiredAdventurers} adventurers.`, "Requirements Not Met");
            return;
        }
        
        // --- TIME CALCULATION (FIXED) ---
        let baseDurationMs = originalDurationHours * GAME_HOUR_IN_REAL_SECONDS * 1000;
        let flatReductionSeconds = 0;
        let percentReduction = 0;

        Object.values(equippedItems).forEach(equippedInstanceId => {
            if (!equippedInstanceId) return;
            const invItem = playerInventory.find(i => i.uniqueInstanceId === equippedInstanceId);
            if (invItem) {
                const itemMaster = craftableItemsData.find(im => im.id === invItem.id);
                if (itemMaster && itemMaster.perk) {
                    const scaledPerk = getScaledItemPerk(itemMaster, invItem.level || 0);
                    if (scaledPerk.type === "timeReduction") flatReductionSeconds += scaledPerk.value;
                    if (scaledPerk.type === "timeReductionPercent") percentReduction += scaledPerk.value;
                    if (scaledPerk.type === "timeReductionHybrid") {
                        flatReductionSeconds += scaledPerk.flat;
                        percentReduction += scaledPerk.percent;
                    }
                }
            }
        });
        
        const flatReductionMs = (flatReductionSeconds / 3600) * (GAME_HOUR_IN_REAL_SECONDS * 1000);
        let calculatedDurationMs = (baseDurationMs * (1 - percentReduction)) - flatReductionMs;
        calculatedDurationMs = Math.max(1000, calculatedDurationMs); // Ensure time is at least 1 second
        const returnTime = Date.now() + calculatedDurationMs;
        // --- END TIME CALCULATION ---

        const existingActiveAdventure = activeAdventures.find(adv => adv.originalAdventureId === adventureIdBase);

        if (existingActiveAdventure) { // Adding more
            showCustomPopup(`Adding ${numAdventurersToSend} to "${adventureName}" will reset its timer. Continue?`, "Confirm Add", {
                confirmCallback: (confirmed) => {
                    if (confirmed) {
                        existingActiveAdventure.adventurers += numAdventurersToSend;
                        existingActiveAdventure.returnTime = returnTime; // Use newly calculated time
                        recalculateTotalAvailableAdventurers();
                        renderActiveTasksInSidebar();
                        updateAdventureDisplayStates();
                        if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
                    }
                }
            });
        } else { // Starting new
            const newActiveAdventure = {
                id: nextActiveAdventureId++,
                originalAdventureId: adventureIdBase,
                name: adventureName,
                adventurers: numAdventurersToSend,
                returnTime: returnTime,
                pvReward: pvReward,
                goldChance: goldChance,
                diamondChance: diamondChance
            };
            activeAdventures.push(newActiveAdventure);
            recalculateTotalAvailableAdventurers();
            renderActiveTasksInSidebar();
            updateAdventureDisplayStates();
            if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
        }
    });
});
            // --- Currency Swap Logic ---
            function updateSwapDisplay() {
                if (!swapInfoDisplay || !swapBtn || !reverseSwapDirectionBtn) return;
                if (isGoldToDiamondSwap) {
                    swapInfoDisplay.innerHTML = `10 <span class="gold">GOLD</span> = 1 <span class="diamond">DIAMOND</span>`; // Changed 100 to 10
                    swapBtn.textContent = "Swap Gold for Diamond";
                } else {
                    swapInfoDisplay.innerHTML = `1 <span class="diamond">DIAMOND</span> = 10 <span class="gold">GOLD</span>`; // Changed 100 to 10
                    swapBtn.textContent = "Swap Diamond for Gold";
                }
            }

            if (reverseSwapDirectionBtn) {
                reverseSwapDirectionBtn.addEventListener('click', () => {
                    isGoldToDiamondSwap = !isGoldToDiamondSwap;
                    updateSwapDisplay();
                });
            }

            if (swapBtn) {
                swapBtn.addEventListener('click', () => {
                    if (!currentUser) return;
                    let costGold = 0, rewardDiamond = 0, costDiamond = 0, rewardGold = 0;
                    let message = "";

                    if (isGoldToDiamondSwap) {
                        costGold = 10; // Changed 100 to 10
                        rewardDiamond = 1;
                        if (currentGold >= costGold) {
                            currentGold -= costGold;
                            currentDiamonds += rewardDiamond;
                            message = `Swapped ${costGold} Gold for ${rewardDiamond} Diamond!`;
                        } else {
                            showCustomPopup(`Not enough Gold! You need ${costGold} Gold.`, "Swap Failed");
                            return;
                        }
                    } else { // Diamond to Gold
                        costDiamond = 1;
                        rewardGold = 10; // Changed 100 to 10
                        if (currentDiamonds >= costDiamond) {
                            currentDiamonds -= costDiamond;
                            currentGold += rewardGold;
                            message = `Swapped ${costDiamond} Diamond for ${rewardGold} Gold!`;
                        } else {
                            showCustomPopup(`Not enough Diamonds! You need ${costDiamond} Diamond.`, "Swap Failed");
                            return;
                        }
                    }
                    updateStatsDisplay();
                    showCustomPopup(message, "Swap Successful");
                    if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
                });
            }
            updateSwapDisplay(); // Initialize display on load


            // --- Whitelist Raffle Logic ---
            async function fetchAndDisplayRaffles() {
                if (!db) { console.error("Firestore not initialized for fetching raffles."); allRaffles = []; renderWhitelistRaffles(); return; }
                const rafflesCol = collection(db, "raffles");
                const q_raffles = query(rafflesCol, where("status", "in", ["active", "ended", "drawing_winners", "winners_announced"]), orderBy("endTime", "desc"));
                try {
                    const querySnapshot = await getDocs(q_raffles); const fetchedRaffles = [];
                    for (const docSnap of querySnapshot.docs) { 
                        const raffleData = docSnap.data();
                        fetchedRaffles.push({ id: docSnap.id, ...raffleData, startTime: raffleData.startTime.toDate().getTime(), endTime: raffleData.endTime.toDate().getTime() });
                    }
                    allRaffles = fetchedRaffles; renderWhitelistRaffles(); console.log("Fetched raffles from Firestore:", allRaffles);
                } catch (error) { console.error("Error fetching raffles: ", error); showCustomPopup("Could not load raffles. Check console (missing index or rules?).", "Raffle Error"); allRaffles = []; renderWhitelistRaffles(); }
            }
            if (createRaffleForm) {
                createRaffleForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (!db || !currentUser || !currentUser.uid || !ADMIN_WALLET_ADDRESSES.includes(currentUser.uid.toLowerCase())) {
                        showCustomPopup("Admin action failed. You do not have permission.", "Admin Error");
                        return;
                    }
                    const name = document.getElementById('raffleName').value;
                                        const description = document.getElementById('raffleDescription').value;
                    const imageUrl = document.getElementById('raffleImageUrl').value || ''; // Allow empty string if not provided
                    const socialX = document.getElementById('raffleSocialX').value;
                    const socialDiscord = document.getElementById('raffleSocialDiscord').value;
                    const costPV = parseInt(document.getElementById('raffleCostPV').value) || 0;
                    const costGold = parseInt(document.getElementById('raffleCostGold').value) || 0;
                    const costDiamonds = parseInt(document.getElementById('raffleCostDiamonds').value) || 0;
                    const durationHours = parseInt(document.getElementById('raffleDurationHours').value) || 24;
                    const maxWinners = parseInt(document.getElementById('raffleMaxWinners').value) || 1;
                    // ... (get other form values) ...
                                        const nowMs = Date.now();
                    const newRaffleData = {
                        name,
                        description, // assuming you get these from form
                        imageUrl,
                        socials: { x: socialX, discord: socialDiscord },
                        entryCost: { pv: costPV, gold: costGold, diamonds: costDiamonds },
                        durationHours,
                        maxWinners,
                        startTime: Timestamp.fromDate(new Date(nowMs)), // ensure nowMs is defined
                        endTime: Timestamp.fromDate(new Date(nowMs + durationHours * GAME_HOUR_IN_REAL_SECONDS * 1000)),
                        status: 'active',
                        creatorWallet: currentUser.uid, // <<< CHANGED FROM createdByEmail
                        createdAt: Timestamp.now(),
                        winners: [],
                        entryCount: 0
                    };
                    try {
                        const newRaffleRef = await addDoc(collection(db, "raffles"), newRaffleData);
                        showCustomPopup(`Raffle "${name}" created!`, "Admin Action");
                        createRaffleForm.reset();
                        await fetchAndDisplayRaffles();
                    } catch (error) {
                        console.error("Error creating raffle: ", error);
                        showCustomPopup("Failed to create raffle. Firestore rules might be blocking.", "Admin Error");
                    }
                });
            }
                                              async function renderWhitelistRaffles() {
                if (!whitelistRafflesContainer) return;
                whitelistRafflesContainer.innerHTML = '';
                if (allRaffles.length === 0) {
                    whitelistRafflesContainer.innerHTML = '<p style="text-align:center;">No active raffles.</p>';
                    return;
                }
                allRaffles.sort((a, b) => b.startTime - a.startTime);

                const formatWinnerAddress = (addr) => {
                    if (addr && addr.length > 10) {
                        return `<span style="font-size:0.85em; opacity:0.8;">(${addr.substring(0, 6)}...${addr.substring(addr.length - 4)})</span>`;
                    }
                    return addr ? `(${addr})` : '';
                };

                for (const raffle of allRaffles) {
                    const card = document.createElement('div');
                    card.className = 'raffle-card';
                    card.dataset.raffleId = raffle.id;
                    const timeLeftMs = raffle.endTime - Date.now();

                    // --- COST CALCULATION LOGIC ---
                    // Base cost display
                    let baseCostHtml = '';
                    if (raffle.entryCost.pv > 0) baseCostHtml += `${raffle.entryCost.pv} <span class="pv">PV</span> `;
                    if (raffle.entryCost.gold > 0) baseCostHtml += `${raffle.entryCost.gold} <span class="gold">GOLD</span> `;
                    if (raffle.entryCost.diamonds > 0) baseCostHtml += `${raffle.entryCost.diamonds} <span class="diamond">DIAMONDS</span>`;
                    if (baseCostHtml === '') baseCostHtml = 'Free Entry';
                    else baseCostHtml = 'Base Cost: ' + baseCostHtml;

                    // User's next entry cost display
                    const userEntryCount = (currentUser && playerRaffleEntries && playerRaffleEntries[raffle.id]) || 0;
                    const nextEntryCostMultiplier = userEntryCount + 1;
                    let nextCostHtml = '';
                    if (raffle.entryCost.pv > 0) nextCostHtml += `${raffle.entryCost.pv * nextEntryCostMultiplier} <span class="pv">PV</span> `;
                    if (raffle.entryCost.gold > 0) nextCostHtml += `${raffle.entryCost.gold * nextEntryCostMultiplier} <span class="gold">GOLD</span> `;
                    if (raffle.entryCost.diamonds > 0) nextCostHtml += `${raffle.entryCost.diamonds * nextEntryCostMultiplier} <span class="diamond">DIAMONDS</span>`;
                    if (nextCostHtml === '') nextCostHtml = 'Free';
                    // --- END COST CALCULATION ---

                    let adminActionsHtml = '';
                    if (currentUser && currentUser.uid && ADMIN_WALLET_ADDRESSES.includes(currentUser.uid.toLowerCase())) {
                        adminActionsHtml += `<button class="action-button raffle-action-btn delete-raffle-btn" data-raffle-id="${raffle.id}">Delete</button>`;
                        if (raffle.status === 'active' && timeLeftMs > 0) {
                            adminActionsHtml += `<button class="action-button raffle-action-btn draw-now-btn" data-raffle-id="${raffle.id}">Draw Now</button>`;
                        } else if ((raffle.status === 'ended' || (raffle.status === 'active' && timeLeftMs <= 0)) && (!raffle.winners || raffle.winners.length === 0)) {
                            adminActionsHtml += `<button class="action-button raffle-action-btn draw-winners-btn" data-raffle-id="${raffle.id}">Draw Winners</button>`;
                        }
                    }
                    
                    let winnersHtml = '';
                    if (raffle.winners && raffle.winners.length > 0) {
                        const winnerListItems = raffle.winners.map(winner => {
                            if (typeof winner === 'object' && winner !== null && winner.nickname) {
                                return `<li>${winner.nickname} ${formatWinnerAddress(winner.address)}</li>`;
                            } else if (typeof winner === 'string') {
                                return `<li>${winner}</li>`;
                            }
                            return `<li>Winner</li>`;
                        }).join('');
                        winnersHtml = `<div><strong>Winners (${raffle.winners.length}/${raffle.maxWinners}):</strong><ul>${winnerListItems}</ul></div>`;
                    }

                    // Information for the user about their entries
                    let userEntryInfoHtml = '';
                    if (userEntryCount > 0) {
                        userEntryInfoHtml = `<p><strong>You have entered ${userEntryCount} time(s)!</strong></p>`;
                    }

                    card.innerHTML = `
                        <div class="raffle-card-image ${raffle.imageUrl ? '' : 'placeholder'}" style="${raffle.imageUrl ? 'background-image: url(' + raffle.imageUrl + ');' : ''}">
                            ${!raffle.imageUrl ? 'No Image' : ''}
                        </div>
                        <div class="raffle-card-content">
                            <h4>${raffle.name}</h4>
                            <p class="raffle-card-description">${raffle.description}</p>
                            <div class="raffle-card-socials">
                                ${raffle.socials.x ? `<a href="${raffle.socials.x}" target="_blank">Project X</a>` : ''}
                                ${raffle.socials.discord ? `<a href="${raffle.socials.discord}" target="_blank">Project Discord</a>` : ''}
                            </div>
                            <p class="raffle-card-cost">${baseCostHtml}</p>
                            <p class="raffle-card-status">Status: ${raffle.status.replace('_', ' ')}</p>
                            <p>Time Left: <span class="raffle-timer">${timeLeftMs > 0 ? formatTimeLeft(timeLeftMs) : 'Ended'}</span></p>
                            <p>Total Tickets: ${raffle.entryCount || 0}</p>
                            ${userEntryInfoHtml}
                            ${currentUser && raffle.status === 'active' && timeLeftMs > 0 ? `
                                <p style="font-size:0.9em; margin-bottom:5px;">Next Entry Cost: ${nextCostHtml}</p>
                                <button class="action-button enter-raffle-btn raffle-action-btn" data-raffle-id="${raffle.id}">Enter Raffle</button>
                            ` : ''}
                            <div class="raffle-admin-actions">${adminActionsHtml}</div>
                            ${winnersHtml}
                        </div>
                    `;
                    whitelistRafflesContainer.appendChild(card);
                }
                whitelistRafflesContainer.querySelectorAll('.enter-raffle-btn').forEach(btn => btn.addEventListener('click', handleEnterRaffle));
                whitelistRafflesContainer.querySelectorAll('.draw-winners-btn').forEach(btn => btn.addEventListener('click', handleDrawWinners));
                whitelistRafflesContainer.querySelectorAll('.draw-now-btn').forEach(btn => btn.addEventListener('click', handleDrawNow));
                whitelistRafflesContainer.querySelectorAll('.delete-raffle-btn').forEach(btn => btn.addEventListener('click', handleDeleteRaffle));
            }
            async function handleEnterRaffle(event) {
    if (!currentUser) { showCustomPopup("You must be logged in to enter a raffle.", "Login Required"); return; }
    const raffleId = event.target.dataset.raffleId;
    const raffle = allRaffles.find(r => r.id === raffleId);
    if (!raffle || raffle.status !== 'active' || (raffle.endTime - Date.now() <= 0)) {
        showCustomPopup("Raffle is not active or has ended.", "Entry Failed");
        await fetchAndDisplayRaffles();
        return;
    }

    // --- Calculate cost for this specific entry ---
    const userEntryCount = playerRaffleEntries[raffle.id] || 0;
    const costMultiplier = userEntryCount + 1;
    const costPV = raffle.entryCost.pv * costMultiplier;
    const costGold = raffle.entryCost.gold * costMultiplier;
    const costDiamonds = raffle.entryCost.diamonds * costMultiplier;
    
    // Check for funds
    if (currentPvTokens < costPV || currentGold < costGold || currentDiamonds < costDiamonds) {
        showCustomPopup("Not enough currency for the next entry.", "Entry Failed");
        return;
    }

    const playerProgressRef = doc(db, "playerProgress", currentUser.uid);
    // Use collection().doc() to generate a new unique ID for the entry
    const raffleEntryRef = doc(collection(db, "raffles", raffleId, "entries"));
    const mainRaffleDocRef = doc(db, "raffles", raffleId);

    try {
        await runTransaction(db, async (transaction) => {
            const playerDoc = await transaction.get(playerProgressRef);
            if (!playerDoc.exists()) throw "Player document does not exist!";

            const mainRaffleSnap = await transaction.get(mainRaffleDocRef);
            if (!mainRaffleSnap.exists()) throw "Raffle document does not exist!";
            
            const currentPlayerData = playerDoc.data();
            const currentRaffleData = mainRaffleSnap.data();

            if (currentRaffleData.status !== 'active' || (currentRaffleData.endTime.toDate().getTime() - Date.now() <= 0)) {
                throw "Raffle is no longer active.";
            }

            // --- Re-calculate cost inside transaction for consistency ---
            const dbEntryCount = (currentPlayerData.playerRaffleEntries || {})[raffleId] || 0;
            const dbCostMultiplier = dbEntryCount + 1;
            const dbCostPV = raffle.entryCost.pv * dbCostMultiplier;
            const dbCostGold = raffle.entryCost.gold * dbCostMultiplier;
            const dbCostDiamonds = raffle.entryCost.diamonds * dbCostMultiplier;
            
            const newPv = (currentPlayerData.pvTokens || 0) - dbCostPV;
            const newGold = (currentPlayerData.gold || 0) - dbCostGold;
            const newDiamonds = (currentPlayerData.diamonds || 0) - dbCostDiamonds;
            
            if (newPv < 0 || newGold < 0 || newDiamonds < 0) throw "Insufficient funds.";

            // Increment the user's entry count for this raffle
            let updatedPlayerRaffleEntries = {
                ... (currentPlayerData.playerRaffleEntries || {}),
                [raffleId]: dbEntryCount + 1
            };

            // Update player's currency and their entry count
            transaction.update(playerProgressRef, {
                pvTokens: newPv,
                gold: newGold,
                diamonds: newDiamonds,
                playerRaffleEntries: updatedPlayerRaffleEntries
            });

            // Create a new entry document with the player's info
            transaction.set(raffleEntryRef, {
                timestamp: Timestamp.now(),
                nickname: userNickname,
                walletAddress: currentUser.uid // Store the wallet address here
            });
            
            // Increment the total entry count on the main raffle document
            transaction.update(mainRaffleDocRef, {
                entryCount: (currentRaffleData.entryCount || 0) + 1
            });
        });

        // --- On successful transaction, update client-side state ---
        currentPvTokens -= costPV;
        currentGold -= costGold;
        currentDiamonds -= costDiamonds;
        playerRaffleEntries[raffle.id] = (playerRaffleEntries[raffle.id] || 0) + 1;

        const raffleInClientArray = allRaffles.find(r => r.id === raffleId);
        if (raffleInClientArray) raffleInClientArray.entryCount = (raffleInClientArray.entryCount || 0) + 1;

        updateStatsDisplay();
        renderWhitelistRaffles(); // Re-render to show new entry count and next cost
        showCustomPopup(`Successfully entered raffle: ${raffle.name}! (Entry #${playerRaffleEntries[raffle.id]})`, "Raffle Entry");
        
        if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
    } catch (error) {
        console.error("Raffle entry transaction failed: ", error);
        showCustomPopup(`Raffle entry failed: ${error.toString()}`, "Entry Error");
        await fetchAndDisplayRaffles(); // Refresh raffle list in case of error
    }
}
                async function drawRaffleWinners(raffleId, isDrawingNow = false) {
                if (!currentUser || !currentUser.uid || !ADMIN_WALLET_ADDRESSES.includes(currentUser.uid.toLowerCase()) || !db) {
                    console.warn("Admin action 'drawRaffleWinners' blocked: Not an admin wallet.");
                    return;
                }
                const raffleDocRef = doc(db, "raffles", raffleId);
                try {
                    const raffleDocSnap = await getDoc(raffleDocRef);
                    if (!raffleDocSnap.exists()) {
                        showCustomPopup("Raffle document not found.", "Admin Error");
                        return false;
                    }
                    const raffleData = raffleDocSnap.data();
                    if (!isDrawingNow && raffleData.status === 'active' && raffleData.endTime.toDate().getTime() > Date.now()) {
                        showCustomPopup("Raffle not ended yet.", "Admin Action Failed");
                        return false;
                    }
                    if (raffleData.winners && raffleData.winners.length > 0) {
                        showCustomPopup("Winners already drawn.", "Admin Info");
                        return false;
                    }
                    await updateDoc(raffleDocRef, { status: 'drawing_winners', endTime: Timestamp.now() });
                    const localRaffle = allRaffles.find(r => r.id === raffleId);
                    if (localRaffle) {
                        localRaffle.status = 'drawing_winners';
                        localRaffle.endTime = Date.now();
                    }
                    renderWhitelistRaffles();
                    const entriesColRef = collection(db, "raffles", raffleId, "entries");
                    const entriesSnapshot = await getDocs(entriesColRef);
                    const allEntries = []; // Each object in this array is one ticket
                    entriesSnapshot.forEach(entryDoc => {
                        const entryData = entryDoc.data();
                        // Important: Read the wallet address from *inside* the document now
                        if (entryData && entryData.walletAddress) {
                            allEntries.push({
                                nickname: entryData.nickname || `User...${entryData.walletAddress.slice(-4)}`,
                                address: entryData.walletAddress
                            });
                        }
                    });

                    if (allEntries.length === 0) {
                        await updateDoc(raffleDocRef, { status: 'winners_announced', winners: [] });
                        if (localRaffle) {
                            localRaffle.status = 'winners_announced';
                            localRaffle.winners = [];
                        }
                        showCustomPopup(`No entries for ${raffleData.name}.`, "Raffle Result");
                        renderWhitelistRaffles();
                        return true;
                    }

                    // --- Draw winners from all tickets ---
                    // This logic prevents the same person from winning multiple times.
                    let potentialWinners = [...allEntries]; // All tickets are potential winners
                    const drawnWinners = []; // Array of {nickname, address} objects
                    const uniqueWinnerAddresses = new Set(); // To ensure one person doesn't win multiple times

                    // Loop until we have enough winners or run out of unique people to draw from
                    for (let i = 0; i < raffleData.maxWinners && potentialWinners.length > 0; i++) {
                        const winnerIndex = Math.floor(Math.random() * potentialWinners.length);
                        const winnerCandidate = potentialWinners[winnerIndex];

                        if (!uniqueWinnerAddresses.has(winnerCandidate.address)) {
                            // This person hasn't won yet. Add them to the list.
                            drawnWinners.push(winnerCandidate);
                            uniqueWinnerAddresses.add(winnerCandidate.address);
                            
                            // Now, remove ALL tickets belonging to this winner from the pool
                            potentialWinners = potentialWinners.filter(ticket => ticket.address !== winnerCandidate.address);
                        } else {
                            // This person already won. Remove just this one ticket from the pool and try again.
                            potentialWinners.splice(winnerIndex, 1);
                            i--; // Decrement i to re-do this loop iteration and find another winner
                        }
                    }
                    
                    await updateDoc(raffleDocRef, { winners: drawnWinners, status: 'winners_announced' });
                    if (localRaffle) {
                        localRaffle.winners = drawnWinners;
                        localRaffle.status = 'winners_announced';
                    }
                    showCustomPopup(`Winners drawn for ${raffleData.name}!`, "Raffle Result");
                    renderWhitelistRaffles();
                    return true;
                } catch (error) {
                    console.error("Error drawing winners: ", error);
                    showCustomPopup("Failed to draw winners.", "Admin Error");
                    const localRaffle = allRaffles.find(r => r.id === raffleId);
                    if (localRaffle && localRaffle.status === 'drawing_winners') localRaffle.status = (localRaffle.endTime > Date.now() ? 'active' : 'ended');
                    renderWhitelistRaffles();
                    return false;
                }
            }
            async function handleDrawWinners(event) { await drawRaffleWinners(event.target.dataset.raffleId, false); }
            async function handleDrawNow(event) { await drawRaffleWinners(event.target.dataset.raffleId, true); }
            async function handleDeleteRaffle(event) { if (!currentUser || !currentUser.uid || !ADMIN_WALLET_ADDRESSES.includes(currentUser.uid.toLowerCase()) || !db) { console.warn("Admin action 'handleDeleteRaffle' blocked: Not an admin wallet."); return; }
const raffleId = event.target.dataset.raffleId; const raffleName = allRaffles.find(r => r.id === raffleId)?.name || "this raffle"; if (confirm(`Are you sure you want to delete "${raffleName}"? This cannot be undone.`)) { const raffleDocRef = doc(db, "raffles", raffleId); try { await deleteDoc(raffleDocRef); showCustomPopup(`Raffle "${raffleName}" deleted.`, "Admin Action"); await fetchAndDisplayRaffles(); } catch (error) { console.error("Error deleting raffle:", error); showCustomPopup("Failed to delete raffle.", "Admin Error"); } }}
            
async function loadPunkVoyageIds() {
    console.log("loadPunkVoyageIds (from GitHub): Function CALLED. Current punkVoyageIdsLoaded state:", punkVoyageIdsLoaded);

    if (punkVoyageIdsLoaded) {
        console.log("loadPunkVoyageIds (from GitHub): Already loaded. Skipping.");
        return true;
    }

    // Replace with the actual RAW URL to your JSON file on GitHub
    const GITHUB_IDS_URL = 'https://raw.githubusercontent.com/nvoiy/pvadventures/main/punk_voyage_ids.json'; // <<< IMPORTANT: UPDATE THIS URL

    try {
        console.log(`loadPunkVoyageIds (from GitHub): Attempting to fetch IDs from ${GITHUB_IDS_URL}`);
        const response = await fetch(GITHUB_IDS_URL, { cache: "no-store" });

        if (!response.ok) {
            console.error(`loadPunkVoyageIds (from GitHub): Failed to fetch official ID list. Status: ${response.status} ${response.statusText}`);
            if (userOrdinalsDisplayElement) userOrdinalsDisplayElement.style.display = 'block';
            if (userOrdinalsListElement) userOrdinalsListElement.innerHTML = `<p>Error: Could not load game's collection definition from server. Bonus may be incorrect.</p>`;
            punkVoyageIdsLoaded = false;
            PUNK_VOYAGE_IDS_SET = new Set();
            return false;
        }

        const idsArray = await response.json();
        console.log("loadPunkVoyageIds (from GitHub): Successfully fetched IDs. Count:", idsArray.length);

        if (!Array.isArray(idsArray)) {
            console.error("loadPunkVoyageIds (from GitHub): Fetched data is not an array.");
            if (userOrdinalsDisplayElement) userOrdinalsDisplayElement.style.display = 'block';
            if (userOrdinalsListElement) userOrdinalsListElement.innerHTML = `<p>Error: Game's collection definition format is incorrect.</p>`;
            punkVoyageIdsLoaded = false;
            PUNK_VOYAGE_IDS_SET = new Set();
            return false;
        }

        PUNK_VOYAGE_IDS_SET = new Set(idsArray);
        console.log(`loadPunkVoyageIds (from GitHub): Successfully processed ${PUNK_VOYAGE_IDS_SET.size} IDs into PUNK_VOYAGE_IDS_SET. Setting punkVoyageIdsLoaded to true.`);
        punkVoyageIdsLoaded = true;
        return true;

    } catch (error) {
        console.error('loadPunkVoyageIds (from GitHub): CRITICAL ERROR fetching or processing IDs:', error, error.stack);
        if (userOrdinalsDisplayElement) userOrdinalsDisplayElement.style.display = 'block';
        if (userOrdinalsListElement) userOrdinalsListElement.innerHTML = `<p>Critical Error: Could not load game's collection definition. Error: ${error.message}</p>`;
        PUNK_VOYAGE_IDS_SET = new Set();
        punkVoyageIdsLoaded = false;
        return false;
    }
}


   async function loadDungeonCrawlerIds() {
        console.log("loadDungeonCrawlerIds: Attempting to load Dungeon Crawler inscription IDs.");
        try {
            // PASTE YOUR DUNGEON CRAWLER NFT IDs HERE, formatted as a JavaScript array
            // It should look like: const crawlerIdsArray = [ "crawler_id1", "crawler_id2", ... ];
            const crawlerIdsArray = [
                // EXAMPLE: "some_crawler_inscription_id_1i0",
                // EXAMPLE: "another_crawler_inscription_id_2i0"
            ]; // <<<<------ YOU WILL ADD YOUR IDs HERE LATER

            if (!Array.isArray(crawlerIdsArray) /* || crawlerIdsArray.length === 0 */) { // Allow empty for now
                console.warn("loadDungeonCrawlerIds: Embedded crawlerIdsArray is not a valid array or is empty. Dungeon Crawler feature might be limited.");
                // No critical error if empty, just means no crawlers defined yet
                PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET.clear(); // Use .clear() to empty the Set
                dungeonCrawlerIdsLoaded = true; // Mark as "loaded" (even if empty) to prevent re-attempts
                return true; // Still return true as the process completed without error
            }

            PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET.clear(); // Clear before adding new ones
            crawlerIdsArray.forEach(id => PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET.add(id));

            console.log(`loadDungeonCrawlerIds: Successfully loaded ${PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET.size} Dungeon Crawler inscription IDs.`);
            dungeonCrawlerIdsLoaded = true;
            return true;
        } catch (error) {
            console.error('loadDungeonCrawlerIds: Error processing embedded IDs:', error);
            PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET.clear();
            dungeonCrawlerIdsLoaded = false; // Mark as failed
            return false;
        }
    }

    function renderActiveSpecialties() {
    if (!specialtiesListContainer) {
        console.warn("Specialties list container not found.");
        return;
    }

    specialtiesListContainer.innerHTML = ''; // Clear previous
    let specialtiesHtml = '<ul>';
    let foundSpecialties = false;

    // 1. Perks from equipped items
    Object.keys(equippedItems).forEach(slotId => {
        const equippedInstanceId = equippedItems[slotId];
        if (!equippedInstanceId) return;

        const invItem = playerInventory.find(i => i.uniqueInstanceId === equippedInstanceId);
        if (invItem) {
            const itemMaster = craftableItemsData.find(im => im.id === invItem.id);
            if (itemMaster && itemMaster.perk) {
                const scaledPerk = getScaledItemPerk(itemMaster, invItem.level || 0);
                let perkText = '';
                
                // This function will now display ALL perk types
                switch (scaledPerk.type) {
                    case "attackBoost":
                        perkText = `Attack: +${scaledPerk.value}`;
                        break;
                    case "defenseBoost":
                        perkText = `Defense: +${scaledPerk.value}`;
                        break;
                    case "statBoost":
                        let stats = [];
                        if (scaledPerk.attack) stats.push(`Attack ${scaledPerk.attack > 0 ? '+' : ''}${scaledPerk.attack}`);
                        if (scaledPerk.defense) stats.push(`Defense ${scaledPerk.defense > 0 ? '+' : ''}${scaledPerk.defense}`);
                        perkText = stats.join(', ');
                        break;
                    case "timeReduction":
                        perkText = `Adventure Time Reduction: ${scaledPerk.value / 60} minutes`;
                        break;
                    case "goldChanceIncrease":
                        perkText = `Gold Find Chance Multiplier: +${(scaledPerk.value * 100).toFixed(1)}%`;
                        break;
                    case "pvBonus":
                        perkText = `PV Token Bonus (Adventures): +${(scaledPerk.value * 100).toFixed(1)}%`;
                        break;
                    case "materialChanceMultiplier":
                        perkText = `Material Find Chance Multiplier: x${scaledPerk.value.toFixed(2)}`;
                        break;
                    case "flatCurrencyChanceBoost":
                        let currencyBonuses = [];
                        if (scaledPerk.goldBonus) currencyBonuses.push(`Gold Find (Flat): +${(scaledPerk.goldBonus * 100).toFixed(1)}%`);
                        if (scaledPerk.diamondBonus) currencyBonuses.push(`Diamond Find (Flat): +${(scaledPerk.diamondBonus * 100).toFixed(1)}%`);
                        perkText = currencyBonuses.join('<br>');
                        break;
                    case "dungeonEntryBonus":
                        let entryBonuses = [];
                        if (scaledPerk.dungeon1) entryBonuses.push(`Dungeon 1: +${scaledPerk.dungeon1} daily entry`);
                        if (scaledPerk.dungeon2) entryBonuses.push(`Dungeon 2: +${scaledPerk.dungeon2} daily entry`);
                        perkText = entryBonuses.join('<br>');
                        break;
                    case "timeReductionPercent":
                        perkText = `Adventure Time Reduction: ${(scaledPerk.value * 100).toFixed(0)}%`;
                        break;
                    case "dungeonMaterialFetch":
                        perkText = `$DOG Pet: Fetches ${scaledPerk.count} random material(s) after dungeon.`;
                        break;
                    default:
                        console.warn("Unknown perk type for specialty display:", scaledPerk.type);
                        perkText = ''; // Don't display unknown perks
                        break;
                }

                if (perkText) {
                    const itemLevelText = (invItem.level || 0) > 0 ? ` +${invItem.level}` : '';
                    specialtiesHtml += `<li>${perkText} <span class="specialty-source">(from ${itemMaster.name}${itemLevelText})</span></li>`;
                    foundSpecialties = true;
                }
            }
        }
    });

    // 2. Dungeon Set Bonus
    const dungeonSetReduction = getDungeonSetBonusTimeReduction();
    if (dungeonSetReduction > 0) {
        specialtiesHtml += `<li>Dungeon Set Bonus: Adventure Time Reduction: ${(dungeonSetReduction * 100).toFixed(0)}%</li>`;
        foundSpecialties = true;
    }

    if (!foundSpecialties) {
        specialtiesHtml += '<li>No active specialties. Equip items with perks!</li>';
    }
    specialtiesHtml += '</ul>';
    specialtiesListContainer.innerHTML = specialtiesHtml;
}

async function fetchWalletInscriptions(userAddress, walletName) {
    if (!punkVoyageIdsLoaded) {
        console.warn("fetchWalletInscriptions: Punk Voyage ID list (game definition) not loaded. Cannot calculate bonus or display.");
        if (userOrdinalsDisplayElement) userOrdinalsDisplayElement.style.display = 'block';
        if (userOrdinalsListElement) userOrdinalsListElement.innerHTML = `<p>Loading game's collection definitions...</p>`;
        return;
    }

    if (userOrdinalsDisplayElement) userOrdinalsDisplayElement.style.display = 'block';
    if (userOrdinalsListElement) userOrdinalsListElement.innerHTML = `<p>Loading your inscriptions...</p>`;

    let actualWalletInscriptionIds = [];
    let inscriptionDetailsForRendering = [];
    let previousBonusAdventurers = ordinalBonusAdventurers;

    try {
        if (walletName === 'UniSat' && typeof window.unisat !== 'undefined') {
            const unisatInscriptions = await window.unisat.getInscriptions(0, 200);
            if (unisatInscriptions && unisatInscriptions.list) {
                actualWalletInscriptionIds = unisatInscriptions.list.map(insc => insc.inscriptionId);
            }
        } else if (walletName === 'Xverse' || walletName === 'UniSat') {
            let currentOffset = 0; const pageLimit = 60; let hasMore = true;
            const tempIds = [];
            while (hasMore && tempIds.length < 500) {
                const hiroApiUrl = `https://api.hiro.so/ordinals/v1/inscriptions?address=${userAddress}&limit=${pageLimit}&offset=${currentOffset}`;
                const response = await fetch(hiroApiUrl);
                if (!response.ok) {
                     if (tempIds.length === 0 && userOrdinalsListElement) userOrdinalsListElement.innerHTML = `<p>Error fetching inscriptions via public API. Status: ${response.statusText}</p>`;
                    break;
                }
                const data = await response.json();
                if (data.results && data.results.length > 0) tempIds.push(...data.results.map(insc => insc.id));
                if (data.total > tempIds.length && data.results && data.results.length === pageLimit) currentOffset += pageLimit;
                else hasMore = false;
            }
            actualWalletInscriptionIds = tempIds;
        } else {
            if (userOrdinalsListElement) userOrdinalsListElement.innerHTML = `<p>Wallet type not supported for inscription listing.</p>`;
            ordinalBonusAdventurers = 0;
            recalculateTotalAvailableAdventurers();
            if (previousBonusAdventurers !== 0 && currentUser && currentUser.uid) await saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
            return;
        }

        if (actualWalletInscriptionIds.length === 0) {
            if (userOrdinalsListElement) userOrdinalsListElement.innerHTML = `<p>No inscriptions found in this wallet.</p>`;
            ordinalBonusAdventurers = 0;
        } else {
            const ownedPunkVoyageForBonus = actualWalletInscriptionIds.filter(id => PUNK_VOYAGE_IDS_SET.has(id));
            ordinalBonusAdventurers = ownedPunkVoyageForBonus.length;

            if (userOrdinalsListElement) userOrdinalsListElement.innerHTML = `<p>Found ${ownedPunkVoyageForBonus.length} Punk Voyage Ordinal(s). You get ${ordinalBonusAdventurers} bonus adventurer(s)! Fetching details for display...</p>`;

            for (const inscriptionId of ownedPunkVoyageForBonus) {
                if (PUNK_VOYAGE_ID_IMAGE_CACHE[inscriptionId]) {
                    inscriptionDetailsForRendering.push(PUNK_VOYAGE_ID_IMAGE_CACHE[inscriptionId]);
                    continue;
                }
                try {
                    const detailUrl = `https://api.hiro.so/ordinals/v1/inscriptions/${inscriptionId}`;
                    const contentUrl = `https://api.hiro.so/ordinals/v1/inscriptions/${inscriptionId}/content`;
                    let name = `#${inscriptionId.slice(0,4)}...`;
                    try {
                        const detailResponse = await fetch(detailUrl);
                        if(detailResponse.ok){
                            const detailData = await detailResponse.json();
                            name = `#${detailData.number || inscriptionId.slice(0,4)}`;
                        }
                    } catch (nameFetchError) { console.warn("Could not fetch name for display", nameFetchError); }
                    PUNK_VOYAGE_ID_IMAGE_CACHE[inscriptionId] = { id: inscriptionId, name: name, imageUrl: contentUrl };
                    inscriptionDetailsForRendering.push(PUNK_VOYAGE_ID_IMAGE_CACHE[inscriptionId]);
                } catch (detailError) {
                    console.error(`Error processing inscription ${inscriptionId} for display:`, detailError);
                    inscriptionDetailsForRendering.push({ id: inscriptionId, name: `ID ${inscriptionId.slice(0,6)}... (Error)`, imageUrl: null });
                }
            }
        }
        renderOwnedPunkVoyageOrdinals(inscriptionDetailsForRendering);

    } catch (error) {
        console.error(`Error in fetchWalletInscriptions (Client-Side Bonus) for ${walletName}:`, error);
        if (userOrdinalsListElement) userOrdinalsListElement.innerHTML = `<p>An error occurred while checking your Ordinals.</p>`;
        ordinalBonusAdventurers = 0;
    } finally {
        recalculateTotalAvailableAdventurers();
        if (ordinalBonusAdventurers !== previousBonusAdventurers && currentUser && currentUser.uid) {
            console.log(`Ordinal bonus changed from ${previousBonusAdventurers} to ${ordinalBonusAdventurers}. Saving game state.`);
            await saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
        } else if (ordinalBonusAdventurers === previousBonusAdventurers) {
            console.log(`Ordinal bonus unchanged (${ordinalBonusAdventurers}). No save triggered by fetchWalletInscriptions.`);
        }
    }
}

function renderOwnedPunkVoyageOrdinals(ownedInscriptions) { // ownedInscriptions is an array of {id, name, imageUrl}
    if (!userOrdinalsDisplayElement || !userOrdinalsListElement) return;

    userOrdinalsListElement.innerHTML = ''; // Clear previous list items

    // Get the <h4> element for the title, or create it if it doesn't exist
    let titleElement = userOrdinalsDisplayElement.querySelector('h4');
    if (!titleElement) {
        titleElement = document.createElement('h4');
        // Ensure the title is the first child of userOrdinalsDisplayElement, before userOrdinalsListElement
        if (userOrdinalsDisplayElement.firstChild) {
            userOrdinalsDisplayElement.insertBefore(titleElement, userOrdinalsDisplayElement.firstChild);
        } else {
            userOrdinalsDisplayElement.appendChild(titleElement);
        }
    }

    if (!ownedInscriptions || ownedInscriptions.length === 0) {
        titleElement.textContent = "MY PUNK VOYAGE ORDINALS (0)";
        userOrdinalsListElement.innerHTML = `<p style="text-align:center; font-size:0.9em;">You don't own any Punk Voyage Ordinals from this collection in the connected wallet.</p>`;
        userOrdinalsDisplayElement.style.display = 'block'; // Ensure the section is visible to show the "0" count
        return;
    }

    titleElement.textContent = `MY PUNK VOYAGE ORDINALS (${ownedInscriptions.length})`;

    const ul = document.createElement('ul');
    ul.style.listStyleType = 'none'; // Remove bullet points
    ul.style.paddingLeft = '0';
    ul.style.textAlign = 'center'; // Center the list items

    ownedInscriptions.forEach(insc => {
        const li = document.createElement('li');
        li.textContent = insc.name; // insc.name already includes '#' from fetchWalletInscriptions
        li.style.fontSize = '0.9em';
        li.style.marginBottom = '3px';
        ul.appendChild(li);
    });
    userOrdinalsListElement.appendChild(ul);
    userOrdinalsDisplayElement.style.display = 'block'; // Make sure the section is visible
}
async function fetchPlayerDungeonCrawlers(userAddress, walletName) {
    if (!dungeonCrawlerIdsLoaded) {
        console.warn("Dungeon Crawler ID list not loaded. Cannot fetch player's crawlers.");
        playerDungeonCrawlers = [];
        return;
    }

    console.log(`Fetching Dungeon Crawlers for ${userAddress} via ${walletName}... (Currently Placeholder)`);
    // This will be similar to fetchWalletInscriptions but will use PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET
    // For now, let's simulate owning a few if the main Punk Voyage collection is used as a stand-in, or add dummy data
    
    playerDungeonCrawlers = []; // Clear previous

    // --- SIMULATION / PLACEHOLDER ---
    // If you want to test with some dummy data:
    // Temporarily add some dummy crawlers if the set is empty for UI testing
    if (PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET.size === 0) { // <<< MODIFIED THIS CONDITION FOR TESTING
        console.log("DEV MODE: Adding dummy crawlers for UI testing as actual ID set is empty.");
        playerDungeonCrawlers.push({ 
            id: "dummy_crawler_1i0", 
            uniqueInstanceId: "crawler_dummy1", 
            name: "Test Crawler Alpha", 
            imageUrl: "https://via.placeholder.com/30/FF0000/FFFFFF?Text=C1", 
            attack: 10, 
            defense: 5 
        });
        playerDungeonCrawlers.push({ 
            id: "dummy_crawler_2i0", 
            uniqueInstanceId: "crawler_dummy2", 
            name: "Test Crawler Beta", 
            imageUrl: "https://via.placeholder.com/30/00FF00/FFFFFF?Text=C2", 
            attack: 7, 
            defense: 8 
        });
        playerDungeonCrawlers.push({ 
            id: "dummy_crawler_3i0", 
            uniqueInstanceId: "crawler_dummy3", 
            name: "Test Crawler Gamma", 
            imageUrl: "https://via.placeholder.com/30/0000FF/FFFFFF?Text=C3", 
            attack: 5, 
            defense: 10 
        });
    } else if (PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET.size > 0) { 
        let count = 0;
        PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET.forEach(id => {
            if (count < 5) { 
                playerDungeonCrawlers.push({ 
                    id: id, 
                    uniqueInstanceId: `crawler_${id.slice(0,8)}`, 
                    name: `Crawler #${id.slice(0,4)}`, 
                    imageUrl: `https://api.hiro.so/ordinals/v1/inscriptions/${id}/content`, 
                    attack: Math.floor(Math.random() * 10) + 5, 
                    defense: Math.floor(Math.random() * 10) + 5
                });
                count++;
            }
        });
         console.log("Simulated owning Dungeon Crawlers:", playerDungeonCrawlers);
    } else {
        console.log("No Dungeon Crawler IDs defined in PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET. Player will have no crawlers.");
    }
    // --- END SIMULATION ---

    // In the real version, you'd:
    // 1. Fetch all inscriptions from the user's wallet (like in fetchWalletInscriptions)
    // 2. Filter those against PUNK_VOYAGE_DUNGEON_CRAWLER_IDS_SET
    // 3. For each owned crawler, fetch its metadata (name, image, and importantly, its ATK/DEF stats if they are part of the inscription metadata)
    // 4. Populate playerDungeonCrawlers with objects containing { id, uniqueInstanceId, name, imageUrl, attack, defense }
    
    // For now, we assume it's populated (e.g., by the simulation above or if you manually add to playerDungeonCrawlers for testing)
    if (currentUser.uid) { // Save if state changed (e.g. simulated crawlers were added)
        saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
    }
}
function updateUpgradeSuccessRateDisplay() {
    if (!upgradeSuccessRateDisplay) return;
    if (!selectedItemForUpgrade || !selectedScrollForUpgrade) {
        upgradeSuccessRateDisplay.textContent = ""; return;
    }
    
    const scrollTier = selectedScrollForUpgrade.scrollTier;
    const itemCurrentLevel = selectedItemForUpgrade.currentLevel || 0;
    
    let compatibleForLevel = false;
    if (scrollTier === 1 && itemCurrentLevel === 0) compatibleForLevel = true;
    else if (scrollTier === 2 && (itemCurrentLevel >= 0 && itemCurrentLevel <= 2)) compatibleForLevel = true;
    else if (scrollTier === 3 && (itemCurrentLevel >= 0 && itemCurrentLevel <= 4)) compatibleForLevel = true;

    if (!compatibleForLevel) { 
        if (scrollTier === 1 && itemCurrentLevel > 0) {
            upgradeSuccessRateDisplay.textContent = `Basic Scrolls are only for +0 items.`;
        } else {
            upgradeSuccessRateDisplay.textContent = `This scroll is not for an item at +${itemCurrentLevel}.`; 
        }
        return; 
    }
    
    if (itemCurrentLevel >= 5) { upgradeSuccessRateDisplay.textContent = "Item is at max level (+5)."; return; }
    
    let successChance = upgradeChances[itemCurrentLevel];
    let bonusText = "";

    // Scroll level bonus (NEW LOGIC)
    if ((scrollTier === 2 && itemCurrentLevel <= 1) || (scrollTier === 3 && itemCurrentLevel <= 3)) {
        successChance += 0.10;
        bonusText += " (+10% scroll bonus)";
    }

    // Upgrade Booster bonus
    const booster = activePotions.find(p => p.id === 'upgrade_booster');
    if (booster) {
        successChance += booster.effect.flatValue;
        bonusText += ` <span class="upgrade-booster-text">(+10% booster)</span>`; // USE THE NEW STYLE
    }

    successChance = Math.min(successChance, 1);
    upgradeSuccessRateDisplay.innerHTML = `Success Chance: ${(successChance * 100).toFixed(0)}%${bonusText}`; // Use innerHTML for the span
}
       
function openItemSelectionModal(purpose) {
    if (upgradeResultDisplay) upgradeResultDisplay.textContent = ''; // Clear previous results on any new selection

    itemSelectionModalList.innerHTML = '';
    itemSelectionModalOverlay.classList.remove('hidden');
    itemSelectionModal.classList.remove('hidden');

    if (purpose === 'item') {
        itemSelectionModalTitle.textContent = "Select Item to Upgrade";
        const equippableItemsInInventory = playerInventory.filter(invItem => {
            const itemMaster = craftableItemsData.find(ci => ci.id === invItem.id);
            return itemMaster && itemMaster.type !== "Consumable" && itemMaster.type !== "upgrade_scroll_purchase" && itemMaster.type !== "unlockable_consumable" && (invItem.level || 0) < 5;
        });
        if (equippableItemsInInventory.length === 0) { itemSelectionModalList.innerHTML = "<p>No upgradable items (non-max level) in inventory.</p>"; return; }
        equippableItemsInInventory.forEach(invItem => {
            const itemMaster = craftableItemsData.find(ci => ci.id === invItem.id);
            const btn = document.createElement('button'); btn.classList.add('action-button'); btn.style.width = '100%'; btn.style.marginBottom = '5px'; btn.style.display = 'flex'; btn.style.alignItems = 'center';
            const levelText = (invItem.level || 0) > 0 ? `(+${invItem.level || 0}) ` : '';
            const itemTierDisplay = itemMaster.tier === undefined ? 0 : itemMaster.tier;
            btn.innerHTML = `${getItemIconHTML(itemMaster.iconUrlOrColor, itemMaster.type, '20px')} <span style="margin-left: 5px;">${levelText}${itemMaster.name} (Tier ${itemTierDisplay})</span>`;
            btn.onclick = () => {
                selectedItemForUpgrade = { ...itemMaster, ...invItem, uniqueInstanceId: invItem.uniqueInstanceId, currentLevel: invItem.level || 0, tier: itemMaster.tier };
                selectedItemForUpgradeDisplay.innerHTML = `Item: ${getItemIconHTML(selectedItemForUpgrade.iconUrlOrColor, selectedItemForUpgrade.type, '30px')} ${levelText}${selectedItemForUpgrade.name}`;
                closeItemSelectionModal(); updateUpgradeSuccessRateDisplay();
            };
            itemSelectionModalList.appendChild(btn);
        });
    } else if (purpose === 'scroll') {
        itemSelectionModalTitle.textContent = "Select Upgrade Scroll Type";
        let hasScrolls = false;
        Object.keys(scrollData).forEach(scrollTypeKey => {
            const count = playerScrolls[scrollTypeKey] || 0;
            if (count > 0) hasScrolls = true;
            const scrollMaster = scrollData[scrollTypeKey];
            const btn = document.createElement('button'); btn.classList.add('action-button'); btn.style.width = '100%'; btn.style.marginBottom = '5px'; btn.style.display = 'flex'; btn.style.alignItems = 'center';
            btn.innerHTML = `${getItemIconHTML(scrollMaster.icon, 'S', '20px')} <span style="margin-left: 5px;">${scrollMaster.name} (Count: ${count})</span>`;
            if (count === 0) btn.disabled = true;
            btn.onclick = () => {
                if (count > 0) {
                    selectedScrollForUpgrade = { type: scrollTypeKey, name: scrollMaster.name, scrollTier: scrollMaster.tier, iconUrlOrColor: scrollMaster.icon };
                    selectedScrollForUpgradeDisplay.innerHTML = `Scroll: ${getItemIconHTML(selectedScrollForUpgrade.iconUrlOrColor, 'S', '30px')} ${selectedScrollForUpgrade.name}`;
                    closeItemSelectionModal(); updateUpgradeSuccessRateDisplay();
                }
            };
            itemSelectionModalList.appendChild(btn);
        });
         if (!hasScrolls) { itemSelectionModalList.innerHTML = "<p>No upgrade scrolls available.</p>";}
    }
}

            function closeItemSelectionModal() { itemSelectionModalOverlay.classList.add('hidden'); itemSelectionModal.classList.add('hidden'); }
            if (upgradeItemSlot) upgradeItemSlot.addEventListener('click', () => openItemSelectionModal('item'));
            if (upgradeScrollSlot) upgradeScrollSlot.addEventListener('click', () => openItemSelectionModal('scroll'));
            if (itemSelectionModalCloseBtn) itemSelectionModalCloseBtn.addEventListener('click', closeItemSelectionModal);
            if (itemSelectionModalOverlay) itemSelectionModalOverlay.addEventListener('click', (event) => { if(event.target === itemSelectionModalOverlay) closeItemSelectionModal(); });
            let currentDungeonIdForCrawlerSelection = null;
            let tempSelectedCrawlers = []; // Store uniqueInstanceIds of crawlers selected in the modal
                        let confirmedCrawlersForDungeons = {};

            function openDungeonCrawlerSelectionModal(dungeonId) {
                currentDungeonIdForCrawlerSelection = dungeonId;
                const dungeon = dungeonsData.find(d => d.id === dungeonId);
                if (!dungeon || dungeon.type !== "party_npc") {
                    console.error("Invalid dungeon or not a party dungeon for crawler selection:", dungeonId);
                    return;
                }

                tempSelectedCrawlers = []; // Reset temporary selection
                dungeonCrawlerMaxSelectCountSpan.textContent = dungeon.maxPartySize - 1; // Player is 1, rest are crawlers

                availableDungeonCrawlersListDiv.innerHTML = '';
                if (playerDungeonCrawlers.length === 0) {
                    availableDungeonCrawlersListDiv.innerHTML = "<p>You don't own any Dungeon Crawler ordinals.</p>";
                } else {
                    playerDungeonCrawlers.forEach(crawler => {
                        // In the future, you'd also check if this crawler is already busy in another dungeon party
                        const crawlerBtn = document.createElement('button');
                        crawlerBtn.classList.add('crawler-item-btn');
                        crawlerBtn.dataset.crawlerInstanceId = crawler.uniqueInstanceId;
                        // Basic display: Name (ATK/DEF) - You'd style this better
                        crawlerBtn.innerHTML = `
                            <img src="${crawler.imageUrl || 'https://via.placeholder.com/30'}" alt="C" style="width:30px; height:30px; margin-right:8px; border-radius:3px;">
                            ${crawler.name} (ATK: ${crawler.attack || 'N/A'}, DEF: ${crawler.defense || 'N/A'})
                        `;
                        crawlerBtn.onclick = () => toggleCrawlerSelection(crawler, crawlerBtn, dungeon.maxPartySize - 1);
                        availableDungeonCrawlersListDiv.appendChild(crawlerBtn);
                    });
                }

                updateSelectedCrawlersDisplay(); // Clear and update the "Selected Crawlers" display
                dungeonCrawlerSelectionModalOverlay.classList.remove('hidden');
                dungeonCrawlerSelectionModal.classList.remove('hidden');
            }

            function toggleCrawlerSelection(crawler, buttonElement, maxSelect) {
                const index = tempSelectedCrawlers.findIndex(cId => cId === crawler.uniqueInstanceId);
                if (index > -1) { // Already selected, so deselect
                    tempSelectedCrawlers.splice(index, 1);
                    buttonElement.classList.remove('selected-for-dungeon');
                } else { // Not selected, try to select
                    if (tempSelectedCrawlers.length < maxSelect) {
                        tempSelectedCrawlers.push(crawler.uniqueInstanceId);
                        buttonElement.classList.add('selected-for-dungeon');
                    } else {
                        showCustomPopup(`You can select a maximum of ${maxSelect} crawlers for this dungeon.`, "Selection Limit Reached");
                    }
                }
                updateSelectedCrawlersDisplay();
            }

            function updateSelectedCrawlersDisplay() {
                selectedDungeonCrawlersDisplayDiv.innerHTML = '';
                if (tempSelectedCrawlers.length === 0) {
                    selectedDungeonCrawlersDisplayDiv.innerHTML = '<p style="font-size:0.9em; opacity:0.7;">No crawlers selected.</p>';
                    return;
                }
                tempSelectedCrawlers.forEach(crawlerInstanceId => {
                    const crawlerData = playerDungeonCrawlers.find(c => c.uniqueInstanceId === crawlerInstanceId);
                    if (crawlerData) {
                        const tag = document.createElement('span');
                        tag.classList.add('selected-crawler-tag');
                        tag.textContent = `${crawlerData.name}`;
                        
                        const removeBtn = document.createElement('button');
                        removeBtn.classList.add('remove-crawler-btn');
                        removeBtn.innerHTML = ''; // Multiplication sign as an X
                        removeBtn.title = `Remove ${crawlerData.name}`;
                        removeBtn.onclick = (event) => {
                            event.stopPropagation(); // Prevent card click if nested
                            const crawlerButtonInList = availableDungeonCrawlersListDiv.querySelector(`.crawler-item-btn[data-crawler-instance-id="${crawlerInstanceId}"]`);
                            toggleCrawlerSelection(crawlerData, crawlerButtonInList, parseInt(dungeonCrawlerMaxSelectCountSpan.textContent));
                        };
                        tag.appendChild(removeBtn);
                        selectedDungeonCrawlersDisplayDiv.appendChild(tag);
                    }
                });
            }

            function closeDungeonCrawlerSelectionModal() {
                dungeonCrawlerSelectionModalOverlay.classList.add('hidden');
                dungeonCrawlerSelectionModal.classList.add('hidden');
                currentDungeonIdForCrawlerSelection = null;
                tempSelectedCrawlers = [];
            }

            if (dungeonCrawlerConfirmSelectionBtn) {
                dungeonCrawlerConfirmSelectionBtn.addEventListener('click', () => {
                    if (currentDungeonIdForCrawlerSelection) {
                        // Store the confirmed selection for this dungeon
                        confirmedCrawlersForDungeons[currentDungeonIdForCrawlerSelection] = [...tempSelectedCrawlers]; // Store a copy

                        console.log(`Confirmed selection for dungeon ${currentDungeonIdForCrawlerSelection}:`, confirmedCrawlersForDungeons[currentDungeonIdForCrawlerSelection]);
                        
                        // Update the display on the main dungeons page
                        // This will now be handled by the renderDungeonsPage call below,
                        // but keeping the direct update for selectedCrawlersDisplayOnPage is fine too.
                        const selectedCrawlersDisplayOnPage = document.getElementById(`selectedCrawlersDisplay_${currentDungeonIdForCrawlerSelection}`);
                        if (selectedCrawlersDisplayOnPage) {
                            if (confirmedCrawlersForDungeons[currentDungeonIdForCrawlerSelection].length > 0) {
                                const names = confirmedCrawlersForDungeons[currentDungeonIdForCrawlerSelection].map(id => {
                                    const crawler = playerDungeonCrawlers.find(c => c.uniqueInstanceId === id);
                                    return crawler ? crawler.name : 'Unknown';
                                }).join(', ');
                                selectedCrawlersDisplayOnPage.textContent = `Selected: ${names}`;
                            } else {
                                selectedCrawlersDisplayOnPage.textContent = 'No crawlers selected.';
                            }
                        }
                        closeDungeonCrawlerSelectionModal();
                        // +++ ADD THIS LINE TO FORCE RE-RENDER +++
                        if (document.getElementById('dungeons-page') && document.getElementById('dungeons-page').classList.contains('active')) {
                            renderDungeonsPage();
                        }
                        // +++ END OF ADDED LINE +++
                    }
                });
            }
            if (dungeonCrawlerCancelSelectionBtn) {
                dungeonCrawlerCancelSelectionBtn.addEventListener('click', closeDungeonCrawlerSelectionModal);
            }
            if (dungeonCrawlerSelectionModalOverlay) {
                dungeonCrawlerSelectionModalOverlay.addEventListener('click', (event) => {
                    if (event.target === dungeonCrawlerSelectionModalOverlay) closeDungeonCrawlerSelectionModal();
                });
            }

            if (upgradeItemButton) {
    upgradeItemButton.addEventListener('click', () => {
        if (!currentUser) return;
        if (!selectedItemForUpgrade || !selectedScrollForUpgrade) {
            upgradeResultDisplay.textContent = "Please select an item and a scroll.";
            return;
        }

        const itemBaseTier = selectedItemForUpgrade.tier === undefined ? 0 : selectedItemForUpgrade.tier;
        const scrollTier = selectedScrollForUpgrade.scrollTier;
        const itemCurrentLevel = selectedItemForUpgrade.currentLevel || 0;

        let compatibleForLevel = false;
        if (scrollTier === 1 && itemCurrentLevel === 0) compatibleForLevel = true;
        else if (scrollTier === 2 && (itemCurrentLevel >= 0 && itemCurrentLevel <= 2)) compatibleForLevel = true;
        else if (scrollTier === 3 && (itemCurrentLevel >= 0 && itemCurrentLevel <= 4)) compatibleForLevel = true;

        if (!compatibleForLevel) {
            upgradeResultDisplay.textContent = `This scroll is not suitable for an item at +${itemCurrentLevel}.`;
            return;
        }
        
        if (playerScrolls[selectedScrollForUpgrade.type] <= 0) {
            upgradeResultDisplay.textContent = `You don't have any ${selectedScrollForUpgrade.name}.`;
            return;
        }
        if (itemCurrentLevel >= 5) {
            upgradeResultDisplay.textContent = "Item is at max level (+5).";
            return;
        }

        // --- CORE UPGRADE LOGIC WITH BOOSTER ---
        let successChance = upgradeChances[itemCurrentLevel]; // Base chance (e.g., 0.45 for 45%)
        
        // Apply scroll tier bonus
        if (scrollTier > itemBaseTier && ((scrollTier === 2 && itemBaseTier <= 1) || (scrollTier === 3 && itemBaseTier <= 2))) {
            successChance += 0.10;
        }

        // --- NEW: Find and apply the Upgrade Booster ---
        const boosterIndex = activePotions.findIndex(p => p.id === 'upgrade_booster');
        if (boosterIndex > -1) {
            successChance += activePotions[boosterIndex].effect.flatValue; // Add the flat 10% (0.10)
        }
        // --- END NEW ---

        successChance = Math.min(successChance, 1); // Cap at 100%

        upgradeResultDisplay.textContent = `Attempting upgrade... Chance: ${(successChance * 100).toFixed(0)}%`;
        upgradeItemButton.disabled = true;

        // Consume the regular scroll
        playerScrolls[selectedScrollForUpgrade.type]--;

        // --- NEW: Consume the Upgrade Booster if it was used ---
        if (boosterIndex > -1) {
            activePotions.splice(boosterIndex, 1);
            console.log("Upgrade Booster consumed.");
        }
        // --- END NEW ---

        const originalSlotId = Object.keys(equippedItems).find(slot => equippedItems[slot] === selectedItemForUpgrade.uniqueInstanceId);

        setTimeout(async () => {
            const destroyedItemMasterData = { ...selectedItemForUpgrade };
            if (Math.random() < successChance) { // SUCCESS
                const itemInvIndex = playerInventory.findIndex(invItem => invItem.uniqueInstanceId === selectedItemForUpgrade.uniqueInstanceId);
                if (itemInvIndex > -1) {
                    playerInventory[itemInvIndex].level++;
                    const updatedItem = playerInventory[itemInvIndex];
                    upgradeResultDisplay.textContent = `SUCCESS! ${selectedItemForUpgrade.name} upgraded to +${updatedItem.level}!`;
                    
                    selectedItemForUpgrade = { ...selectedItemForUpgrade, ...updatedItem, currentLevel: updatedItem.level };
                    const levelText = updatedItem.level > 0 ? `(+${updatedItem.level}) ` : '';
                    selectedItemForUpgradeDisplay.innerHTML = `Item: ${getItemIconHTML(selectedItemForUpgrade.iconUrlOrColor, selectedItemForUpgrade.type, '30px')} ${levelText}${selectedItemForUpgrade.name}`;
                    
                    // Quest checks...
                    quests.forEach(q => { 
                        if (q.metric === "itemUpgradedToPlus2" && updatedItem.level >= 2 && !q.completed && !q.claimed) { q.progress = 1; q.completed = true; if(!q.claimed) showCustomPopup(`Quest Completed: ${q.text}`, "Quest Complete!");} 
                        if (q.metric === "itemUpgradedToPlus3" && updatedItem.level >= 3 && !q.completed && !q.claimed) { q.progress = 1; q.completed = true; if(!q.claimed) showCustomPopup(`Quest Completed: ${q.text}`, "Quest Complete!");} 
                    });
                    if(document.getElementById('quests-page').classList.contains('active')) renderQuests();
                }
            } else { // FAILURE
                const itemInvIndex = playerInventory.findIndex(invItem => invItem.uniqueInstanceId === selectedItemForUpgrade.uniqueInstanceId);
                if (itemInvIndex > -1) {
                    if (originalSlotId) equippedItems[originalSlotId] = null;
                    playerInventory.splice(itemInvIndex, 1);
                    upgradeResultDisplay.textContent = `FAILURE! ${destroyedItemMasterData.name} +${itemCurrentLevel} was destroyed.`;
                    promptToCraftAgain(destroyedItemMasterData, originalSlotId);
                }
                selectedItemForUpgrade = null;
                selectedItemForUpgradeDisplay.innerHTML = `Item: None`;
            }

            selectedScrollForUpgrade = null;
            selectedScrollForUpgradeDisplay.innerHTML = `Scroll: None`;
            
            updateUpgradeSuccessRateDisplay();
            renderInventory();
            renderCraftingItems();
            renderMaterials();
            renderActivePotions(); // Re-render potions to show the booster is gone
            renderActiveSpecialties();
            upgradeItemButton.disabled = false;
            if (currentUser.uid) saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
        }, 1000);
    });
}


            // --- Final Initializations ---
            initializeTheme(); 
            setInterval(updateTimers, 1000);
            document.querySelectorAll('.adventure-num-select').forEach(select => { select.value = "5"; });
handleWalletDisconnected(); // This will reset state and prompt for connection
initializeTheme();
            
            const connectWalletBtn = document.getElementById('connectWalletBtn'); const walletDropdown = document.getElementById('walletDropdown'); const walletOptions = walletDropdown.querySelectorAll('li'); const walletAddressDisplay = document.getElementById('walletAddressDisplay');
            let connectedAccount = null; let connectedWalletName = null;
// --- START OF FULL updateWalletDisplay FUNCTION TO REPLACE ---
// (This will replace your existing function from approx. line 5407 to its end)



function updateWalletDisplay(account, walletName = '', idsWereLoadedForThisCall = false, crawlersWereLoadedForThisCall = false) {
    console.log("updateWalletDisplay CALLED. Passed idsWereLoadedForThisCall:", idsWereLoadedForThisCall, "Passed crawlersWereLoadedForThisCall:", crawlersWereLoadedForThisCall, "Passed Account:", account, "Passed WalletName:", walletName);
    const connectWalletBtnElement = document.getElementById('connectWalletBtn');
    const walletAddressDisplayElement = document.getElementById('walletAddressDisplay');
    const playerNicknameDisplayElement = document.getElementById('playerNicknameDisplay');

    if (account) {
        const shortAddress = `${account.substring(0, 6)}...${account.substring(account.length - 4)}`;
        if (connectWalletBtnElement) {
            connectWalletBtnElement.textContent = `${walletName}: ${shortAddress}`;
            connectWalletBtnElement.classList.add('connected');
        }
        if (walletAddressDisplayElement) walletAddressDisplayElement.textContent = `Wallet: ${account}`;

        walletVerificationPendingForBonus = false; // Reset this flag as wallet is now connected

        // Close popups related to wallet verification
        if (customPopup && !customPopup.classList.contains('hidden') && customPopupTitleEl) {
            const currentPopupTitle = customPopupTitleEl.textContent;
            if (currentPopupTitle === "Wallet Bonus Information" ||
                currentPopupTitle === "Wallet Connection Required" ||
                currentPopupTitle === "Verify Wallet Bonus" ||
                currentPopupTitle === "Wallet Verification Needed") {
                hideCustomPopup();
            }
        }

        // Logic for fetching inscriptions and crawlers
        if (idsWereLoadedForThisCall && account && walletName) {
            console.log("updateWalletDisplay: Conditions MET for fetching inscriptions. idsWereLoadedForThisCall:", idsWereLoadedForThisCall);
            // fetchWalletInscriptions will handle its own logic for updating ordinalBonusAdventurers
            // and saving if the bonus changes.
            fetchWalletInscriptions(account, walletName);

            if (crawlersWereLoadedForThisCall) {
                console.log("updateWalletDisplay: Conditions MET for fetching crawlers. crawlersWereLoadedForThisCall:", crawlersWereLoadedForThisCall);
                fetchPlayerDungeonCrawlers(account, walletName);
            }
        } else {
            console.warn("updateWalletDisplay: Wallet connected, but asset ID lists not indicated as loaded OR account/name issue. Ordinal/Crawler check skipped for now. Details - idsWereLoadedForThisCall:", idsWereLoadedForThisCall, "crawlersWereLoadedForThisCall:", crawlersWereLoadedForThisCall, "account:", account, "walletName:", walletName);
            if (userOrdinalsDisplayElement) {
                 userOrdinalsDisplayElement.style.display = 'block';
                 if(userOrdinalsListElement) userOrdinalsListElement.innerHTML = "<p>Could not check Ordinals: Game's collection ID list might not be ready or wallet info missing. This will be re-attempted.</p>";
            }
            // DO NOT reset ordinalBonusAdventurers or save here.
            // The loaded state from applyLoadedGameState should persist until fetchWalletInscriptions updates it.
        }

        if (playerNicknameDisplayElement && userNickname) { // userNickname should be set by applyLoadedGameState or createInitialGameState
            playerNicknameDisplayElement.textContent = userNickname;
        }

    } else { // Wallet disconnected or not present
        if (connectWalletBtnElement) {
            connectWalletBtnElement.textContent = 'CONNECT WALLET';
            connectWalletBtnElement.classList.remove('connected');
        }
        if (walletAddressDisplayElement) walletAddressDisplayElement.textContent = '';
        if (playerNicknameDisplayElement && typeof userNickname !== 'undefined') { // Check if userNickname is defined
             playerNicknameDisplayElement.textContent = 'Voyager'; // Reset to default if disconnected
        }


        if (userOrdinalsDisplayElement) userOrdinalsDisplayElement.style.display = 'none';
        if (userOrdinalsListElement) userOrdinalsListElement.innerHTML = '';
    }
}
// --- END OF FULL updateWalletDisplay FUNCTION TO REPLACE ---
            if(connectWalletBtn && walletDropdown) { connectWalletBtn.addEventListener('click', (event) => { event.stopPropagation(); walletDropdown.style.display = walletDropdown.style.display === 'block' ? 'none' : 'block'; }); document.addEventListener('click', (event) => { if (walletDropdown && connectWalletBtn && !connectWalletBtn.contains(event.target) && !walletDropdown.contains(event.target)) { walletDropdown.style.display = 'none'; } }); }
       async function connectWithSatsConnect(walletTypeHint = null) {
        // Check for SatsConnect availability right when the function is called
        if (typeof SatsConnect === 'undefined' || typeof SatsConnect.getAddresses === 'undefined') {
            console.error("SatsConnect object is not available. The library might not have loaded yet or failed to load.");
            showCustomPopup('Sats Connect library is not ready. Please try again in a moment or ensure it is loaded.', "Wallet Error");
            return;
        }

        try {
            SatsConnect.getAddresses({
                payload: {
                    purposes: ['ordinals', 'payment'],
                    message: 'Connect to Punk Voyage Adventures',
                    network: { type: 'Mainnet' },
                },
                onFinish: (response) => {
                    const ordAddress = response.addresses.find(a => a.purpose === 'ordinals');
                    const payAddress = response.addresses.find(a => a.purpose === 'payment');
                    let addr = ordAddress ? ordAddress.address : (payAddress ? payAddress.address : null);
                    if (addr) {
                        connectedAccount = addr;
                        let name = walletTypeHint ? walletTypeHint.replace('satsconnect_', '').toUpperCase() : "BTC";
                        if (name === "GENERAL") name = "BTC";
                        connectedWalletName = name;
                        updateWalletDisplay(connectedAccount, connectedWalletName); // This will trigger fetchWalletInscriptions if conditions are met
                    } else {
                        showCustomPopup('No suitable Bitcoin address found via SatsConnect.', 'Wallet Error');
                    }
                },
                onCancel: () => {
                    console.log('SatsConnect connection canceled by user.');
                },
            });
        } catch (e) {
            console.error('Error during SatsConnect.getAddresses call:', e);
            showCustomPopup(`An error occurred with SatsConnect: ${e.message || 'Unknown error'}`, 'Wallet Error');
        }
    }         
    
async function handleWalletConnected(walletAddress, walletName) {
    console.log(`Wallet connected: ${walletName} - ${walletAddress} (handleWalletConnected client-only flow start)`);
    window.connectedAccount = walletAddress;
    window.connectedWalletName = walletName;
    currentUser = { uid: walletAddress, name: walletName };

    let isNewUserFlow = false;
    let successfullyLoadedExistingState = false;

    try {
        console.log(`handleWalletConnected: Attempting to load game state for ${walletAddress} directly.`);
        const loadResult = await loadGameStateFromFirebase(walletAddress);

        if (loadResult.status === 'success') {
            console.log("Existing game state found. Applying it.", walletAddress);
            applyLoadedGameState(loadResult.data);
            successfullyLoadedExistingState = true;
            if (userNickname && userNickname.startsWith("Voyager-")) {
                isNewUserFlow = true; // Prompt for nickname change even if state loaded, if it's a default name
            }
        } else if (loadResult.status === 'not_found') {
            console.log("No game state found (document does not exist). Creating initial state for new user.", walletAddress);
            isNewUserFlow = true;
            await createInitialGameState(walletAddress);
            successfullyLoadedExistingState = true; // Technically, we successfully created a new state
        } else { // This means loadResult.status === 'error'
            console.error("Failed to load game state due to an error:", loadResult.error.message);
            // DO NOT create initial game state if loading failed due to an error (like network)
            // Show a message and potentially lock the game or parts of it
            showCustomPopup(
                `Could not load your game data from the server. Error: ${loadResult.error.message}.<br><br>Please check your internet connection and try refreshing. You might be in a temporary offline mode. Some features might be unavailable or progress might not save.`,
                "Data Load Failed",
                {
                    confirmText: "Refresh Page",
                    confirmCallback: (confirmed) => {
                        if (confirmed) window.location.reload();
                    },
                    cancelText: "Continue Offline (Risky)",
                    cancelCallback: () => { /* User chose to continue, acknowledge the risk */ }
                }
            );
            // Update display to show connected wallet but indicate data issue
            updateWalletDisplay(walletAddress, walletName, false, false); // Pass false for loaded flags
            // Optionally, you might want to disable most game interactions here
            // or load a very minimal "offline" version of the UI.
            // For now, we'll let them proceed but with warnings.
            // Resetting game state fully via handleWalletDisconnected() might be too aggressive here
            // as the user might just want to wait for connection to restore.
            return; // Exit handleWalletConnected early
        }
    } catch (criticalError) { // Catch any unexpected errors from the try block itself
        console.error("Critical error during client-side game state loading/creation in handleWalletConnected:", criticalError, criticalError.stack);
        showCustomPopup(`A critical error occurred: ${criticalError.message}. Please refresh.`, "Critical Error", { confirmCallback: () => window.location.reload()});
        await handleWalletDisconnected(); // Clean up fully in this case
        return;
    }

    // PRE-LOAD ORDINAL/CRAWLER ID DEFINITIONS (if not already done)
    let gameCollectionIdsReady = punkVoyageIdsLoaded;
    if (!punkVoyageIdsLoaded) {
        gameCollectionIdsReady = await loadPunkVoyageIds();
    }
    if (!dungeonCrawlerIdsLoaded) {
        await loadDungeonCrawlerIds();
    }

    // UPDATE WALLET DISPLAY & TRIGGER CLIENT-SIDE ORDINAL/CRAWLER FETCH
    updateWalletDisplay(walletAddress, walletName, gameCollectionIdsReady, dungeonCrawlerIdsLoaded);

    const currentThemeIsDark = body.classList.contains('dark-mode');
    loadTwitterWidget(currentThemeIsDark ? 'dark' : 'light');

    if (isNewUserFlow && successfullyLoadedExistingState) { // Only prompt if we didn't hit a load error
        setTimeout(() => {
            promptAndSetNickname(walletAddress);
        }, 500);
    }

    if (adminRafflePanel) {
        if (currentUser && currentUser.uid && ADMIN_WALLET_ADDRESSES.includes(currentUser.uid.toLowerCase())) {
            adminRafflePanel.classList.remove('hidden');
        } else {
            adminRafflePanel.classList.add('hidden');
        }
    }
    if (successfullyLoadedExistingState) { // Only switch to adventures page if state is good
        showPage('adventures-page');
    }
    console.log("handleWalletConnected (client-only flow): Processing finished.");
}



         async function handleWalletDisconnected() { // Added "async" here
             console.log("Wallet disconnected or no account found / Initializing disconnected state.");

             // --- TRY TO SAVE CURRENT STATE BEFORE RESETTING ---
             if (currentUser && currentUser.uid) {
                 console.log(`Attempting to save game state for user ${currentUser.uid} before full disconnect processing.`);
                 try {
                     await saveGameStateToFirebase(currentUser.uid, getCurrentGameState());
                     console.log(`Game state saved for ${currentUser.uid} due to disconnect.`);
                 } catch (error) {
                     console.error(`Error saving game state during disconnect for ${currentUser.uid}:`, error);
                     // Optionally, you could show a non-critical popup here if saving fails,
                     // but the disconnect process should still continue.
                 }
             } else {
                 console.warn("handleWalletDisconnected: currentUser or currentUser.uid was already null/undefined. Cannot save state.");
             }
             // --- END SAVE STATE ---

             currentUser = null;
             userNickname = ''; // Reset global nickname variable

             // Explicitly set the global variables to null
             window.connectedAccount = null;
             window.connectedWalletName = null;

             resetGameStateToDefaults(); // This should handle resetting game-specific states
             if (adminRafflePanel) adminRafflePanel.classList.add('hidden'); // <<< ADD THIS LINE TO HIDE PANEL
             updateStatsDisplay();       // Update UI based on reset state
             updateWalletDisplay(null);  // This will set button to "CONNECT WALLET"

             showPage('adventures-page'); // Show a default page
             if(sidebarActiveAdventuresList) {
                 sidebarActiveAdventuresList.innerHTML = '<p style="text-align:center;">Connect wallet to see active tasks.</p>';
             }
             if(userOrdinalsDisplayElement) userOrdinalsDisplayElement.style.display = 'none';
             if(userOrdinalsListElement) userOrdinalsListElement.innerHTML = '';
             if(playerNicknameDisplay) playerNicknameDisplay.textContent = "Voyager"; // Reset display

             console.log("handleWalletDisconnected finished. State reset. (Attempted save before reset)");
         }
         
    async function promptAndSetNickname(walletAddressForNickname) {
            // userNickname should already be set globally by either:
            // 1. applyLoadedGameState (if an existing user with a saved nickname)
            // 2. createInitialGameState (if a new user, it sets the "Voyager-XXXXX" format)
            const currentNameToSuggest = userNickname || `Voyager-${walletAddressForNickname.slice(-5).toUpperCase()}`; // Fallback if userNickname is somehow empty

            const newNicknameInput = prompt(`Set/Update your in-game nickname (max 20 chars, current: ${currentNameToSuggest}):\nLeave blank or cancel to keep current name.`, currentNameToSuggest);

            if (newNicknameInput === null) {
                // User pressed Cancel
                showCustomPopup(`Nickname change cancelled. Current nickname: "${userNickname}" remains.`, "Nickname Unchanged");
                return; // Exit the function
            }

            const newNicknameTrimmed = newNicknameInput.trim();

            if (newNicknameTrimmed === "") {
                // User submitted an empty string (or only spaces)
                showCustomPopup(`Nickname cannot be empty. Your current nickname: "${userNickname}" remains.`, "Nickname Error");
                return; // Exit the function
            }

            if (newNicknameTrimmed === userNickname) {
                // User submitted the same nickname they already have
                showCustomPopup(`Nickname is already "${userNickname}". No change made.`, "Nickname Info");
                return; // Exit the function
            }

            // If we reach here, the user entered a new, non-empty, different nickname
            userNickname = newNicknameTrimmed.substring(0, 20); // Apply max length

            if (playerNicknameDisplay) {
                playerNicknameDisplay.textContent = userNickname;
            }

            // Update the nickname in Firebase
            // Ensure currentUser and its uid match the walletAddressForNickname to prevent potential mismatches
            // although in the current flow, handleWalletConnected sets currentUser.uid to walletAddress.
            if (currentUser && currentUser.uid && currentUser.uid.toLowerCase() === walletAddressForNickname.toLowerCase()) {
                const playerDocRef = doc(db, 'playerProgress', walletAddressForNickname);
                try {
                    await updateDoc(playerDocRef, { nickname: userNickname });
                    console.log("Nickname updated in Firebase to:", userNickname);
                    showCustomPopup(`Nickname successfully set to: "${userNickname}"`, "Nickname Set");
                } catch (error) {
                    console.error("Error updating nickname in Firebase:", error);
                    // Revert client-side change if Firebase update fails, and notify user
                    userNickname = currentNameToSuggest; // Revert to what it was before the prompt
                    if (playerNicknameDisplay) playerNicknameDisplay.textContent = userNickname;
                    showCustomPopup("Could not save nickname to server. Please try again later.", "Nickname Save Error");
                }
            } else {
                console.warn("Mismatch or missing currentUser.uid when trying to save nickname. Nickname not saved to Firebase.", { currentUid: currentUser ? currentUser.uid : 'null', walletForNickname: walletAddressForNickname });
                // Nickname changed client-side but not saved. This state is temporary until next load.
                showCustomPopup(`Nickname "${userNickname}" set locally, but an issue occurred saving to server. It may not persist.`, "Partial Nickname Update");
            }
        }


if (walletOptions) {
    walletOptions.forEach(option => {
        option.addEventListener('click', async (event) => {
            const walletType = event.target.dataset.wallet;
            if(walletDropdown) walletDropdown.style.display = 'none';
            connectedAccount = null;
            connectedWalletName = null;
            updateWalletDisplay(null);

            if (walletType === 'unisat') {
                await connectUnisat();
            } else if (walletType === 'xverse_provider') { // <<< ADD THIS ELSE IF BLOCK
                await connectXverseProvider();
            } else if (walletType && walletType.startsWith('satsconnect_')) {
                // This will now handle 'satsconnect_magiceden' and 'satsconnect_general'
                // and any other 'satsconnect_whatever' you might add.
                // The original 'satsconnect_xverse' is effectively replaced by 'xverse_provider'
                // unless you kept/added another list item for it.
                const satsConnectHint = walletType.substring('satsconnect_'.length);
                await connectWithSatsConnect(satsConnectHint);
            }
        });
    });
}

async function connectUnisat() { // <<< MAKE SURE THIS LINE AND THE WHOLE FUNCTION IS THERE
    try {
        if (typeof window.unisat !== 'undefined') {
            const accounts = await window.unisat.requestAccounts();
            if (accounts && accounts.length > 0) {
                const walletAddress = accounts[0];
                const walletName = 'UniSat';
                await handleWalletConnected(walletAddress, walletName);

                window.unisat.on('accountsChanged', async (newAccs) => {
                    if (connectedWalletName === 'UniSat') {
                        const newAddress = (newAccs && newAccs.length > 0) ? newAccs[0] : null;
                        if (newAddress !== connectedAccount) {
                            if (newAddress) {
                                await handleWalletConnected(newAddress, walletName);
                            } else {
                                await handleWalletDisconnected();
                            }
                        }
                    }
                });
            }
        } else {
            window.open('https://unisat.io/', '_blank');
        }
    } catch (e) {
        console.error('UniSat error:', e);
        showCustomPopup('An error occurred with UniSat Wallet.', 'Wallet Error');
    }
} 

            async function connectXverseProvider() {
    let xverseBitcoinProvider; // Specific variable for Xverse provider
    if (typeof window !== "undefined") {
        const anyWindow = window; // Use 'any' to access potentially non-standard window properties
        if (anyWindow?.XverseProviders?.BitcoinProvider) {
            xverseBitcoinProvider = anyWindow.XverseProviders.BitcoinProvider;
        }
    }

    if (!xverseBitcoinProvider) {
        showCustomPopup('Xverse Wallet provider not found. Please ensure Xverse Wallet is installed and enabled.', "Wallet Error");
        // Consider adding a link to Xverse website: window.open('https://www.xverse.app/', '_blank');
        return;
    }

    try {
        // Using 'wallet_connect' as per your snippet
        const response = await xverseBitcoinProvider.request('wallet_connect', { addresses: ['ordinals', 'payment'] });

        if (response.error) {
            console.error('Xverse connection error in response:', response.error);
            showCustomPopup(response.error.message || 'Xverse connection failed.', 'Wallet Error');
            return;
        }

        // Processing the response as per your snippet
        if (response.result && response.result.addresses && response.result.addresses.length > 0) {
            const addresses = response.result.addresses
                .filter(address => address.addressType !== "stacks"); // Filter out Stacks addresses as per your snippet

            const ordAddressInfo = addresses.find(a => a.purpose === 'ordinals');
            const payAddressInfo = addresses.find(a => a.purpose === 'payment');

            let addrToUse = null;
            // Prioritize ordinals address if available
            if (ordAddressInfo) {
                addrToUse = ordAddressInfo.address;
            } else if (payAddressInfo) {
                addrToUse = payAddressInfo.address;
            }
            
            if (addrToUse) {
                // DO NOT set connectedAccount and connectedWalletName here directly.
                // Let handleWalletConnected do it.
                await handleWalletConnected(addrToUse, 'Xverse'); // Pass directly to the handler

                // You might want to check Xverse documentation for an 'accountsChanged' event
                // to handle account switches in the wallet, similar to UniSat.
                // Example (you'll need to verify event name and logic with Xverse docs):
                /*
                if (xverseBitcoinProvider.on) { // Check if 'on' method exists
                    xverseBitcoinProvider.on('accountsChanged', async (newAccounts) => {
                        if (connectedWalletName === 'Xverse') { // Ensure it's for Xverse
                            let newAddress = null;
                            if (newAccounts && newAccounts.result && newAccounts.result.addresses && newAccounts.result.addresses.length > 0) {
                                const newOrdInfo = newAccounts.result.addresses.find(a => a.purpose === 'ordinals' && a.addressType !== "stacks");
                                const newPayInfo = newAccounts.result.addresses.find(a => a.purpose === 'payment' && a.addressType !== "stacks");
                                newAddress = newOrdInfo ? newOrdInfo.address : (newPayInfo ? newPayInfo.address : null);
                            }

                            if (newAddress && newAddress !== connectedAccount) {
                                await handleWalletConnected(newAddress, 'Xverse');
                            } else if (!newAddress && connectedAccount) {
                                await handleWalletDisconnected();
                            }
                        }
                    });
                }
                */
            } else {
                showCustomPopup('Could not retrieve a suitable Bitcoin address from Xverse Wallet.', 'Wallet Error');
            }
        } else {
            showCustomPopup('No suitable addresses returned from Xverse Wallet.', 'Wallet Error');
        }

    } catch (e) { // Catch errors from the provider.request call itself or other issues
        console.error('Xverse Wallet connection exception:', e);
        let errorMessage = 'An error occurred with Xverse Wallet.';
        if (e && e.message) {
            errorMessage = e.message;
        } else if (typeof e === 'string') {
            errorMessage = e; // Some providers might throw string errors
        }
        showCustomPopup(errorMessage, 'Wallet Error');
    }
}


            const toggleMaterialsBtn = document.getElementById('toggleMaterialsBtn');
            if (toggleMaterialsBtn && materialsListContainer) {
                // Check local storage for saved state
                const isMaterialsHidden = localStorage.getItem('materialsHidden') === 'true';
                if (isMaterialsHidden) {
                    materialsListContainer.classList.add('hidden');
                    toggleMaterialsBtn.textContent = 'Show';
                }

                toggleMaterialsBtn.addEventListener('click', () => {
                    materialsListContainer.classList.toggle('hidden');
                    if (materialsListContainer.classList.contains('hidden')) {
                        toggleMaterialsBtn.textContent = 'Show';
                        localStorage.setItem('materialsHidden', 'true');
                    } else {
                        toggleMaterialsBtn.textContent = 'Hide';
                        localStorage.setItem('materialsHidden', 'false');
                        
                    }
                });
            }
             if (toggleSpecialtiesBtn && specialtiesListContainer) {
            const isSpecialtiesHidden = localStorage.getItem('specialtiesHidden') === 'true';
            if (isSpecialtiesHidden) {
                specialtiesListContainer.classList.add('hidden');
                toggleSpecialtiesBtn.textContent = 'Show';
            } else {
                 // Ensure it's visible by default if not explicitly hidden
                specialtiesListContainer.classList.remove('hidden');
                toggleSpecialtiesBtn.textContent = 'Hide';
            }

            toggleSpecialtiesBtn.addEventListener('click', () => {
                specialtiesListContainer.classList.toggle('hidden');
                if (specialtiesListContainer.classList.contains('hidden')) {
                    toggleSpecialtiesBtn.textContent = 'Show';
                    localStorage.setItem('specialtiesHidden', 'true');
                } else {
                    toggleSpecialtiesBtn.textContent = 'Hide';
                    localStorage.setItem('specialtiesHidden', 'false');
                }
            });
        }
        }); // End of 'firebaseReady' event listener
    </script>
</body>
</html>
